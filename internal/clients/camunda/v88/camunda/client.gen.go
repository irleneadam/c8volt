// Package camunda provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package camunda

import (
	"bytes"
	"context"
	"encoding/json"
	"encoding/xml"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for AuthorizationSearchQuerySortRequestField.
const (
	OwnerId      AuthorizationSearchQuerySortRequestField = "ownerId"
	OwnerType    AuthorizationSearchQuerySortRequestField = "ownerType"
	ResourceId   AuthorizationSearchQuerySortRequestField = "resourceId"
	ResourceType AuthorizationSearchQuerySortRequestField = "resourceType"
)

// Defines values for BatchOperationErrorType.
const (
	QUERYFAILED              BatchOperationErrorType = "QUERY_FAILED"
	RESULTBUFFERSIZEEXCEEDED BatchOperationErrorType = "RESULT_BUFFER_SIZE_EXCEEDED"
)

// Defines values for BatchOperationItemResponseState.
const (
	BatchOperationItemResponseStateACTIVE    BatchOperationItemResponseState = "ACTIVE"
	BatchOperationItemResponseStateCANCELED  BatchOperationItemResponseState = "CANCELED"
	BatchOperationItemResponseStateCOMPLETED BatchOperationItemResponseState = "COMPLETED"
	BatchOperationItemResponseStateFAILED    BatchOperationItemResponseState = "FAILED"
	BatchOperationItemResponseStateSKIPPED   BatchOperationItemResponseState = "SKIPPED"
)

// Defines values for BatchOperationItemSearchQuerySortRequestField.
const (
	BatchOperationItemSearchQuerySortRequestFieldBatchOperationKey  BatchOperationItemSearchQuerySortRequestField = "batchOperationKey"
	BatchOperationItemSearchQuerySortRequestFieldItemKey            BatchOperationItemSearchQuerySortRequestField = "itemKey"
	BatchOperationItemSearchQuerySortRequestFieldProcessInstanceKey BatchOperationItemSearchQuerySortRequestField = "processInstanceKey"
	BatchOperationItemSearchQuerySortRequestFieldState              BatchOperationItemSearchQuerySortRequestField = "state"
)

// Defines values for BatchOperationItemStateEnum.
const (
	BatchOperationItemStateEnumACTIVE    BatchOperationItemStateEnum = "ACTIVE"
	BatchOperationItemStateEnumCANCELED  BatchOperationItemStateEnum = "CANCELED"
	BatchOperationItemStateEnumCOMPLETED BatchOperationItemStateEnum = "COMPLETED"
	BatchOperationItemStateEnumFAILED    BatchOperationItemStateEnum = "FAILED"
)

// Defines values for BatchOperationResponseState.
const (
	BatchOperationResponseStateACTIVE             BatchOperationResponseState = "ACTIVE"
	BatchOperationResponseStateCANCELED           BatchOperationResponseState = "CANCELED"
	BatchOperationResponseStateCOMPLETED          BatchOperationResponseState = "COMPLETED"
	BatchOperationResponseStateCREATED            BatchOperationResponseState = "CREATED"
	BatchOperationResponseStateFAILED             BatchOperationResponseState = "FAILED"
	BatchOperationResponseStatePARTIALLYCOMPLETED BatchOperationResponseState = "PARTIALLY_COMPLETED"
	BatchOperationResponseStateSUSPENDED          BatchOperationResponseState = "SUSPENDED"
)

// Defines values for BatchOperationSearchQuerySortRequestField.
const (
	BatchOperationSearchQuerySortRequestFieldBatchOperationKey BatchOperationSearchQuerySortRequestField = "batchOperationKey"
	BatchOperationSearchQuerySortRequestFieldEndDate           BatchOperationSearchQuerySortRequestField = "endDate"
	BatchOperationSearchQuerySortRequestFieldOperationType     BatchOperationSearchQuerySortRequestField = "operationType"
	BatchOperationSearchQuerySortRequestFieldStartDate         BatchOperationSearchQuerySortRequestField = "startDate"
	BatchOperationSearchQuerySortRequestFieldState             BatchOperationSearchQuerySortRequestField = "state"
)

// Defines values for BatchOperationStateEnum.
const (
	BatchOperationStateEnumACTIVE             BatchOperationStateEnum = "ACTIVE"
	BatchOperationStateEnumCANCELED           BatchOperationStateEnum = "CANCELED"
	BatchOperationStateEnumCOMPLETED          BatchOperationStateEnum = "COMPLETED"
	BatchOperationStateEnumCREATED            BatchOperationStateEnum = "CREATED"
	BatchOperationStateEnumFAILED             BatchOperationStateEnum = "FAILED"
	BatchOperationStateEnumPARTIALLYCOMPLETED BatchOperationStateEnum = "PARTIALLY_COMPLETED"
	BatchOperationStateEnumSUSPENDED          BatchOperationStateEnum = "SUSPENDED"
)

// Defines values for BatchOperationTypeEnum.
const (
	BatchOperationTypeEnumADDVARIABLE              BatchOperationTypeEnum = "ADD_VARIABLE"
	BatchOperationTypeEnumCANCELPROCESSINSTANCE    BatchOperationTypeEnum = "CANCEL_PROCESS_INSTANCE"
	BatchOperationTypeEnumDELETEDECISIONDEFINITION BatchOperationTypeEnum = "DELETE_DECISION_DEFINITION"
	BatchOperationTypeEnumDELETEPROCESSDEFINITION  BatchOperationTypeEnum = "DELETE_PROCESS_DEFINITION"
	BatchOperationTypeEnumDELETEPROCESSINSTANCE    BatchOperationTypeEnum = "DELETE_PROCESS_INSTANCE"
	BatchOperationTypeEnumMIGRATEPROCESSINSTANCE   BatchOperationTypeEnum = "MIGRATE_PROCESS_INSTANCE"
	BatchOperationTypeEnumMODIFYPROCESSINSTANCE    BatchOperationTypeEnum = "MODIFY_PROCESS_INSTANCE"
	BatchOperationTypeEnumRESOLVEINCIDENT          BatchOperationTypeEnum = "RESOLVE_INCIDENT"
	BatchOperationTypeEnumUPDATEVARIABLE           BatchOperationTypeEnum = "UPDATE_VARIABLE"
)

// Defines values for CorrelatedMessageSubscriptionSearchQuerySortRequestField.
const (
	CorrelatedMessageSubscriptionSearchQuerySortRequestFieldCorrelationKey       CorrelatedMessageSubscriptionSearchQuerySortRequestField = "correlationKey"
	CorrelatedMessageSubscriptionSearchQuerySortRequestFieldCorrelationTime      CorrelatedMessageSubscriptionSearchQuerySortRequestField = "correlationTime"
	CorrelatedMessageSubscriptionSearchQuerySortRequestFieldElementId            CorrelatedMessageSubscriptionSearchQuerySortRequestField = "elementId"
	CorrelatedMessageSubscriptionSearchQuerySortRequestFieldElementInstanceKey   CorrelatedMessageSubscriptionSearchQuerySortRequestField = "elementInstanceKey"
	CorrelatedMessageSubscriptionSearchQuerySortRequestFieldMessageKey           CorrelatedMessageSubscriptionSearchQuerySortRequestField = "messageKey"
	CorrelatedMessageSubscriptionSearchQuerySortRequestFieldMessageName          CorrelatedMessageSubscriptionSearchQuerySortRequestField = "messageName"
	CorrelatedMessageSubscriptionSearchQuerySortRequestFieldPartitionId          CorrelatedMessageSubscriptionSearchQuerySortRequestField = "partitionId"
	CorrelatedMessageSubscriptionSearchQuerySortRequestFieldProcessDefinitionId  CorrelatedMessageSubscriptionSearchQuerySortRequestField = "processDefinitionId"
	CorrelatedMessageSubscriptionSearchQuerySortRequestFieldProcessDefinitionKey CorrelatedMessageSubscriptionSearchQuerySortRequestField = "processDefinitionKey"
	CorrelatedMessageSubscriptionSearchQuerySortRequestFieldProcessInstanceKey   CorrelatedMessageSubscriptionSearchQuerySortRequestField = "processInstanceKey"
	CorrelatedMessageSubscriptionSearchQuerySortRequestFieldSubscriptionKey      CorrelatedMessageSubscriptionSearchQuerySortRequestField = "subscriptionKey"
	CorrelatedMessageSubscriptionSearchQuerySortRequestFieldTenantId             CorrelatedMessageSubscriptionSearchQuerySortRequestField = "tenantId"
)

// Defines values for DecisionDefinitionSearchQuerySortRequestField.
const (
	DecisionDefinitionSearchQuerySortRequestFieldDecisionDefinitionId    DecisionDefinitionSearchQuerySortRequestField = "decisionDefinitionId"
	DecisionDefinitionSearchQuerySortRequestFieldDecisionDefinitionKey   DecisionDefinitionSearchQuerySortRequestField = "decisionDefinitionKey"
	DecisionDefinitionSearchQuerySortRequestFieldDecisionRequirementsId  DecisionDefinitionSearchQuerySortRequestField = "decisionRequirementsId"
	DecisionDefinitionSearchQuerySortRequestFieldDecisionRequirementsKey DecisionDefinitionSearchQuerySortRequestField = "decisionRequirementsKey"
	DecisionDefinitionSearchQuerySortRequestFieldName                    DecisionDefinitionSearchQuerySortRequestField = "name"
	DecisionDefinitionSearchQuerySortRequestFieldTenantId                DecisionDefinitionSearchQuerySortRequestField = "tenantId"
	DecisionDefinitionSearchQuerySortRequestFieldVersion                 DecisionDefinitionSearchQuerySortRequestField = "version"
)

// Defines values for DecisionDefinitionTypeEnum.
const (
	DecisionDefinitionTypeEnumDECISIONTABLE     DecisionDefinitionTypeEnum = "DECISION_TABLE"
	DecisionDefinitionTypeEnumLITERALEXPRESSION DecisionDefinitionTypeEnum = "LITERAL_EXPRESSION"
	DecisionDefinitionTypeEnumUNKNOWN           DecisionDefinitionTypeEnum = "UNKNOWN"
	DecisionDefinitionTypeEnumUNSPECIFIED       DecisionDefinitionTypeEnum = "UNSPECIFIED"
)

// Defines values for DecisionInstanceSearchQuerySortRequestField.
const (
	DecisionInstanceSearchQuerySortRequestFieldDecisionDefinitionId          DecisionInstanceSearchQuerySortRequestField = "decisionDefinitionId"
	DecisionInstanceSearchQuerySortRequestFieldDecisionDefinitionKey         DecisionInstanceSearchQuerySortRequestField = "decisionDefinitionKey"
	DecisionInstanceSearchQuerySortRequestFieldDecisionDefinitionName        DecisionInstanceSearchQuerySortRequestField = "decisionDefinitionName"
	DecisionInstanceSearchQuerySortRequestFieldDecisionDefinitionType        DecisionInstanceSearchQuerySortRequestField = "decisionDefinitionType"
	DecisionInstanceSearchQuerySortRequestFieldDecisionDefinitionVersion     DecisionInstanceSearchQuerySortRequestField = "decisionDefinitionVersion"
	DecisionInstanceSearchQuerySortRequestFieldDecisionEvaluationInstanceKey DecisionInstanceSearchQuerySortRequestField = "decisionEvaluationInstanceKey"
	DecisionInstanceSearchQuerySortRequestFieldDecisionEvaluationKey         DecisionInstanceSearchQuerySortRequestField = "decisionEvaluationKey"
	DecisionInstanceSearchQuerySortRequestFieldElementInstanceKey            DecisionInstanceSearchQuerySortRequestField = "elementInstanceKey"
	DecisionInstanceSearchQuerySortRequestFieldEvaluationDate                DecisionInstanceSearchQuerySortRequestField = "evaluationDate"
	DecisionInstanceSearchQuerySortRequestFieldEvaluationFailure             DecisionInstanceSearchQuerySortRequestField = "evaluationFailure"
	DecisionInstanceSearchQuerySortRequestFieldProcessDefinitionKey          DecisionInstanceSearchQuerySortRequestField = "processDefinitionKey"
	DecisionInstanceSearchQuerySortRequestFieldProcessInstanceKey            DecisionInstanceSearchQuerySortRequestField = "processInstanceKey"
	DecisionInstanceSearchQuerySortRequestFieldState                         DecisionInstanceSearchQuerySortRequestField = "state"
	DecisionInstanceSearchQuerySortRequestFieldTenantId                      DecisionInstanceSearchQuerySortRequestField = "tenantId"
)

// Defines values for DecisionInstanceStateEnum.
const (
	DecisionInstanceStateEnumEVALUATED   DecisionInstanceStateEnum = "EVALUATED"
	DecisionInstanceStateEnumFAILED      DecisionInstanceStateEnum = "FAILED"
	DecisionInstanceStateEnumUNKNOWN     DecisionInstanceStateEnum = "UNKNOWN"
	DecisionInstanceStateEnumUNSPECIFIED DecisionInstanceStateEnum = "UNSPECIFIED"
)

// Defines values for DecisionRequirementsSearchQuerySortRequestField.
const (
	DecisionRequirementsSearchQuerySortRequestFieldDecisionRequirementsId   DecisionRequirementsSearchQuerySortRequestField = "decisionRequirementsId"
	DecisionRequirementsSearchQuerySortRequestFieldDecisionRequirementsKey  DecisionRequirementsSearchQuerySortRequestField = "decisionRequirementsKey"
	DecisionRequirementsSearchQuerySortRequestFieldDecisionRequirementsName DecisionRequirementsSearchQuerySortRequestField = "decisionRequirementsName"
	DecisionRequirementsSearchQuerySortRequestFieldTenantId                 DecisionRequirementsSearchQuerySortRequestField = "tenantId"
	DecisionRequirementsSearchQuerySortRequestFieldVersion                  DecisionRequirementsSearchQuerySortRequestField = "version"
)

// Defines values for DocumentReferenceCamundaDocumentType.
const (
	Camunda DocumentReferenceCamundaDocumentType = "camunda"
)

// Defines values for ElementInstanceFilterType.
const (
	ElementInstanceFilterTypeADHOCSUBPROCESS              ElementInstanceFilterType = "AD_HOC_SUB_PROCESS"
	ElementInstanceFilterTypeADHOCSUBPROCESSINNERINSTANCE ElementInstanceFilterType = "AD_HOC_SUB_PROCESS_INNER_INSTANCE"
	ElementInstanceFilterTypeBOUNDARYEVENT                ElementInstanceFilterType = "BOUNDARY_EVENT"
	ElementInstanceFilterTypeBUSINESSRULETASK             ElementInstanceFilterType = "BUSINESS_RULE_TASK"
	ElementInstanceFilterTypeCALLACTIVITY                 ElementInstanceFilterType = "CALL_ACTIVITY"
	ElementInstanceFilterTypeENDEVENT                     ElementInstanceFilterType = "END_EVENT"
	ElementInstanceFilterTypeEVENTBASEDGATEWAY            ElementInstanceFilterType = "EVENT_BASED_GATEWAY"
	ElementInstanceFilterTypeEVENTSUBPROCESS              ElementInstanceFilterType = "EVENT_SUB_PROCESS"
	ElementInstanceFilterTypeEXCLUSIVEGATEWAY             ElementInstanceFilterType = "EXCLUSIVE_GATEWAY"
	ElementInstanceFilterTypeINCLUSIVEGATEWAY             ElementInstanceFilterType = "INCLUSIVE_GATEWAY"
	ElementInstanceFilterTypeINTERMEDIATECATCHEVENT       ElementInstanceFilterType = "INTERMEDIATE_CATCH_EVENT"
	ElementInstanceFilterTypeINTERMEDIATETHROWEVENT       ElementInstanceFilterType = "INTERMEDIATE_THROW_EVENT"
	ElementInstanceFilterTypeMANUALTASK                   ElementInstanceFilterType = "MANUAL_TASK"
	ElementInstanceFilterTypeMULTIINSTANCEBODY            ElementInstanceFilterType = "MULTI_INSTANCE_BODY"
	ElementInstanceFilterTypePARALLELGATEWAY              ElementInstanceFilterType = "PARALLEL_GATEWAY"
	ElementInstanceFilterTypePROCESS                      ElementInstanceFilterType = "PROCESS"
	ElementInstanceFilterTypeRECEIVETASK                  ElementInstanceFilterType = "RECEIVE_TASK"
	ElementInstanceFilterTypeSCRIPTTASK                   ElementInstanceFilterType = "SCRIPT_TASK"
	ElementInstanceFilterTypeSENDTASK                     ElementInstanceFilterType = "SEND_TASK"
	ElementInstanceFilterTypeSEQUENCEFLOW                 ElementInstanceFilterType = "SEQUENCE_FLOW"
	ElementInstanceFilterTypeSERVICETASK                  ElementInstanceFilterType = "SERVICE_TASK"
	ElementInstanceFilterTypeSTARTEVENT                   ElementInstanceFilterType = "START_EVENT"
	ElementInstanceFilterTypeSUBPROCESS                   ElementInstanceFilterType = "SUB_PROCESS"
	ElementInstanceFilterTypeTASK                         ElementInstanceFilterType = "TASK"
	ElementInstanceFilterTypeUNKNOWN                      ElementInstanceFilterType = "UNKNOWN"
	ElementInstanceFilterTypeUNSPECIFIED                  ElementInstanceFilterType = "UNSPECIFIED"
	ElementInstanceFilterTypeUSERTASK                     ElementInstanceFilterType = "USER_TASK"
)

// Defines values for ElementInstanceResultType.
const (
	ElementInstanceResultTypeADHOCSUBPROCESS              ElementInstanceResultType = "AD_HOC_SUB_PROCESS"
	ElementInstanceResultTypeADHOCSUBPROCESSINNERINSTANCE ElementInstanceResultType = "AD_HOC_SUB_PROCESS_INNER_INSTANCE"
	ElementInstanceResultTypeBOUNDARYEVENT                ElementInstanceResultType = "BOUNDARY_EVENT"
	ElementInstanceResultTypeBUSINESSRULETASK             ElementInstanceResultType = "BUSINESS_RULE_TASK"
	ElementInstanceResultTypeCALLACTIVITY                 ElementInstanceResultType = "CALL_ACTIVITY"
	ElementInstanceResultTypeENDEVENT                     ElementInstanceResultType = "END_EVENT"
	ElementInstanceResultTypeEVENTBASEDGATEWAY            ElementInstanceResultType = "EVENT_BASED_GATEWAY"
	ElementInstanceResultTypeEVENTSUBPROCESS              ElementInstanceResultType = "EVENT_SUB_PROCESS"
	ElementInstanceResultTypeEXCLUSIVEGATEWAY             ElementInstanceResultType = "EXCLUSIVE_GATEWAY"
	ElementInstanceResultTypeINCLUSIVEGATEWAY             ElementInstanceResultType = "INCLUSIVE_GATEWAY"
	ElementInstanceResultTypeINTERMEDIATECATCHEVENT       ElementInstanceResultType = "INTERMEDIATE_CATCH_EVENT"
	ElementInstanceResultTypeINTERMEDIATETHROWEVENT       ElementInstanceResultType = "INTERMEDIATE_THROW_EVENT"
	ElementInstanceResultTypeMANUALTASK                   ElementInstanceResultType = "MANUAL_TASK"
	ElementInstanceResultTypeMULTIINSTANCEBODY            ElementInstanceResultType = "MULTI_INSTANCE_BODY"
	ElementInstanceResultTypePARALLELGATEWAY              ElementInstanceResultType = "PARALLEL_GATEWAY"
	ElementInstanceResultTypePROCESS                      ElementInstanceResultType = "PROCESS"
	ElementInstanceResultTypeRECEIVETASK                  ElementInstanceResultType = "RECEIVE_TASK"
	ElementInstanceResultTypeSCRIPTTASK                   ElementInstanceResultType = "SCRIPT_TASK"
	ElementInstanceResultTypeSENDTASK                     ElementInstanceResultType = "SEND_TASK"
	ElementInstanceResultTypeSEQUENCEFLOW                 ElementInstanceResultType = "SEQUENCE_FLOW"
	ElementInstanceResultTypeSERVICETASK                  ElementInstanceResultType = "SERVICE_TASK"
	ElementInstanceResultTypeSTARTEVENT                   ElementInstanceResultType = "START_EVENT"
	ElementInstanceResultTypeSUBPROCESS                   ElementInstanceResultType = "SUB_PROCESS"
	ElementInstanceResultTypeTASK                         ElementInstanceResultType = "TASK"
	ElementInstanceResultTypeUNKNOWN                      ElementInstanceResultType = "UNKNOWN"
	ElementInstanceResultTypeUNSPECIFIED                  ElementInstanceResultType = "UNSPECIFIED"
	ElementInstanceResultTypeUSERTASK                     ElementInstanceResultType = "USER_TASK"
)

// Defines values for ElementInstanceSearchQuerySortRequestField.
const (
	ElementInstanceSearchQuerySortRequestFieldElementId            ElementInstanceSearchQuerySortRequestField = "elementId"
	ElementInstanceSearchQuerySortRequestFieldElementInstanceKey   ElementInstanceSearchQuerySortRequestField = "elementInstanceKey"
	ElementInstanceSearchQuerySortRequestFieldElementName          ElementInstanceSearchQuerySortRequestField = "elementName"
	ElementInstanceSearchQuerySortRequestFieldEndDate              ElementInstanceSearchQuerySortRequestField = "endDate"
	ElementInstanceSearchQuerySortRequestFieldIncidentKey          ElementInstanceSearchQuerySortRequestField = "incidentKey"
	ElementInstanceSearchQuerySortRequestFieldProcessDefinitionId  ElementInstanceSearchQuerySortRequestField = "processDefinitionId"
	ElementInstanceSearchQuerySortRequestFieldProcessDefinitionKey ElementInstanceSearchQuerySortRequestField = "processDefinitionKey"
	ElementInstanceSearchQuerySortRequestFieldProcessInstanceKey   ElementInstanceSearchQuerySortRequestField = "processInstanceKey"
	ElementInstanceSearchQuerySortRequestFieldStartDate            ElementInstanceSearchQuerySortRequestField = "startDate"
	ElementInstanceSearchQuerySortRequestFieldState                ElementInstanceSearchQuerySortRequestField = "state"
	ElementInstanceSearchQuerySortRequestFieldTenantId             ElementInstanceSearchQuerySortRequestField = "tenantId"
	ElementInstanceSearchQuerySortRequestFieldType                 ElementInstanceSearchQuerySortRequestField = "type"
)

// Defines values for ElementInstanceStateEnum.
const (
	ElementInstanceStateEnumACTIVE     ElementInstanceStateEnum = "ACTIVE"
	ElementInstanceStateEnumCOMPLETED  ElementInstanceStateEnum = "COMPLETED"
	ElementInstanceStateEnumTERMINATED ElementInstanceStateEnum = "TERMINATED"
)

// Defines values for GroupClientSearchQuerySortRequestField.
const (
	GroupClientSearchQuerySortRequestFieldClientId GroupClientSearchQuerySortRequestField = "clientId"
)

// Defines values for GroupSearchQuerySortRequestField.
const (
	GroupSearchQuerySortRequestFieldGroupId GroupSearchQuerySortRequestField = "groupId"
	GroupSearchQuerySortRequestFieldName    GroupSearchQuerySortRequestField = "name"
)

// Defines values for GroupUserSearchQuerySortRequestField.
const (
	GroupUserSearchQuerySortRequestFieldUsername GroupUserSearchQuerySortRequestField = "username"
)

// Defines values for IncidentFilterErrorType.
const (
	IncidentFilterErrorTypeADHOCSUBPROCESSNORETRIES   IncidentFilterErrorType = "AD_HOC_SUB_PROCESS_NO_RETRIES"
	IncidentFilterErrorTypeCALLEDDECISIONERROR        IncidentFilterErrorType = "CALLED_DECISION_ERROR"
	IncidentFilterErrorTypeCALLEDELEMENTERROR         IncidentFilterErrorType = "CALLED_ELEMENT_ERROR"
	IncidentFilterErrorTypeCONDITIONERROR             IncidentFilterErrorType = "CONDITION_ERROR"
	IncidentFilterErrorTypeDECISIONEVALUATIONERROR    IncidentFilterErrorType = "DECISION_EVALUATION_ERROR"
	IncidentFilterErrorTypeEXECUTIONLISTENERNORETRIES IncidentFilterErrorType = "EXECUTION_LISTENER_NO_RETRIES"
	IncidentFilterErrorTypeEXTRACTVALUEERROR          IncidentFilterErrorType = "EXTRACT_VALUE_ERROR"
	IncidentFilterErrorTypeFORMNOTFOUND               IncidentFilterErrorType = "FORM_NOT_FOUND"
	IncidentFilterErrorTypeIOMAPPINGERROR             IncidentFilterErrorType = "IO_MAPPING_ERROR"
	IncidentFilterErrorTypeJOBNORETRIES               IncidentFilterErrorType = "JOB_NO_RETRIES"
	IncidentFilterErrorTypeMESSAGESIZEEXCEEDED        IncidentFilterErrorType = "MESSAGE_SIZE_EXCEEDED"
	IncidentFilterErrorTypeRESOURCENOTFOUND           IncidentFilterErrorType = "RESOURCE_NOT_FOUND"
	IncidentFilterErrorTypeTASKLISTENERNORETRIES      IncidentFilterErrorType = "TASK_LISTENER_NO_RETRIES"
	IncidentFilterErrorTypeUNHANDLEDERROREVENT        IncidentFilterErrorType = "UNHANDLED_ERROR_EVENT"
	IncidentFilterErrorTypeUNKNOWN                    IncidentFilterErrorType = "UNKNOWN"
	IncidentFilterErrorTypeUNSPECIFIED                IncidentFilterErrorType = "UNSPECIFIED"
)

// Defines values for IncidentFilterState.
const (
	IncidentFilterStateACTIVE   IncidentFilterState = "ACTIVE"
	IncidentFilterStateMIGRATED IncidentFilterState = "MIGRATED"
	IncidentFilterStatePENDING  IncidentFilterState = "PENDING"
	IncidentFilterStateRESOLVED IncidentFilterState = "RESOLVED"
)

// Defines values for IncidentResultErrorType.
const (
	IncidentResultErrorTypeADHOCSUBPROCESSNORETRIES   IncidentResultErrorType = "AD_HOC_SUB_PROCESS_NO_RETRIES"
	IncidentResultErrorTypeCALLEDDECISIONERROR        IncidentResultErrorType = "CALLED_DECISION_ERROR"
	IncidentResultErrorTypeCALLEDELEMENTERROR         IncidentResultErrorType = "CALLED_ELEMENT_ERROR"
	IncidentResultErrorTypeCONDITIONERROR             IncidentResultErrorType = "CONDITION_ERROR"
	IncidentResultErrorTypeDECISIONEVALUATIONERROR    IncidentResultErrorType = "DECISION_EVALUATION_ERROR"
	IncidentResultErrorTypeEXECUTIONLISTENERNORETRIES IncidentResultErrorType = "EXECUTION_LISTENER_NO_RETRIES"
	IncidentResultErrorTypeEXTRACTVALUEERROR          IncidentResultErrorType = "EXTRACT_VALUE_ERROR"
	IncidentResultErrorTypeFORMNOTFOUND               IncidentResultErrorType = "FORM_NOT_FOUND"
	IncidentResultErrorTypeIOMAPPINGERROR             IncidentResultErrorType = "IO_MAPPING_ERROR"
	IncidentResultErrorTypeJOBNORETRIES               IncidentResultErrorType = "JOB_NO_RETRIES"
	IncidentResultErrorTypeMESSAGESIZEEXCEEDED        IncidentResultErrorType = "MESSAGE_SIZE_EXCEEDED"
	IncidentResultErrorTypeRESOURCENOTFOUND           IncidentResultErrorType = "RESOURCE_NOT_FOUND"
	IncidentResultErrorTypeTASKLISTENERNORETRIES      IncidentResultErrorType = "TASK_LISTENER_NO_RETRIES"
	IncidentResultErrorTypeUNHANDLEDERROREVENT        IncidentResultErrorType = "UNHANDLED_ERROR_EVENT"
	IncidentResultErrorTypeUNKNOWN                    IncidentResultErrorType = "UNKNOWN"
	IncidentResultErrorTypeUNSPECIFIED                IncidentResultErrorType = "UNSPECIFIED"
)

// Defines values for IncidentResultState.
const (
	IncidentResultStateACTIVE   IncidentResultState = "ACTIVE"
	IncidentResultStateMIGRATED IncidentResultState = "MIGRATED"
	IncidentResultStatePENDING  IncidentResultState = "PENDING"
	IncidentResultStateRESOLVED IncidentResultState = "RESOLVED"
)

// Defines values for IncidentSearchQuerySortRequestField.
const (
	IncidentSearchQuerySortRequestFieldCreationTime         IncidentSearchQuerySortRequestField = "creationTime"
	IncidentSearchQuerySortRequestFieldElementId            IncidentSearchQuerySortRequestField = "elementId"
	IncidentSearchQuerySortRequestFieldElementInstanceKey   IncidentSearchQuerySortRequestField = "elementInstanceKey"
	IncidentSearchQuerySortRequestFieldErrorMessage         IncidentSearchQuerySortRequestField = "errorMessage"
	IncidentSearchQuerySortRequestFieldErrorType            IncidentSearchQuerySortRequestField = "errorType"
	IncidentSearchQuerySortRequestFieldIncidentKey          IncidentSearchQuerySortRequestField = "incidentKey"
	IncidentSearchQuerySortRequestFieldJobKey               IncidentSearchQuerySortRequestField = "jobKey"
	IncidentSearchQuerySortRequestFieldProcessDefinitionId  IncidentSearchQuerySortRequestField = "processDefinitionId"
	IncidentSearchQuerySortRequestFieldProcessDefinitionKey IncidentSearchQuerySortRequestField = "processDefinitionKey"
	IncidentSearchQuerySortRequestFieldProcessInstanceKey   IncidentSearchQuerySortRequestField = "processInstanceKey"
	IncidentSearchQuerySortRequestFieldState                IncidentSearchQuerySortRequestField = "state"
	IncidentSearchQuerySortRequestFieldTenantId             IncidentSearchQuerySortRequestField = "tenantId"
)

// Defines values for JobKindEnum.
const (
	ADHOCSUBPROCESS   JobKindEnum = "AD_HOC_SUB_PROCESS"
	BPMNELEMENT       JobKindEnum = "BPMN_ELEMENT"
	EXECUTIONLISTENER JobKindEnum = "EXECUTION_LISTENER"
	TASKLISTENER      JobKindEnum = "TASK_LISTENER"
)

// Defines values for JobListenerEventTypeEnum.
const (
	JobListenerEventTypeEnumASSIGNING   JobListenerEventTypeEnum = "ASSIGNING"
	JobListenerEventTypeEnumCANCELING   JobListenerEventTypeEnum = "CANCELING"
	JobListenerEventTypeEnumCOMPLETING  JobListenerEventTypeEnum = "COMPLETING"
	JobListenerEventTypeEnumCREATING    JobListenerEventTypeEnum = "CREATING"
	JobListenerEventTypeEnumEND         JobListenerEventTypeEnum = "END"
	JobListenerEventTypeEnumSTART       JobListenerEventTypeEnum = "START"
	JobListenerEventTypeEnumUNSPECIFIED JobListenerEventTypeEnum = "UNSPECIFIED"
	JobListenerEventTypeEnumUPDATING    JobListenerEventTypeEnum = "UPDATING"
)

// Defines values for JobResultType.
const (
	AdHocSubProcess JobResultType = "adHocSubProcess"
	UserTask        JobResultType = "userTask"
)

// Defines values for JobSearchQuerySortRequestField.
const (
	JobSearchQuerySortRequestFieldDeadline                 JobSearchQuerySortRequestField = "deadline"
	JobSearchQuerySortRequestFieldDeniedReason             JobSearchQuerySortRequestField = "deniedReason"
	JobSearchQuerySortRequestFieldElementId                JobSearchQuerySortRequestField = "elementId"
	JobSearchQuerySortRequestFieldElementInstanceKey       JobSearchQuerySortRequestField = "elementInstanceKey"
	JobSearchQuerySortRequestFieldEndTime                  JobSearchQuerySortRequestField = "endTime"
	JobSearchQuerySortRequestFieldErrorCode                JobSearchQuerySortRequestField = "errorCode"
	JobSearchQuerySortRequestFieldErrorMessage             JobSearchQuerySortRequestField = "errorMessage"
	JobSearchQuerySortRequestFieldHasFailedWithRetriesLeft JobSearchQuerySortRequestField = "hasFailedWithRetriesLeft"
	JobSearchQuerySortRequestFieldIsDenied                 JobSearchQuerySortRequestField = "isDenied"
	JobSearchQuerySortRequestFieldJobKey                   JobSearchQuerySortRequestField = "jobKey"
	JobSearchQuerySortRequestFieldKind                     JobSearchQuerySortRequestField = "kind"
	JobSearchQuerySortRequestFieldListenerEventType        JobSearchQuerySortRequestField = "listenerEventType"
	JobSearchQuerySortRequestFieldProcessDefinitionId      JobSearchQuerySortRequestField = "processDefinitionId"
	JobSearchQuerySortRequestFieldProcessDefinitionKey     JobSearchQuerySortRequestField = "processDefinitionKey"
	JobSearchQuerySortRequestFieldProcessInstanceKey       JobSearchQuerySortRequestField = "processInstanceKey"
	JobSearchQuerySortRequestFieldRetries                  JobSearchQuerySortRequestField = "retries"
	JobSearchQuerySortRequestFieldState                    JobSearchQuerySortRequestField = "state"
	JobSearchQuerySortRequestFieldTenantId                 JobSearchQuerySortRequestField = "tenantId"
	JobSearchQuerySortRequestFieldType                     JobSearchQuerySortRequestField = "type"
	JobSearchQuerySortRequestFieldWorker                   JobSearchQuerySortRequestField = "worker"
)

// Defines values for JobStateEnum.
const (
	JobStateEnumCANCELED       JobStateEnum = "CANCELED"
	JobStateEnumCOMPLETED      JobStateEnum = "COMPLETED"
	JobStateEnumCREATED        JobStateEnum = "CREATED"
	JobStateEnumERRORTHROWN    JobStateEnum = "ERROR_THROWN"
	JobStateEnumFAILED         JobStateEnum = "FAILED"
	JobStateEnumMIGRATED       JobStateEnum = "MIGRATED"
	JobStateEnumRETRIESUPDATED JobStateEnum = "RETRIES_UPDATED"
	JobStateEnumTIMEDOUT       JobStateEnum = "TIMED_OUT"
)

// Defines values for MappingRuleSearchQuerySortRequestField.
const (
	MappingRuleSearchQuerySortRequestFieldClaimName     MappingRuleSearchQuerySortRequestField = "claimName"
	MappingRuleSearchQuerySortRequestFieldClaimValue    MappingRuleSearchQuerySortRequestField = "claimValue"
	MappingRuleSearchQuerySortRequestFieldMappingRuleId MappingRuleSearchQuerySortRequestField = "mappingRuleId"
	MappingRuleSearchQuerySortRequestFieldName          MappingRuleSearchQuerySortRequestField = "name"
)

// Defines values for MessageSubscriptionSearchQuerySortRequestField.
const (
	MessageSubscriptionSearchQuerySortRequestFieldCorrelationKey           MessageSubscriptionSearchQuerySortRequestField = "correlationKey"
	MessageSubscriptionSearchQuerySortRequestFieldElementId                MessageSubscriptionSearchQuerySortRequestField = "elementId"
	MessageSubscriptionSearchQuerySortRequestFieldElementInstanceKey       MessageSubscriptionSearchQuerySortRequestField = "elementInstanceKey"
	MessageSubscriptionSearchQuerySortRequestFieldLastUpdatedDate          MessageSubscriptionSearchQuerySortRequestField = "lastUpdatedDate"
	MessageSubscriptionSearchQuerySortRequestFieldMessageName              MessageSubscriptionSearchQuerySortRequestField = "messageName"
	MessageSubscriptionSearchQuerySortRequestFieldMessageSubscriptionKey   MessageSubscriptionSearchQuerySortRequestField = "messageSubscriptionKey"
	MessageSubscriptionSearchQuerySortRequestFieldMessageSubscriptionState MessageSubscriptionSearchQuerySortRequestField = "messageSubscriptionState"
	MessageSubscriptionSearchQuerySortRequestFieldProcessDefinitionId      MessageSubscriptionSearchQuerySortRequestField = "processDefinitionId"
	MessageSubscriptionSearchQuerySortRequestFieldProcessInstanceKey       MessageSubscriptionSearchQuerySortRequestField = "processInstanceKey"
	MessageSubscriptionSearchQuerySortRequestFieldTenantId                 MessageSubscriptionSearchQuerySortRequestField = "tenantId"
)

// Defines values for MessageSubscriptionStateEnum.
const (
	MessageSubscriptionStateEnumCORRELATED MessageSubscriptionStateEnum = "CORRELATED"
	MessageSubscriptionStateEnumCREATED    MessageSubscriptionStateEnum = "CREATED"
	MessageSubscriptionStateEnumDELETED    MessageSubscriptionStateEnum = "DELETED"
	MessageSubscriptionStateEnumMIGRATED   MessageSubscriptionStateEnum = "MIGRATED"
)

// Defines values for OwnerTypeEnum.
const (
	OwnerTypeEnumCLIENT      OwnerTypeEnum = "CLIENT"
	OwnerTypeEnumGROUP       OwnerTypeEnum = "GROUP"
	OwnerTypeEnumMAPPINGRULE OwnerTypeEnum = "MAPPING_RULE"
	OwnerTypeEnumROLE        OwnerTypeEnum = "ROLE"
	OwnerTypeEnumUNSPECIFIED OwnerTypeEnum = "UNSPECIFIED"
	OwnerTypeEnumUSER        OwnerTypeEnum = "USER"
)

// Defines values for PartitionHealth.
const (
	Dead      PartitionHealth = "dead"
	Healthy   PartitionHealth = "healthy"
	Unhealthy PartitionHealth = "unhealthy"
)

// Defines values for PartitionRole.
const (
	Follower PartitionRole = "follower"
	Inactive PartitionRole = "inactive"
	Leader   PartitionRole = "leader"
)

// Defines values for PermissionTypeEnum.
const (
	PermissionTypeEnumACCESS                                       PermissionTypeEnum = "ACCESS"
	PermissionTypeEnumCANCELPROCESSINSTANCE                        PermissionTypeEnum = "CANCEL_PROCESS_INSTANCE"
	PermissionTypeEnumCREATE                                       PermissionTypeEnum = "CREATE"
	PermissionTypeEnumCREATEBATCHOPERATIONCANCELPROCESSINSTANCE    PermissionTypeEnum = "CREATE_BATCH_OPERATION_CANCEL_PROCESS_INSTANCE"
	PermissionTypeEnumCREATEBATCHOPERATIONDELETEDECISIONDEFINITION PermissionTypeEnum = "CREATE_BATCH_OPERATION_DELETE_DECISION_DEFINITION"
	PermissionTypeEnumCREATEBATCHOPERATIONDELETEDECISIONINSTANCE   PermissionTypeEnum = "CREATE_BATCH_OPERATION_DELETE_DECISION_INSTANCE"
	PermissionTypeEnumCREATEBATCHOPERATIONDELETEPROCESSDEFINITION  PermissionTypeEnum = "CREATE_BATCH_OPERATION_DELETE_PROCESS_DEFINITION"
	PermissionTypeEnumCREATEBATCHOPERATIONDELETEPROCESSINSTANCE    PermissionTypeEnum = "CREATE_BATCH_OPERATION_DELETE_PROCESS_INSTANCE"
	PermissionTypeEnumCREATEBATCHOPERATIONMIGRATEPROCESSINSTANCE   PermissionTypeEnum = "CREATE_BATCH_OPERATION_MIGRATE_PROCESS_INSTANCE"
	PermissionTypeEnumCREATEBATCHOPERATIONMODIFYPROCESSINSTANCE    PermissionTypeEnum = "CREATE_BATCH_OPERATION_MODIFY_PROCESS_INSTANCE"
	PermissionTypeEnumCREATEBATCHOPERATIONRESOLVEINCIDENT          PermissionTypeEnum = "CREATE_BATCH_OPERATION_RESOLVE_INCIDENT"
	PermissionTypeEnumCREATEDECISIONINSTANCE                       PermissionTypeEnum = "CREATE_DECISION_INSTANCE"
	PermissionTypeEnumCREATEPROCESSINSTANCE                        PermissionTypeEnum = "CREATE_PROCESS_INSTANCE"
	PermissionTypeEnumDELETE                                       PermissionTypeEnum = "DELETE"
	PermissionTypeEnumDELETEDECISIONINSTANCE                       PermissionTypeEnum = "DELETE_DECISION_INSTANCE"
	PermissionTypeEnumDELETEDRD                                    PermissionTypeEnum = "DELETE_DRD"
	PermissionTypeEnumDELETEFORM                                   PermissionTypeEnum = "DELETE_FORM"
	PermissionTypeEnumDELETEPROCESS                                PermissionTypeEnum = "DELETE_PROCESS"
	PermissionTypeEnumDELETEPROCESSINSTANCE                        PermissionTypeEnum = "DELETE_PROCESS_INSTANCE"
	PermissionTypeEnumDELETERESOURCE                               PermissionTypeEnum = "DELETE_RESOURCE"
	PermissionTypeEnumMODIFYPROCESSINSTANCE                        PermissionTypeEnum = "MODIFY_PROCESS_INSTANCE"
	PermissionTypeEnumREAD                                         PermissionTypeEnum = "READ"
	PermissionTypeEnumREADDECISIONDEFINITION                       PermissionTypeEnum = "READ_DECISION_DEFINITION"
	PermissionTypeEnumREADDECISIONINSTANCE                         PermissionTypeEnum = "READ_DECISION_INSTANCE"
	PermissionTypeEnumREADPROCESSDEFINITION                        PermissionTypeEnum = "READ_PROCESS_DEFINITION"
	PermissionTypeEnumREADPROCESSINSTANCE                          PermissionTypeEnum = "READ_PROCESS_INSTANCE"
	PermissionTypeEnumREADUSAGEMETRIC                              PermissionTypeEnum = "READ_USAGE_METRIC"
	PermissionTypeEnumREADUSERTASK                                 PermissionTypeEnum = "READ_USER_TASK"
	PermissionTypeEnumUPDATE                                       PermissionTypeEnum = "UPDATE"
	PermissionTypeEnumUPDATEPROCESSINSTANCE                        PermissionTypeEnum = "UPDATE_PROCESS_INSTANCE"
	PermissionTypeEnumUPDATEUSERTASK                               PermissionTypeEnum = "UPDATE_USER_TASK"
)

// Defines values for ProcessDefinitionSearchQuerySortRequestField.
const (
	ProcessDefinitionSearchQuerySortRequestFieldName                 ProcessDefinitionSearchQuerySortRequestField = "name"
	ProcessDefinitionSearchQuerySortRequestFieldProcessDefinitionId  ProcessDefinitionSearchQuerySortRequestField = "processDefinitionId"
	ProcessDefinitionSearchQuerySortRequestFieldProcessDefinitionKey ProcessDefinitionSearchQuerySortRequestField = "processDefinitionKey"
	ProcessDefinitionSearchQuerySortRequestFieldResourceName         ProcessDefinitionSearchQuerySortRequestField = "resourceName"
	ProcessDefinitionSearchQuerySortRequestFieldTenantId             ProcessDefinitionSearchQuerySortRequestField = "tenantId"
	ProcessDefinitionSearchQuerySortRequestFieldVersion              ProcessDefinitionSearchQuerySortRequestField = "version"
	ProcessDefinitionSearchQuerySortRequestFieldVersionTag           ProcessDefinitionSearchQuerySortRequestField = "versionTag"
)

// Defines values for ProcessInstanceCreationRuntimeInstructionType.
const (
	TERMINATEPROCESSINSTANCE ProcessInstanceCreationRuntimeInstructionType = "TERMINATE_PROCESS_INSTANCE"
)

// Defines values for ProcessInstanceSearchQuerySortRequestField.
const (
	ProcessInstanceSearchQuerySortRequestFieldEndDate                     ProcessInstanceSearchQuerySortRequestField = "endDate"
	ProcessInstanceSearchQuerySortRequestFieldHasIncident                 ProcessInstanceSearchQuerySortRequestField = "hasIncident"
	ProcessInstanceSearchQuerySortRequestFieldParentElementInstanceKey    ProcessInstanceSearchQuerySortRequestField = "parentElementInstanceKey"
	ProcessInstanceSearchQuerySortRequestFieldParentProcessInstanceKey    ProcessInstanceSearchQuerySortRequestField = "parentProcessInstanceKey"
	ProcessInstanceSearchQuerySortRequestFieldProcessDefinitionId         ProcessInstanceSearchQuerySortRequestField = "processDefinitionId"
	ProcessInstanceSearchQuerySortRequestFieldProcessDefinitionKey        ProcessInstanceSearchQuerySortRequestField = "processDefinitionKey"
	ProcessInstanceSearchQuerySortRequestFieldProcessDefinitionName       ProcessInstanceSearchQuerySortRequestField = "processDefinitionName"
	ProcessInstanceSearchQuerySortRequestFieldProcessDefinitionVersion    ProcessInstanceSearchQuerySortRequestField = "processDefinitionVersion"
	ProcessInstanceSearchQuerySortRequestFieldProcessDefinitionVersionTag ProcessInstanceSearchQuerySortRequestField = "processDefinitionVersionTag"
	ProcessInstanceSearchQuerySortRequestFieldProcessInstanceKey          ProcessInstanceSearchQuerySortRequestField = "processInstanceKey"
	ProcessInstanceSearchQuerySortRequestFieldStartDate                   ProcessInstanceSearchQuerySortRequestField = "startDate"
	ProcessInstanceSearchQuerySortRequestFieldState                       ProcessInstanceSearchQuerySortRequestField = "state"
	ProcessInstanceSearchQuerySortRequestFieldTenantId                    ProcessInstanceSearchQuerySortRequestField = "tenantId"
)

// Defines values for ProcessInstanceStateEnum.
const (
	ACTIVE     ProcessInstanceStateEnum = "ACTIVE"
	COMPLETED  ProcessInstanceStateEnum = "COMPLETED"
	TERMINATED ProcessInstanceStateEnum = "TERMINATED"
)

// Defines values for ResourceTypeEnum.
const (
	AUTHORIZATION                  ResourceTypeEnum = "AUTHORIZATION"
	BATCH                          ResourceTypeEnum = "BATCH"
	COMPONENT                      ResourceTypeEnum = "COMPONENT"
	DECISIONDEFINITION             ResourceTypeEnum = "DECISION_DEFINITION"
	DECISIONREQUIREMENTSDEFINITION ResourceTypeEnum = "DECISION_REQUIREMENTS_DEFINITION"
	DOCUMENT                       ResourceTypeEnum = "DOCUMENT"
	GROUP                          ResourceTypeEnum = "GROUP"
	MAPPINGRULE                    ResourceTypeEnum = "MAPPING_RULE"
	MESSAGE                        ResourceTypeEnum = "MESSAGE"
	PROCESSDEFINITION              ResourceTypeEnum = "PROCESS_DEFINITION"
	RESOURCE                       ResourceTypeEnum = "RESOURCE"
	ROLE                           ResourceTypeEnum = "ROLE"
	SYSTEM                         ResourceTypeEnum = "SYSTEM"
	TENANT                         ResourceTypeEnum = "TENANT"
	USER                           ResourceTypeEnum = "USER"
)

// Defines values for RoleClientSearchQuerySortRequestField.
const (
	RoleClientSearchQuerySortRequestFieldClientId RoleClientSearchQuerySortRequestField = "clientId"
)

// Defines values for RoleGroupSearchQuerySortRequestField.
const (
	RoleGroupSearchQuerySortRequestFieldGroupId RoleGroupSearchQuerySortRequestField = "groupId"
)

// Defines values for RoleSearchQuerySortRequestField.
const (
	RoleSearchQuerySortRequestFieldName   RoleSearchQuerySortRequestField = "name"
	RoleSearchQuerySortRequestFieldRoleId RoleSearchQuerySortRequestField = "roleId"
)

// Defines values for RoleUserSearchQuerySortRequestField.
const (
	RoleUserSearchQuerySortRequestFieldUsername RoleUserSearchQuerySortRequestField = "username"
)

// Defines values for SortOrderEnum.
const (
	ASC  SortOrderEnum = "ASC"
	DESC SortOrderEnum = "DESC"
)

// Defines values for TenantClientSearchQuerySortRequestField.
const (
	ClientId TenantClientSearchQuerySortRequestField = "clientId"
)

// Defines values for TenantGroupSearchQuerySortRequestField.
const (
	TenantGroupSearchQuerySortRequestFieldGroupId TenantGroupSearchQuerySortRequestField = "groupId"
)

// Defines values for TenantSearchQuerySortRequestField.
const (
	TenantSearchQuerySortRequestFieldKey      TenantSearchQuerySortRequestField = "key"
	TenantSearchQuerySortRequestFieldName     TenantSearchQuerySortRequestField = "name"
	TenantSearchQuerySortRequestFieldTenantId TenantSearchQuerySortRequestField = "tenantId"
)

// Defines values for TenantUserSearchQuerySortRequestField.
const (
	TenantUserSearchQuerySortRequestFieldUsername TenantUserSearchQuerySortRequestField = "username"
)

// Defines values for UserSearchQuerySortRequestField.
const (
	UserSearchQuerySortRequestFieldEmail    UserSearchQuerySortRequestField = "email"
	UserSearchQuerySortRequestFieldName     UserSearchQuerySortRequestField = "name"
	UserSearchQuerySortRequestFieldUsername UserSearchQuerySortRequestField = "username"
)

// Defines values for UserTaskSearchQuerySortRequestField.
const (
	UserTaskSearchQuerySortRequestFieldCompletionDate UserTaskSearchQuerySortRequestField = "completionDate"
	UserTaskSearchQuerySortRequestFieldCreationDate   UserTaskSearchQuerySortRequestField = "creationDate"
	UserTaskSearchQuerySortRequestFieldDueDate        UserTaskSearchQuerySortRequestField = "dueDate"
	UserTaskSearchQuerySortRequestFieldFollowUpDate   UserTaskSearchQuerySortRequestField = "followUpDate"
	UserTaskSearchQuerySortRequestFieldName           UserTaskSearchQuerySortRequestField = "name"
	UserTaskSearchQuerySortRequestFieldPriority       UserTaskSearchQuerySortRequestField = "priority"
)

// Defines values for UserTaskStateEnum.
const (
	UserTaskStateEnumASSIGNING  UserTaskStateEnum = "ASSIGNING"
	UserTaskStateEnumCANCELED   UserTaskStateEnum = "CANCELED"
	UserTaskStateEnumCANCELING  UserTaskStateEnum = "CANCELING"
	UserTaskStateEnumCOMPLETED  UserTaskStateEnum = "COMPLETED"
	UserTaskStateEnumCOMPLETING UserTaskStateEnum = "COMPLETING"
	UserTaskStateEnumCREATED    UserTaskStateEnum = "CREATED"
	UserTaskStateEnumCREATING   UserTaskStateEnum = "CREATING"
	UserTaskStateEnumFAILED     UserTaskStateEnum = "FAILED"
	UserTaskStateEnumUPDATING   UserTaskStateEnum = "UPDATING"
)

// Defines values for UserTaskVariableSearchQuerySortRequestField.
const (
	UserTaskVariableSearchQuerySortRequestFieldName               UserTaskVariableSearchQuerySortRequestField = "name"
	UserTaskVariableSearchQuerySortRequestFieldProcessInstanceKey UserTaskVariableSearchQuerySortRequestField = "processInstanceKey"
	UserTaskVariableSearchQuerySortRequestFieldScopeKey           UserTaskVariableSearchQuerySortRequestField = "scopeKey"
	UserTaskVariableSearchQuerySortRequestFieldTenantId           UserTaskVariableSearchQuerySortRequestField = "tenantId"
	UserTaskVariableSearchQuerySortRequestFieldValue              UserTaskVariableSearchQuerySortRequestField = "value"
	UserTaskVariableSearchQuerySortRequestFieldVariableKey        UserTaskVariableSearchQuerySortRequestField = "variableKey"
)

// Defines values for VariableSearchQuerySortRequestField.
const (
	VariableSearchQuerySortRequestFieldName               VariableSearchQuerySortRequestField = "name"
	VariableSearchQuerySortRequestFieldProcessInstanceKey VariableSearchQuerySortRequestField = "processInstanceKey"
	VariableSearchQuerySortRequestFieldScopeKey           VariableSearchQuerySortRequestField = "scopeKey"
	VariableSearchQuerySortRequestFieldTenantId           VariableSearchQuerySortRequestField = "tenantId"
	VariableSearchQuerySortRequestFieldValue              VariableSearchQuerySortRequestField = "value"
	VariableSearchQuerySortRequestFieldVariableKey        VariableSearchQuerySortRequestField = "variableKey"
)

// ActivatedJobResult defines model for ActivatedJobResult.
type ActivatedJobResult struct {
	// CustomHeaders A set of custom headers defined during modelling; returned as a serialized JSON document.
	CustomHeaders map[string]interface{} `json:"customHeaders"`

	// Deadline When the job can be activated again, sent as a UNIX epoch timestamp.
	Deadline int64 `json:"deadline"`

	// ElementId The associated task element ID.
	ElementId ElementId `json:"elementId"`

	// ElementInstanceKey The unique key identifying the associated task, unique within the scope of the process instance.
	ElementInstanceKey ElementInstanceKey `json:"elementInstanceKey"`

	// JobKey The key, a unique identifier for the job.
	JobKey JobKey `json:"jobKey"`

	// Kind The job kind.
	Kind JobKindEnum `json:"kind"`

	// ListenerEventType The listener event type of the job.
	ListenerEventType JobListenerEventTypeEnum `json:"listenerEventType"`

	// ProcessDefinitionId The bpmn process ID of the job's process definition.
	ProcessDefinitionId ProcessDefinitionId `json:"processDefinitionId"`

	// ProcessDefinitionKey The key of the job's process definition.
	ProcessDefinitionKey ProcessDefinitionKey `json:"processDefinitionKey"`

	// ProcessDefinitionVersion The version of the job's process definition.
	ProcessDefinitionVersion int32 `json:"processDefinitionVersion"`

	// ProcessInstanceKey The job's process instance key.
	ProcessInstanceKey ProcessInstanceKey `json:"processInstanceKey"`

	// Retries The amount of retries left to this job (should always be positive).
	Retries int32 `json:"retries"`

	// Tags List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
	Tags *TagSet `json:"tags,omitempty"`

	// TenantId The ID of the tenant that owns the job.
	TenantId TenantId `json:"tenantId"`

	// Type The type of the job (should match what was requested).
	Type string `json:"type"`

	// UserTask Contains properties of a user task.
	UserTask *UserTaskProperties `json:"userTask,omitempty"`

	// Variables All variables visible to the task scope, computed at activation time.
	Variables map[string]interface{} `json:"variables"`

	// Worker The name of the worker which activated this job.
	Worker string `json:"worker"`
}

// AdHocSubProcessActivateActivitiesInstruction defines model for AdHocSubProcessActivateActivitiesInstruction.
type AdHocSubProcessActivateActivitiesInstruction struct {
	// CancelRemainingInstances Whether to cancel remaining instances of the ad-hoc sub-process.
	CancelRemainingInstances *bool `json:"cancelRemainingInstances,omitempty"`

	// Elements Activities to activate.
	Elements []AdHocSubProcessActivateActivityReference `json:"elements"`
}

// AdHocSubProcessActivateActivityReference defines model for AdHocSubProcessActivateActivityReference.
type AdHocSubProcessActivateActivityReference struct {
	// ElementId The ID of the element that should be activated.
	ElementId ElementId `json:"elementId"`

	// Variables Variables to be set when activating the element.
	Variables *map[string]interface{} `json:"variables,omitempty"`
}

// AdvancedBatchOperationItemStateFilter Advanced BatchOperationItemStateEnum filter.
type AdvancedBatchOperationItemStateFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *BatchOperationItemStateEnum `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]BatchOperationItemStateEnum `json:"$in,omitempty"`

	// Like Checks if the property matches the provided like value.
	//
	// Supported wildcard characters are:
	//
	// * `*`: matches zero, one, or multiple characters.
	// * `?`: matches one, single character.
	//
	// Wildcard characters can be escaped with backslash, for instance: `\*`.
	Like *LikeFilter `json:"$like,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *BatchOperationItemStateEnum `json:"$neq,omitempty"`
}

// AdvancedBatchOperationStateFilter Advanced BatchOperationStateEnum filter.
type AdvancedBatchOperationStateFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *BatchOperationStateEnum `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]BatchOperationStateEnum `json:"$in,omitempty"`

	// Like Checks if the property matches the provided like value.
	//
	// Supported wildcard characters are:
	//
	// * `*`: matches zero, one, or multiple characters.
	// * `?`: matches one, single character.
	//
	// Wildcard characters can be escaped with backslash, for instance: `\*`.
	Like *LikeFilter `json:"$like,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *BatchOperationStateEnum `json:"$neq,omitempty"`
}

// AdvancedBatchOperationTypeFilter Advanced BatchOperationTypeEnum filter.
type AdvancedBatchOperationTypeFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *BatchOperationTypeEnum `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]BatchOperationTypeEnum `json:"$in,omitempty"`

	// Like Checks if the property matches the provided like value.
	//
	// Supported wildcard characters are:
	//
	// * `*`: matches zero, one, or multiple characters.
	// * `?`: matches one, single character.
	//
	// Wildcard characters can be escaped with backslash, for instance: `\*`.
	Like *LikeFilter `json:"$like,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *BatchOperationTypeEnum `json:"$neq,omitempty"`
}

// AdvancedDateTimeFilter Advanced date-time filter.
type AdvancedDateTimeFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *time.Time `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// Gt Greater than comparison with the provided value.
	Gt *time.Time `json:"$gt,omitempty"`

	// Gte Greater than or equal comparison with the provided value.
	Gte *time.Time `json:"$gte,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]time.Time `json:"$in,omitempty"`

	// Lt Lower than comparison with the provided value.
	Lt *time.Time `json:"$lt,omitempty"`

	// Lte Lower than or equal comparison with the provided value.
	Lte *time.Time `json:"$lte,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *time.Time `json:"$neq,omitempty"`
}

// AdvancedDecisionDefinitionKeyFilter Advanced DecisionDefinitionKey filter.
type AdvancedDecisionDefinitionKeyFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *DecisionDefinitionKey `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]DecisionDefinitionKey `json:"$in,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *DecisionDefinitionKey `json:"$neq,omitempty"`

	// NotIn Checks if the property matches none of the provided values.
	NotIn *[]DecisionDefinitionKey `json:"$notIn,omitempty"`
}

// AdvancedElementInstanceKeyFilter Advanced ElementInstanceKey filter.
type AdvancedElementInstanceKeyFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *ElementInstanceKey `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]ElementInstanceKey `json:"$in,omitempty"`

	// Neq Checks for equality with the provided value.
	Neq *ElementInstanceKey `json:"$neq,omitempty"`

	// NotIn Checks if the property matches none of the provided values.
	NotIn *[]ElementInstanceKey `json:"$notIn,omitempty"`
}

// AdvancedElementInstanceStateFilter Advanced ElementInstanceStateEnum filter.
type AdvancedElementInstanceStateFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *ElementInstanceStateEnum `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]ElementInstanceStateEnum `json:"$in,omitempty"`

	// Like Checks if the property matches the provided like value.
	//
	// Supported wildcard characters are:
	//
	// * `*`: matches zero, one, or multiple characters.
	// * `?`: matches one, single character.
	//
	// Wildcard characters can be escaped with backslash, for instance: `\*`.
	Like *LikeFilter `json:"$like,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *ElementInstanceStateEnum `json:"$neq,omitempty"`
}

// AdvancedIntegerFilter Advanced integer (int32) filter.
type AdvancedIntegerFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *int32 `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// Gt Greater than comparison with the provided value.
	Gt *int32 `json:"$gt,omitempty"`

	// Gte Greater than or equal comparison with the provided value.
	Gte *int32 `json:"$gte,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]int32 `json:"$in,omitempty"`

	// Lt Lower than comparison with the provided value.
	Lt *int32 `json:"$lt,omitempty"`

	// Lte Lower than or equal comparison with the provided value.
	Lte *int32 `json:"$lte,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *int32 `json:"$neq,omitempty"`
}

// AdvancedJobKeyFilter Advanced JobKey filter.
type AdvancedJobKeyFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *JobKey `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]JobKey `json:"$in,omitempty"`

	// Neq Checks for equality with the provided value.
	Neq *JobKey `json:"$neq,omitempty"`

	// NotIn Checks if the property matches none of the provided values.
	NotIn *[]JobKey `json:"$notIn,omitempty"`
}

// AdvancedJobKindFilter Advanced JobKindEnum filter.
type AdvancedJobKindFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *JobKindEnum `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]JobKindEnum `json:"$in,omitempty"`

	// Like Checks if the property matches the provided like value.
	//
	// Supported wildcard characters are:
	//
	// * `*`: matches zero, one, or multiple characters.
	// * `?`: matches one, single character.
	//
	// Wildcard characters can be escaped with backslash, for instance: `\*`.
	Like *LikeFilter `json:"$like,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *JobKindEnum `json:"$neq,omitempty"`
}

// AdvancedJobListenerEventTypeFilter Advanced JobListenerEventTypeEnum filter.
type AdvancedJobListenerEventTypeFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *JobListenerEventTypeEnum `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]JobListenerEventTypeEnum `json:"$in,omitempty"`

	// Like Checks if the property matches the provided like value.
	//
	// Supported wildcard characters are:
	//
	// * `*`: matches zero, one, or multiple characters.
	// * `?`: matches one, single character.
	//
	// Wildcard characters can be escaped with backslash, for instance: `\*`.
	Like *LikeFilter `json:"$like,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *JobListenerEventTypeEnum `json:"$neq,omitempty"`
}

// AdvancedJobStateFilter Advanced JobStateEnum filter.
type AdvancedJobStateFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *JobStateEnum `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]JobStateEnum `json:"$in,omitempty"`

	// Like Checks if the property matches the provided like value.
	//
	// Supported wildcard characters are:
	//
	// * `*`: matches zero, one, or multiple characters.
	// * `?`: matches one, single character.
	//
	// Wildcard characters can be escaped with backslash, for instance: `\*`.
	Like *LikeFilter `json:"$like,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *JobStateEnum `json:"$neq,omitempty"`
}

// AdvancedMessageSubscriptionKeyFilter Advanced MessageSubscriptionKey filter.
type AdvancedMessageSubscriptionKeyFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *MessageSubscriptionKey `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]MessageSubscriptionKey `json:"$in,omitempty"`

	// Neq Checks for equality with the provided value.
	Neq *MessageSubscriptionKey `json:"$neq,omitempty"`

	// NotIn Checks if the property matches none of the provided values.
	NotIn *[]MessageSubscriptionKey `json:"$notIn,omitempty"`
}

// AdvancedMessageSubscriptionStateFilter Advanced MessageSubscriptionStateEnum filter
type AdvancedMessageSubscriptionStateFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *MessageSubscriptionStateEnum `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]MessageSubscriptionStateEnum `json:"$in,omitempty"`

	// Like Checks if the property matches the provided like value.
	//
	// Supported wildcard characters are:
	//
	// * `*`: matches zero, one, or multiple characters.
	// * `?`: matches one, single character.
	//
	// Wildcard characters can be escaped with backslash, for instance: `\*`.
	Like *LikeFilter `json:"$like,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *MessageSubscriptionStateEnum `json:"$neq,omitempty"`
}

// AdvancedProcessDefinitionKeyFilter Advanced ProcessDefinitionKey filter.
type AdvancedProcessDefinitionKeyFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *ProcessDefinitionKey `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]ProcessDefinitionKey `json:"$in,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *ProcessDefinitionKey `json:"$neq,omitempty"`

	// NotIn Checks if the property matches none of the provided values.
	NotIn *[]ProcessDefinitionKey `json:"$notIn,omitempty"`
}

// AdvancedProcessInstanceKeyFilter Advanced ProcessInstanceKey filter.
type AdvancedProcessInstanceKeyFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *ProcessInstanceKey `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]ProcessInstanceKey `json:"$in,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *ProcessInstanceKey `json:"$neq,omitempty"`

	// NotIn Checks if the property matches none of the provided values.
	NotIn *[]ProcessInstanceKey `json:"$notIn,omitempty"`
}

// AdvancedProcessInstanceStateFilter Advanced ProcessInstanceStateEnum filter.
type AdvancedProcessInstanceStateFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *ProcessInstanceStateEnum `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]ProcessInstanceStateEnum `json:"$in,omitempty"`

	// Like Checks if the property matches the provided like value.
	//
	// Supported wildcard characters are:
	//
	// * `*`: matches zero, one, or multiple characters.
	// * `?`: matches one, single character.
	//
	// Wildcard characters can be escaped with backslash, for instance: `\*`.
	Like *LikeFilter `json:"$like,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *ProcessInstanceStateEnum `json:"$neq,omitempty"`
}

// AdvancedScopeKeyFilter Advanced ScopeKey filter.
type AdvancedScopeKeyFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *ScopeKey `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]ScopeKey `json:"$in,omitempty"`

	// Neq Checks for equality with the provided value.
	Neq *ScopeKey `json:"$neq,omitempty"`

	// NotIn Checks if the property matches none of the provided values.
	NotIn *[]ScopeKey `json:"$notIn,omitempty"`
}

// AdvancedStringFilter defines model for AdvancedStringFilter.
type AdvancedStringFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *string `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]string `json:"$in,omitempty"`

	// Like Checks if the property matches the provided like value.
	//
	// Supported wildcard characters are:
	//
	// * `*`: matches zero, one, or multiple characters.
	// * `?`: matches one, single character.
	//
	// Wildcard characters can be escaped with backslash, for instance: `\*`.
	Like *LikeFilter `json:"$like,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *string `json:"$neq,omitempty"`

	// NotIn Checks if the property matches none of the provided values.
	NotIn *[]string `json:"$notIn,omitempty"`
}

// AdvancedUserTaskStateFilter Advanced UserTaskStateEnum filter.
type AdvancedUserTaskStateFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *UserTaskStateEnum `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]UserTaskStateEnum `json:"$in,omitempty"`

	// Like Checks if the property matches the provided like value.
	//
	// Supported wildcard characters are:
	//
	// * `*`: matches zero, one, or multiple characters.
	// * `?`: matches one, single character.
	//
	// Wildcard characters can be escaped with backslash, for instance: `\*`.
	Like *LikeFilter `json:"$like,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *UserTaskStateEnum `json:"$neq,omitempty"`
}

// AdvancedVariableKeyFilter Advanced VariableKey filter.
type AdvancedVariableKeyFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *VariableKey `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]VariableKey `json:"$in,omitempty"`

	// Neq Checks for equality with the provided value.
	Neq *VariableKey `json:"$neq,omitempty"`

	// NotIn Checks if the property matches none of the provided values.
	NotIn *[]VariableKey `json:"$notIn,omitempty"`
}

// AuthorizationCreateResult defines model for AuthorizationCreateResult.
type AuthorizationCreateResult struct {
	// AuthorizationKey The key of the created authorization.
	AuthorizationKey *AuthorizationKey `json:"authorizationKey,omitempty"`
}

// AuthorizationFilter Authorization search filter.
type AuthorizationFilter struct {
	// OwnerId The ID of the owner of permissions.
	OwnerId *string `json:"ownerId,omitempty"`

	// OwnerType The type of the owner of permissions.
	OwnerType *OwnerTypeEnum `json:"ownerType,omitempty"`

	// ResourceIds The IDs of the resource to search permissions for.
	ResourceIds *[]string `json:"resourceIds,omitempty"`

	// ResourceType The type of resource to search permissions for.
	ResourceType *ResourceTypeEnum `json:"resourceType,omitempty"`
}

// AuthorizationKey Zeebe Engine resource key (Java long serialized as string)
type AuthorizationKey = LongKey

// AuthorizationRequest defines model for AuthorizationRequest.
type AuthorizationRequest struct {
	// OwnerId The ID of the owner of the permissions.
	OwnerId string `json:"ownerId"`

	// OwnerType The type of the owner of permissions.
	OwnerType OwnerTypeEnum `json:"ownerType"`

	// PermissionTypes The permission types to add.
	PermissionTypes []PermissionTypeEnum `json:"permissionTypes"`

	// ResourceId The ID of the resource to add permissions to.
	ResourceId string `json:"resourceId"`

	// ResourceType The type of resource to add permissions to.
	ResourceType ResourceTypeEnum `json:"resourceType"`
}

// AuthorizationResult defines model for AuthorizationResult.
type AuthorizationResult struct {
	// AuthorizationKey The key of the authorization.
	AuthorizationKey *AuthorizationKey `json:"authorizationKey,omitempty"`

	// OwnerId The ID of the owner of permissions.
	OwnerId *string `json:"ownerId,omitempty"`

	// OwnerType The type of the owner of permissions.
	OwnerType *OwnerTypeEnum `json:"ownerType,omitempty"`

	// PermissionTypes Specifies the types of the permissions.
	PermissionTypes *[]PermissionTypeEnum `json:"permissionTypes,omitempty"`

	// ResourceId ID of the resource the permission relates to.
	ResourceId *string `json:"resourceId,omitempty"`

	// ResourceType The type of resource that the permissions relate to.
	ResourceType *ResourceTypeEnum `json:"resourceType,omitempty"`
}

// AuthorizationSearchQuery defines model for AuthorizationSearchQuery.
type AuthorizationSearchQuery struct {
	// Filter Authorization search filter.
	Filter *AuthorizationFilter `json:"filter,omitempty"`

	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]AuthorizationSearchQuerySortRequest `json:"sort,omitempty"`
}

// AuthorizationSearchQuerySortRequest defines model for AuthorizationSearchQuerySortRequest.
type AuthorizationSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field AuthorizationSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// AuthorizationSearchQuerySortRequestField The field to sort by.
type AuthorizationSearchQuerySortRequestField string

// AuthorizationSearchResult defines model for AuthorizationSearchResult.
type AuthorizationSearchResult struct {
	// Items The matching authorizations.
	Items *[]AuthorizationResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// BaseProcessInstanceFilterFields Base process instance search filter.
type BaseProcessInstanceFilterFields struct {
	// BatchOperationId The batch operation ID.
	BatchOperationId *StringFilterProperty `json:"batchOperationId,omitempty"`

	// ElementId The element ID associated with the process instance.
	ElementId *StringFilterProperty `json:"elementId,omitempty"`

	// ElementInstanceState The state of the element instances associated with the process instance.
	ElementInstanceState *ElementInstanceStateFilterProperty `json:"elementInstanceState,omitempty"`

	// EndDate The end date.
	EndDate *DateTimeFilterProperty `json:"endDate,omitempty"`

	// ErrorMessage The error message related to the process.
	ErrorMessage *StringFilterProperty `json:"errorMessage,omitempty"`

	// HasElementInstanceIncident Whether the element instance has an incident or not.
	HasElementInstanceIncident *bool `json:"hasElementInstanceIncident,omitempty"`

	// HasIncident Whether this process instance has a related incident or not.
	HasIncident *bool `json:"hasIncident,omitempty"`

	// HasRetriesLeft Whether the process has failed jobs with retries left.
	HasRetriesLeft *bool `json:"hasRetriesLeft,omitempty"`

	// IncidentErrorHashCode The incident error hash code, associated with this process.
	IncidentErrorHashCode *IntegerFilterProperty `json:"incidentErrorHashCode,omitempty"`

	// ParentElementInstanceKey The parent element instance key.
	ParentElementInstanceKey *ElementInstanceKeyFilterProperty `json:"parentElementInstanceKey,omitempty"`

	// ParentProcessInstanceKey The parent process instance key.
	ParentProcessInstanceKey *ProcessInstanceKeyFilterProperty `json:"parentProcessInstanceKey,omitempty"`

	// ProcessInstanceKey The key of this process instance.
	ProcessInstanceKey *ProcessInstanceKeyFilterProperty `json:"processInstanceKey,omitempty"`

	// StartDate The start date.
	StartDate *DateTimeFilterProperty `json:"startDate,omitempty"`

	// State The process instance state.
	State *ProcessInstanceStateFilterProperty `json:"state,omitempty"`

	// Tags List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
	Tags *TagSet `json:"tags,omitempty"`

	// TenantId The tenant ID.
	TenantId *StringFilterProperty `json:"tenantId,omitempty"`

	// Variables The process instance variables.
	Variables *[]VariableValueFilterProperty `json:"variables,omitempty"`
}

// BasicStringFilter Basic advanced string filter.
type BasicStringFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *string `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]string `json:"$in,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *string `json:"$neq,omitempty"`

	// NotIn Checks if the property matches none of the provided values.
	NotIn *[]string `json:"$notIn,omitempty"`
}

// BasicStringFilterProperty String property with basic advanced search capabilities.
type BasicStringFilterProperty struct {
	union json.RawMessage
}

// BasicStringFilterProperty0 Matches the value exactly.
type BasicStringFilterProperty0 = string

// BatchOperationCreatedResult The created batch operation.
type BatchOperationCreatedResult struct {
	// BatchOperationKey Key of the batch operation.
	BatchOperationKey *BatchOperationKey `json:"batchOperationKey,omitempty"`

	// BatchOperationType The type of the batch operation.
	BatchOperationType *BatchOperationTypeEnum `json:"batchOperationType,omitempty"`
}

// BatchOperationError defines model for BatchOperationError.
type BatchOperationError struct {
	// Message The error message that occurred during the batch operation.
	Message *string `json:"message,omitempty"`

	// PartitionId The partition ID where the error occurred.
	PartitionId *int32 `json:"partitionId,omitempty"`

	// Type The type of the error that occurred during the batch operation.
	Type *BatchOperationErrorType `json:"type,omitempty"`
}

// BatchOperationErrorType The type of the error that occurred during the batch operation.
type BatchOperationErrorType string

// BatchOperationFilter Batch operation filter request.
type BatchOperationFilter struct {
	// BatchOperationKey The key (or operate legacy ID) of the batch operation.
	BatchOperationKey *BasicStringFilterProperty `json:"batchOperationKey,omitempty"`

	// OperationType The type of the batch operation.
	OperationType *BatchOperationTypeFilterProperty `json:"operationType,omitempty"`

	// State The state of the batch operation.
	State *BatchOperationStateFilterProperty `json:"state,omitempty"`
}

// BatchOperationItemFilter Batch operation item filter request.
type BatchOperationItemFilter struct {
	// BatchOperationKey The key (or operate legacy ID) of the batch operation.
	BatchOperationKey *BasicStringFilterProperty `json:"batchOperationKey,omitempty"`

	// ItemKey The key of the item, e.g. a process instance key.
	ItemKey *BasicStringFilterProperty `json:"itemKey,omitempty"`

	// ProcessInstanceKey The process instance key of the processed item.
	ProcessInstanceKey *ProcessInstanceKeyFilterProperty `json:"processInstanceKey,omitempty"`

	// State The state of the batch operation.
	State *BatchOperationItemStateFilterProperty `json:"state,omitempty"`
}

// BatchOperationItemResponse defines model for BatchOperationItemResponse.
type BatchOperationItemResponse struct {
	// BatchOperationKey The key (or operate legacy ID) of the batch operation.
	BatchOperationKey *BatchOperationKey `json:"batchOperationKey,omitempty"`

	// ErrorMessage the error message from the engine in case of a failed operation.
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// ItemKey Key of the item, e.g. a process instance key.
	ItemKey *string `json:"itemKey,omitempty"`

	// OperationType The type of the batch operation.
	OperationType *BatchOperationTypeEnum `json:"operationType,omitempty"`

	// ProcessInstanceKey the process instance key of the processed item.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// ProcessedDate the date this item was processed.
	ProcessedDate *time.Time `json:"processedDate,omitempty"`

	// State State of the item.
	State *BatchOperationItemResponseState `json:"state,omitempty"`
}

// BatchOperationItemResponseState State of the item.
type BatchOperationItemResponseState string

// BatchOperationItemSearchQuery defines model for BatchOperationItemSearchQuery.
type BatchOperationItemSearchQuery struct {
	// Filter Batch operation item filter request.
	Filter *BatchOperationItemFilter `json:"filter,omitempty"`

	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]BatchOperationItemSearchQuerySortRequest `json:"sort,omitempty"`
}

// BatchOperationItemSearchQueryResult defines model for BatchOperationItemSearchQueryResult.
type BatchOperationItemSearchQueryResult struct {
	// Items The matching batch operations.
	Items *[]BatchOperationItemResponse `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// BatchOperationItemSearchQuerySortRequest defines model for BatchOperationItemSearchQuerySortRequest.
type BatchOperationItemSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field BatchOperationItemSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// BatchOperationItemSearchQuerySortRequestField The field to sort by.
type BatchOperationItemSearchQuerySortRequestField string

// BatchOperationItemStateEnum The state, one of ACTIVE, COMPLETED, TERMINATED.
type BatchOperationItemStateEnum string

// BatchOperationItemStateFilterProperty BatchOperationItemStateEnum property with full advanced search capabilities.
type BatchOperationItemStateFilterProperty struct {
	union json.RawMessage
}

// BatchOperationItemStateFilterProperty0 The state, one of ACTIVE, COMPLETED, TERMINATED.
type BatchOperationItemStateFilterProperty0 = BatchOperationItemStateEnum

// BatchOperationKey System-generated key for an batch operation.
type BatchOperationKey = string

// BatchOperationResponse defines model for BatchOperationResponse.
type BatchOperationResponse struct {
	// BatchOperationKey Key or (Operate Legacy ID = UUID) of the batch operation.
	BatchOperationKey *BatchOperationKey `json:"batchOperationKey,omitempty"`

	// BatchOperationType The type of the batch operation.
	BatchOperationType *BatchOperationTypeEnum `json:"batchOperationType,omitempty"`

	// EndDate The end date of the batch operation.
	EndDate *time.Time `json:"endDate,omitempty"`

	// Errors The errors that occurred per partition during the batch operation.
	Errors *[]BatchOperationError `json:"errors,omitempty"`

	// OperationsCompletedCount The number of successfully completed tasks.
	OperationsCompletedCount *int32 `json:"operationsCompletedCount,omitempty"`

	// OperationsFailedCount The number of items which failed during execution of the batch operation. (e.g. because they are rejected by the Zeebe engine).
	OperationsFailedCount *int32 `json:"operationsFailedCount,omitempty"`

	// OperationsTotalCount The total number of items contained in this batch operation.
	OperationsTotalCount *int32 `json:"operationsTotalCount,omitempty"`

	// StartDate The start date of the batch operation.
	StartDate *time.Time `json:"startDate,omitempty"`

	// State The state of the batch operation.
	State *BatchOperationResponseState `json:"state,omitempty"`
}

// BatchOperationResponseState The state of the batch operation.
type BatchOperationResponseState string

// BatchOperationSearchQuery defines model for BatchOperationSearchQuery.
type BatchOperationSearchQuery struct {
	// Filter Batch operation filter request.
	Filter *BatchOperationFilter `json:"filter,omitempty"`

	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]BatchOperationSearchQuerySortRequest `json:"sort,omitempty"`
}

// BatchOperationSearchQueryResult defines model for BatchOperationSearchQueryResult.
type BatchOperationSearchQueryResult struct {
	// Items The matching batch operations.
	Items *[]BatchOperationResponse `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// BatchOperationSearchQuerySortRequest defines model for BatchOperationSearchQuerySortRequest.
type BatchOperationSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field BatchOperationSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// BatchOperationSearchQuerySortRequestField The field to sort by.
type BatchOperationSearchQuerySortRequestField string

// BatchOperationStateEnum The batch operation state.
type BatchOperationStateEnum string

// BatchOperationStateFilterProperty BatchOperationStateEnum property with full advanced search capabilities.
type BatchOperationStateFilterProperty struct {
	union json.RawMessage
}

// BatchOperationStateFilterProperty0 The batch operation state.
type BatchOperationStateFilterProperty0 = BatchOperationStateEnum

// BatchOperationTypeEnum The type of the batch operation.
type BatchOperationTypeEnum string

// BatchOperationTypeFilterProperty BatchOperationTypeEnum property with full advanced search capabilities.
type BatchOperationTypeFilterProperty struct {
	union json.RawMessage
}

// BatchOperationTypeFilterProperty0 The type of the batch operation.
type BatchOperationTypeFilterProperty0 = BatchOperationTypeEnum

// BrokerInfo Provides information on a broker node.
type BrokerInfo struct {
	// Host The hostname for reaching the broker.
	Host string `json:"host"`

	// NodeId The unique (within a cluster) node ID for the broker.
	NodeId int32 `json:"nodeId"`

	// Partitions A list of partitions managed or replicated on this broker.
	Partitions []Partition `json:"partitions"`

	// Port The port for reaching the broker.
	Port int32 `json:"port"`

	// Version The broker version.
	Version string `json:"version"`
}

// CamundaUserResult defines model for CamundaUserResult.
type CamundaUserResult struct {
	// AuthorizedComponents The web components the user is authorized to use.
	AuthorizedComponents *[]string `json:"authorizedComponents,omitempty"`

	// C8Links The links to the components in the C8 stack.
	C8Links map[string]string `json:"c8Links"`

	// CanLogout Flag for understanding if the user is able to perform logout.
	CanLogout bool `json:"canLogout"`

	// DisplayName The display name of the user.
	DisplayName *string `json:"displayName"`

	// Email The email of the user.
	Email *string `json:"email"`

	// Groups The groups assigned to the user.
	Groups []string `json:"groups"`

	// Roles The roles assigned to the user.
	Roles []string `json:"roles"`

	// SalesPlanType The plan of the user.
	SalesPlanType string `json:"salesPlanType"`

	// Tenants The tenants the user is a member of.
	Tenants []TenantResult `json:"tenants"`

	// Username The username of the user.
	Username *Username `json:"username"`
}

// CancelProcessInstanceRequest defines model for CancelProcessInstanceRequest.
type CancelProcessInstanceRequest struct {
	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
	// Must be > 0 if provided.
	OperationReference *OperationReference `json:"operationReference,omitempty"`
}

// Changeset JSON object with changed task attribute values.
//
// The following attributes can be adjusted with this endpoint, additional attributes
// will be ignored:
//
// * `candidateGroups` - reset by providing an empty list
// * `candidateUsers` - reset by providing an empty list
// * `dueDate` - reset by providing an empty String
// * `followUpDate` - reset by providing an empty String
// * `priority` - minimum 0, maximum 100, default 50
//
// Providing any of those attributes with a `null` value or omitting it preserves
// the persisted attribute's value.
//
// The assignee cannot be adjusted with this endpoint, use the Assign task endpoint.
// This ensures correct event emission for assignee changes.
type Changeset struct {
	// CandidateGroups The list of candidate groups of the task. Reset by providing an empty list.
	CandidateGroups *[]string `json:"candidateGroups"`

	// CandidateUsers The list of candidate users of the task. Reset by providing an empty list.
	CandidateUsers *[]string `json:"candidateUsers"`

	// DueDate The due date of the task. Reset by providing an empty String.
	DueDate *time.Time `json:"dueDate"`

	// FollowUpDate The follow-up date of the task. Reset by providing an empty String.
	FollowUpDate *time.Time `json:"followUpDate"`

	// Priority The priority of the task.
	Priority             *int32                 `json:"priority"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ClockPinRequest defines model for ClockPinRequest.
type ClockPinRequest struct {
	// Timestamp The exact time in epoch milliseconds to which the clock should be pinned.
	Timestamp int64 `json:"timestamp"`
}

// CorrelatedMessageSubscriptionFilter Correlated message subscriptions search filter.
type CorrelatedMessageSubscriptionFilter struct {
	// CorrelationKey The correlation key of the message.
	CorrelationKey *StringFilterProperty `json:"correlationKey,omitempty"`

	// CorrelationTime The time when the message was correlated.
	CorrelationTime *DateTimeFilterProperty `json:"correlationTime,omitempty"`

	// ElementId The element ID that received the message.
	ElementId *StringFilterProperty `json:"elementId,omitempty"`

	// ElementInstanceKey The element instance key that received the message.
	ElementInstanceKey *ElementInstanceKeyFilterProperty `json:"elementInstanceKey,omitempty"`

	// MessageKey The message key.
	MessageKey *BasicStringFilterProperty `json:"messageKey,omitempty"`

	// MessageName The name of the message.
	MessageName *StringFilterProperty `json:"messageName,omitempty"`

	// PartitionId The partition ID that correlated the message.
	PartitionId *IntegerFilterProperty `json:"partitionId,omitempty"`

	// ProcessDefinitionId The process definition ID associated with this correlated message subscription.
	ProcessDefinitionId *StringFilterProperty `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The process definition key associated with this correlated message subscription.
	ProcessDefinitionKey *BasicStringFilterProperty `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey The process instance key associated with this correlated message subscription.
	ProcessInstanceKey *BasicStringFilterProperty `json:"processInstanceKey,omitempty"`

	// SubscriptionKey The subscription key that received the message.
	SubscriptionKey *BasicStringFilterProperty `json:"subscriptionKey,omitempty"`

	// TenantId The tenant ID associated with this correlated message subscription.
	TenantId *StringFilterProperty `json:"tenantId,omitempty"`
}

// CorrelatedMessageSubscriptionResult defines model for CorrelatedMessageSubscriptionResult.
type CorrelatedMessageSubscriptionResult struct {
	// CorrelationKey The correlation key of the message.
	CorrelationKey string `json:"correlationKey"`

	// CorrelationTime The time when the message was correlated.
	CorrelationTime time.Time `json:"correlationTime"`

	// ElementId The element ID that received the message.
	ElementId string `json:"elementId"`

	// ElementInstanceKey The element instance key that received the message.
	ElementInstanceKey *ElementInstanceKey `json:"elementInstanceKey,omitempty"`

	// MessageKey The message key.
	MessageKey MessageKey `json:"messageKey"`

	// MessageName The name of the message.
	MessageName string `json:"messageName"`

	// PartitionId The partition ID that correlated the message.
	PartitionId int32 `json:"partitionId"`

	// ProcessDefinitionId The process definition ID associated with this correlated message subscription.
	ProcessDefinitionId ProcessDefinitionId `json:"processDefinitionId"`

	// ProcessDefinitionKey The process definition key associated with this correlated message subscription.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey The process instance key associated with this correlated message subscription.
	ProcessInstanceKey ProcessInstanceKey `json:"processInstanceKey"`

	// SubscriptionKey The subscription key that received the message.
	SubscriptionKey MessageSubscriptionKey `json:"subscriptionKey"`

	// TenantId The tenant ID associated with this correlated message subscription.
	TenantId TenantId `json:"tenantId"`
}

// CorrelatedMessageSubscriptionSearchQuery defines model for CorrelatedMessageSubscriptionSearchQuery.
type CorrelatedMessageSubscriptionSearchQuery struct {
	// Filter Correlated message subscriptions search filter.
	Filter *CorrelatedMessageSubscriptionFilter `json:"filter,omitempty"`

	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]CorrelatedMessageSubscriptionSearchQuerySortRequest `json:"sort,omitempty"`
}

// CorrelatedMessageSubscriptionSearchQueryResult defines model for CorrelatedMessageSubscriptionSearchQueryResult.
type CorrelatedMessageSubscriptionSearchQueryResult struct {
	// Items The matching correlated message subscriptions.
	Items *[]CorrelatedMessageSubscriptionResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// CorrelatedMessageSubscriptionSearchQuerySortRequest defines model for CorrelatedMessageSubscriptionSearchQuerySortRequest.
type CorrelatedMessageSubscriptionSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field CorrelatedMessageSubscriptionSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// CorrelatedMessageSubscriptionSearchQuerySortRequestField The field to sort by.
type CorrelatedMessageSubscriptionSearchQuerySortRequestField string

// CreateProcessInstanceResult defines model for CreateProcessInstanceResult.
type CreateProcessInstanceResult struct {
	// ProcessDefinitionId The BPMN process ID of the process definition which was used to create the process.
	// instance
	ProcessDefinitionId ProcessDefinitionId `json:"processDefinitionId"`

	// ProcessDefinitionKey The key of the process definition which was used to create the process instance.
	ProcessDefinitionKey ProcessDefinitionKey `json:"processDefinitionKey"`

	// ProcessDefinitionVersion The version of the process definition which was used to create the process instance.
	ProcessDefinitionVersion int32 `json:"processDefinitionVersion"`

	// ProcessInstanceKey The unique identifier of the created process instance; to be used wherever a request
	// needs a process instance key (e.g. CancelProcessInstanceRequest).
	ProcessInstanceKey ProcessInstanceKey `json:"processInstanceKey"`

	// Tags List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
	Tags *TagSet `json:"tags,omitempty"`

	// TenantId The tenant ID of the created process instance.
	TenantId TenantId `json:"tenantId"`

	// Variables All the variables visible in the root scope.
	Variables map[string]interface{} `json:"variables"`
}

// CursorBackwardPagination defines model for CursorBackwardPagination.
type CursorBackwardPagination struct {
	// Before Use the `startCursor` value from the previous response to fetch the previous page of results.
	Before StartCursor `json:"before"`

	// Limit The maximum number of items to return in one request.
	Limit *int32 `json:"limit,omitempty"`
}

// CursorForwardPagination defines model for CursorForwardPagination.
type CursorForwardPagination struct {
	// After Use the `endCursor` value from the previous response to fetch the next page of results.
	After EndCursor `json:"after"`

	// Limit The maximum number of items to return in one request.
	Limit *int32 `json:"limit,omitempty"`
}

// DateTimeFilterProperty Date-time property with full advanced search capabilities.
type DateTimeFilterProperty struct {
	union json.RawMessage
}

// DateTimeFilterProperty0 Matches the value exactly.
type DateTimeFilterProperty0 = time.Time

// DecisionDefinitionFilter Decision definition search filter.
type DecisionDefinitionFilter struct {
	// DecisionDefinitionId The DMN ID of the decision definition.
	DecisionDefinitionId *DecisionDefinitionId `json:"decisionDefinitionId,omitempty"`

	// DecisionDefinitionKey The assigned key, which acts as a unique identifier for this decision definition.
	DecisionDefinitionKey *DecisionDefinitionKey `json:"decisionDefinitionKey,omitempty"`

	// DecisionRequirementsId the DMN ID of the decision requirements graph that the decision definition is part of.
	DecisionRequirementsId *string `json:"decisionRequirementsId,omitempty"`

	// DecisionRequirementsKey The assigned key of the decision requirements graph that the decision definition is part of.
	DecisionRequirementsKey *DecisionRequirementsKey `json:"decisionRequirementsKey,omitempty"`

	// Name The DMN name of the decision definition.
	Name *string `json:"name,omitempty"`

	// TenantId The tenant ID of the decision definition.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version The assigned version of the decision definition.
	Version *int32 `json:"version,omitempty"`
}

// DecisionDefinitionId Id of a decision definition, from the model. Only ids of decision definitions that are deployed are useful.
type DecisionDefinitionId = string

// DecisionDefinitionKey Zeebe Engine resource key (Java long serialized as string)
type DecisionDefinitionKey = LongKey

// DecisionDefinitionKeyFilterProperty DecisionDefinitionKey property with full advanced search capabilities.
type DecisionDefinitionKeyFilterProperty struct {
	union json.RawMessage
}

// DecisionDefinitionKeyFilterProperty0 System-generated key for a decision definition.
type DecisionDefinitionKeyFilterProperty0 = DecisionDefinitionKey

// DecisionDefinitionResult defines model for DecisionDefinitionResult.
type DecisionDefinitionResult struct {
	// DecisionDefinitionId The DMN ID of the decision definition.
	DecisionDefinitionId *DecisionDefinitionId `json:"decisionDefinitionId,omitempty"`

	// DecisionDefinitionKey The assigned key, which acts as a unique identifier for this decision definition.
	DecisionDefinitionKey *DecisionDefinitionKey `json:"decisionDefinitionKey,omitempty"`

	// DecisionRequirementsId the DMN ID of the decision requirements graph that the decision definition is part of.
	DecisionRequirementsId *string `json:"decisionRequirementsId,omitempty"`

	// DecisionRequirementsKey The assigned key of the decision requirements graph that the decision definition is part of.
	DecisionRequirementsKey *DecisionRequirementsKey `json:"decisionRequirementsKey,omitempty"`

	// Name The DMN name of the decision definition.
	Name *string `json:"name,omitempty"`

	// TenantId The tenant ID of the decision definition.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version The assigned version of the decision definition.
	Version *int32 `json:"version,omitempty"`
}

// DecisionDefinitionSearchQuery defines model for DecisionDefinitionSearchQuery.
type DecisionDefinitionSearchQuery struct {
	// Filter Decision definition search filter.
	Filter *DecisionDefinitionFilter `json:"filter,omitempty"`

	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]DecisionDefinitionSearchQuerySortRequest `json:"sort,omitempty"`
}

// DecisionDefinitionSearchQueryResult defines model for DecisionDefinitionSearchQueryResult.
type DecisionDefinitionSearchQueryResult struct {
	// Items The matching decision definitions.
	Items *[]DecisionDefinitionResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// DecisionDefinitionSearchQuerySortRequest defines model for DecisionDefinitionSearchQuerySortRequest.
type DecisionDefinitionSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field DecisionDefinitionSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// DecisionDefinitionSearchQuerySortRequestField The field to sort by.
type DecisionDefinitionSearchQuerySortRequestField string

// DecisionDefinitionTypeEnum The type of the decision.
type DecisionDefinitionTypeEnum string

// DecisionEvaluationById defines model for DecisionEvaluationById.
type DecisionEvaluationById struct {
	// DecisionDefinitionId The ID of the decision to be evaluated.
	// When using the decision ID, the latest
	// deployed version of the decision is used.
	DecisionDefinitionId DecisionDefinitionId `json:"decisionDefinitionId"`

	// TenantId The tenant ID of the decision.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Variables The message variables as JSON document.
	Variables *map[string]interface{} `json:"variables,omitempty"`
}

// DecisionEvaluationByKey defines model for DecisionEvaluationByKey.
type DecisionEvaluationByKey struct {
	// DecisionDefinitionKey System-generated key for a decision definition.
	DecisionDefinitionKey DecisionDefinitionKey `json:"decisionDefinitionKey"`

	// TenantId The tenant ID of the decision.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Variables The message variables as JSON document.
	Variables *map[string]interface{} `json:"variables,omitempty"`
}

// DecisionEvaluationInstanceKey Zeebe Engine resource key (Java long serialized as string)
type DecisionEvaluationInstanceKey = LongKey

// DecisionEvaluationInstruction defines model for DecisionEvaluationInstruction.
type DecisionEvaluationInstruction struct {
	union json.RawMessage
}

// DecisionEvaluationKey Zeebe Engine resource key (Java long serialized as string)
type DecisionEvaluationKey = LongKey

// DecisionInstanceFilter Decision instance search filter.
type DecisionInstanceFilter struct {
	// DecisionDefinitionId The ID of the DMN decision.
	DecisionDefinitionId *DecisionDefinitionId `json:"decisionDefinitionId,omitempty"`

	// DecisionDefinitionKey The key of the decision.
	DecisionDefinitionKey *DecisionDefinitionKeyFilterProperty `json:"decisionDefinitionKey,omitempty"`

	// DecisionDefinitionName The name of the DMN decision.
	DecisionDefinitionName *string `json:"decisionDefinitionName,omitempty"`

	// DecisionDefinitionType The type of the decision.
	DecisionDefinitionType *DecisionDefinitionTypeEnum `json:"decisionDefinitionType,omitempty"`

	// DecisionDefinitionVersion The version of the decision.
	DecisionDefinitionVersion *int32 `json:"decisionDefinitionVersion,omitempty"`

	// DecisionEvaluationInstanceKey System-generated key for a decision evaluation instance.
	DecisionEvaluationInstanceKey *DecisionEvaluationInstanceKey `json:"decisionEvaluationInstanceKey,omitempty"`

	// DecisionEvaluationKey The key of the parent decision evaluation. Note that this is not the identifier of an individual decision instance; the `decisionEvaluationInstanceKey` is the identifier for a decision instance.
	DecisionEvaluationKey *DecisionEvaluationKey `json:"decisionEvaluationKey,omitempty"`

	// ElementInstanceKey The key of the element instance this decision instance is linked to.
	ElementInstanceKey *ElementInstanceKeyFilterProperty `json:"elementInstanceKey,omitempty"`

	// EvaluationDate The evaluation date of the decision instance.
	EvaluationDate *DateTimeFilterProperty `json:"evaluationDate,omitempty"`

	// EvaluationFailure The evaluation failure of the decision instance.
	EvaluationFailure *string `json:"evaluationFailure,omitempty"`

	// ProcessDefinitionKey The key of the process definition.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey The key of the process instance.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// State The state of the decision instance.
	State *DecisionInstanceStateEnum `json:"state,omitempty"`

	// TenantId The tenant ID of the decision instance.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// DecisionInstanceGetQueryResult defines model for DecisionInstanceGetQueryResult.
type DecisionInstanceGetQueryResult struct {
	// DecisionDefinitionId The ID of the DMN decision.
	DecisionDefinitionId *DecisionDefinitionId `json:"decisionDefinitionId,omitempty"`

	// DecisionDefinitionKey The key of the decision.
	DecisionDefinitionKey *DecisionDefinitionKey `json:"decisionDefinitionKey,omitempty"`

	// DecisionDefinitionName The name of the DMN decision.
	DecisionDefinitionName *string `json:"decisionDefinitionName,omitempty"`

	// DecisionDefinitionType The type of the decision.
	DecisionDefinitionType *DecisionDefinitionTypeEnum `json:"decisionDefinitionType,omitempty"`

	// DecisionDefinitionVersion The version of the decision.
	DecisionDefinitionVersion *int32 `json:"decisionDefinitionVersion,omitempty"`

	// DecisionEvaluationInstanceKey System-generated key for a decision evaluation instance.
	DecisionEvaluationInstanceKey *DecisionEvaluationInstanceKey `json:"decisionEvaluationInstanceKey,omitempty"`

	// DecisionEvaluationKey The key of the decision evaluation where this instance was created.
	DecisionEvaluationKey *DecisionEvaluationKey `json:"decisionEvaluationKey,omitempty"`

	// ElementInstanceKey The key of the element instance this decision instance is linked to.
	ElementInstanceKey *ElementInstanceKey `json:"elementInstanceKey,omitempty"`

	// EvaluatedInputs The evaluated inputs of the decision instance.
	EvaluatedInputs *[]EvaluatedDecisionInputItem `json:"evaluatedInputs,omitempty"`

	// EvaluationDate The evaluation date of the decision instance.
	EvaluationDate *time.Time `json:"evaluationDate,omitempty"`

	// EvaluationFailure The evaluation failure of the decision instance.
	EvaluationFailure *string `json:"evaluationFailure,omitempty"`

	// MatchedRules The matched rules of the decision instance.
	MatchedRules *[]MatchedDecisionRuleItem `json:"matchedRules,omitempty"`

	// ProcessDefinitionKey The key of the process definition.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey The key of the process instance.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// Result The result of the decision instance.
	Result *string `json:"result,omitempty"`

	// State The state of the decision instance.
	State *DecisionInstanceStateEnum `json:"state,omitempty"`

	// TenantId The tenant ID of the decision instance.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// DecisionInstanceKey Zeebe Engine resource key (Java long serialized as string)
type DecisionInstanceKey = LongKey

// DecisionInstanceResult defines model for DecisionInstanceResult.
type DecisionInstanceResult struct {
	// DecisionDefinitionId The ID of the DMN decision.
	DecisionDefinitionId *DecisionDefinitionId `json:"decisionDefinitionId,omitempty"`

	// DecisionDefinitionKey The key of the decision.
	DecisionDefinitionKey *DecisionDefinitionKey `json:"decisionDefinitionKey,omitempty"`

	// DecisionDefinitionName The name of the DMN decision.
	DecisionDefinitionName *string `json:"decisionDefinitionName,omitempty"`

	// DecisionDefinitionType The type of the decision.
	DecisionDefinitionType *DecisionDefinitionTypeEnum `json:"decisionDefinitionType,omitempty"`

	// DecisionDefinitionVersion The version of the decision.
	DecisionDefinitionVersion *int32 `json:"decisionDefinitionVersion,omitempty"`

	// DecisionEvaluationInstanceKey System-generated key for a decision evaluation instance.
	DecisionEvaluationInstanceKey *DecisionEvaluationInstanceKey `json:"decisionEvaluationInstanceKey,omitempty"`

	// DecisionEvaluationKey The key of the decision evaluation where this instance was created.
	DecisionEvaluationKey *DecisionEvaluationKey `json:"decisionEvaluationKey,omitempty"`

	// ElementInstanceKey The key of the element instance this decision instance is linked to.
	ElementInstanceKey *ElementInstanceKey `json:"elementInstanceKey,omitempty"`

	// EvaluationDate The evaluation date of the decision instance.
	EvaluationDate *time.Time `json:"evaluationDate,omitempty"`

	// EvaluationFailure The evaluation failure of the decision instance.
	EvaluationFailure *string `json:"evaluationFailure,omitempty"`

	// ProcessDefinitionKey The key of the process definition.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey The key of the process instance.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// Result The result of the decision instance.
	Result *string `json:"result,omitempty"`

	// State The state of the decision instance.
	State *DecisionInstanceStateEnum `json:"state,omitempty"`

	// TenantId The tenant ID of the decision instance.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// DecisionInstanceSearchQuery defines model for DecisionInstanceSearchQuery.
type DecisionInstanceSearchQuery struct {
	// Filter Decision instance search filter.
	Filter *DecisionInstanceFilter `json:"filter,omitempty"`

	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]DecisionInstanceSearchQuerySortRequest `json:"sort,omitempty"`
}

// DecisionInstanceSearchQueryResult defines model for DecisionInstanceSearchQueryResult.
type DecisionInstanceSearchQueryResult struct {
	// Items The matching decision instances.
	Items *[]DecisionInstanceResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// DecisionInstanceSearchQuerySortRequest defines model for DecisionInstanceSearchQuerySortRequest.
type DecisionInstanceSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field DecisionInstanceSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// DecisionInstanceSearchQuerySortRequestField The field to sort by.
type DecisionInstanceSearchQuerySortRequestField string

// DecisionInstanceStateEnum The state of the decision instance.
type DecisionInstanceStateEnum string

// DecisionRequirementsFilter Decision requirements search filter.
type DecisionRequirementsFilter struct {
	// DecisionRequirementsId the DMN ID of the decision requirements.
	DecisionRequirementsId *string `json:"decisionRequirementsId,omitempty"`

	// DecisionRequirementsKey The assigned key, which acts as a unique identifier for this decision requirements.
	DecisionRequirementsKey *DecisionRequirementsKey `json:"decisionRequirementsKey,omitempty"`

	// DecisionRequirementsName The DMN name of the decision requirements.
	DecisionRequirementsName *string `json:"decisionRequirementsName,omitempty"`

	// ResourceName The name of the resource from which the decision requirements were parsed.
	ResourceName *string `json:"resourceName,omitempty"`

	// TenantId The tenant ID of the decision requirements.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version The assigned version of the decision requirements.
	Version *int32 `json:"version,omitempty"`
}

// DecisionRequirementsKey Zeebe Engine resource key (Java long serialized as string)
type DecisionRequirementsKey = LongKey

// DecisionRequirementsResult defines model for DecisionRequirementsResult.
type DecisionRequirementsResult struct {
	// DecisionRequirementsId The DMN ID of the decision requirements.
	DecisionRequirementsId *string `json:"decisionRequirementsId,omitempty"`

	// DecisionRequirementsKey The assigned key, which acts as a unique identifier for this decision requirements.
	DecisionRequirementsKey *DecisionRequirementsKey `json:"decisionRequirementsKey,omitempty"`

	// DecisionRequirementsName The DMN name of the decision requirements.
	DecisionRequirementsName *string `json:"decisionRequirementsName,omitempty"`

	// ResourceName The name of the resource from which this decision requirements was parsed.
	ResourceName *string `json:"resourceName,omitempty"`

	// TenantId The tenant ID of the decision requirements.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version The assigned version of the decision requirements.
	Version *int32 `json:"version,omitempty"`
}

// DecisionRequirementsSearchQuery defines model for DecisionRequirementsSearchQuery.
type DecisionRequirementsSearchQuery struct {
	// Filter Decision requirements search filter.
	Filter *DecisionRequirementsFilter `json:"filter,omitempty"`

	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]DecisionRequirementsSearchQuerySortRequest `json:"sort,omitempty"`
}

// DecisionRequirementsSearchQueryResult defines model for DecisionRequirementsSearchQueryResult.
type DecisionRequirementsSearchQueryResult struct {
	// Items The matching decision requirements.
	Items *[]DecisionRequirementsResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// DecisionRequirementsSearchQuerySortRequest defines model for DecisionRequirementsSearchQuerySortRequest.
type DecisionRequirementsSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field DecisionRequirementsSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// DecisionRequirementsSearchQuerySortRequestField The field to sort by.
type DecisionRequirementsSearchQuerySortRequestField string

// DeleteResourceRequest defines model for DeleteResourceRequest.
type DeleteResourceRequest struct {
	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
	// Must be > 0 if provided.
	OperationReference *OperationReference `json:"operationReference,omitempty"`
}

// DeploymentDecisionRequirementsResult Deployed decision requirements.
type DeploymentDecisionRequirementsResult struct {
	// DecisionRequirementsId The dmn decision requirements ID, as parsed during deployment; together with the versions forms a unique identifier for a specific decision.
	DecisionRequirementsId *string `json:"decisionRequirementsId,omitempty"`

	// DecisionRequirementsKey The assigned decision requirements key, which acts as a unique identifier for this decision requirements.
	DecisionRequirementsKey *DecisionRequirementsKey `json:"decisionRequirementsKey,omitempty"`

	// DecisionRequirementsName The DMN name of the decision requirements, as parsed during deployment.
	DecisionRequirementsName *string `json:"decisionRequirementsName,omitempty"`

	// ResourceName The resource name from which this decision requirements was parsed.
	ResourceName *string `json:"resourceName,omitempty"`

	// TenantId The tenant ID of the deployed decision requirements.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version The assigned decision requirements version.
	Version *int32 `json:"version,omitempty"`
}

// DeploymentDecisionResult A deployed decision.
type DeploymentDecisionResult struct {
	// DecisionDefinitionId The dmn decision ID, as parsed during deployment, together with the version forms a
	// unique identifier for a specific decision.
	DecisionDefinitionId *DecisionDefinitionId `json:"decisionDefinitionId,omitempty"`

	// DecisionDefinitionKey The assigned decision key, which acts as a unique identifier for this decision.
	DecisionDefinitionKey *DecisionDefinitionKey `json:"decisionDefinitionKey,omitempty"`

	// DecisionRequirementsId The dmn ID of the decision requirements graph that this decision is part of, as parsed during deployment.
	DecisionRequirementsId *string `json:"decisionRequirementsId,omitempty"`

	// DecisionRequirementsKey The assigned key of the decision requirements graph that this decision is part of.
	DecisionRequirementsKey *DecisionRequirementsKey `json:"decisionRequirementsKey,omitempty"`

	// Name The DMN name of the decision, as parsed during deployment.
	Name *string `json:"name,omitempty"`

	// TenantId The tenant ID of the deployed decision.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version The assigned decision version.
	Version *int32 `json:"version,omitempty"`
}

// DeploymentFormResult A deployed form.
type DeploymentFormResult struct {
	// FormId The form ID, as parsed during deployment, together with the version forms a
	// unique identifier for a specific form.
	FormId *FormId `json:"formId,omitempty"`

	// FormKey The assigned key, which acts as a unique identifier for this form.
	FormKey *FormKey `json:"formKey,omitempty"`

	// ResourceName The resource name from which this form was parsed.
	ResourceName *string `json:"resourceName,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version The assigned form version.
	Version *int32 `json:"version,omitempty"`
}

// DeploymentKey Zeebe Engine resource key (Java long serialized as string)
type DeploymentKey = LongKey

// DeploymentMetadataResult defines model for DeploymentMetadataResult.
type DeploymentMetadataResult struct {
	// DecisionDefinition A deployed decision.
	DecisionDefinition *DeploymentDecisionResult `json:"decisionDefinition,omitempty"`

	// DecisionRequirements Deployed decision requirements.
	DecisionRequirements *DeploymentDecisionRequirementsResult `json:"decisionRequirements,omitempty"`

	// Form A deployed form.
	Form *DeploymentFormResult `json:"form,omitempty"`

	// ProcessDefinition A deployed process.
	ProcessDefinition *DeploymentProcessResult `json:"processDefinition,omitempty"`

	// Resource A deployed Resource.
	Resource *DeploymentResourceResult `json:"resource,omitempty"`
}

// DeploymentProcessResult A deployed process.
type DeploymentProcessResult struct {
	// ProcessDefinitionId The bpmn process ID, as parsed during deployment, together with the version forms a
	// unique identifier for a specific process definition.
	ProcessDefinitionId ProcessDefinitionId `json:"processDefinitionId"`

	// ProcessDefinitionKey The assigned key, which acts as a unique identifier for this process.
	ProcessDefinitionKey ProcessDefinitionKey `json:"processDefinitionKey"`

	// ProcessDefinitionVersion The assigned process version.
	ProcessDefinitionVersion int32 `json:"processDefinitionVersion"`

	// ResourceName The resource name from which this process was parsed.
	ResourceName string `json:"resourceName"`

	// TenantId The tenant ID of the deployed process.
	TenantId TenantId `json:"tenantId"`
}

// DeploymentResourceResult A deployed Resource.
type DeploymentResourceResult struct {
	// ResourceId The resource ID, as parsed during deployment, together with the version forms a
	// unique identifier for a specific form.
	ResourceId *string `json:"resourceId,omitempty"`

	// ResourceKey The assigned key, which acts as a unique identifier for this Resource.
	ResourceKey *ResourceKey `json:"resourceKey,omitempty"`

	// ResourceName The resource name from which this resource was parsed.
	ResourceName *string `json:"resourceName,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version The assigned resource version.
	Version *int32 `json:"version,omitempty"`
}

// DeploymentResult defines model for DeploymentResult.
type DeploymentResult struct {
	// DeploymentKey The unique key identifying the deployment.
	DeploymentKey DeploymentKey `json:"deploymentKey"`

	// Deployments Items deployed by the request.
	Deployments []DeploymentMetadataResult `json:"deployments"`

	// TenantId The tenant ID associated with the deployment.
	TenantId TenantId `json:"tenantId"`
}

// DocumentCreationBatchResponse defines model for DocumentCreationBatchResponse.
type DocumentCreationBatchResponse struct {
	// CreatedDocuments Documents that were successfully created.
	CreatedDocuments *[]DocumentReference `json:"createdDocuments,omitempty"`

	// FailedDocuments Documents that failed creation.
	FailedDocuments *[]DocumentCreationFailureDetail `json:"failedDocuments,omitempty"`
}

// DocumentCreationFailureDetail defines model for DocumentCreationFailureDetail.
type DocumentCreationFailureDetail struct {
	// Detail The detail of the failure.
	Detail *string `json:"detail,omitempty"`

	// FileName The name of the file.
	FileName *string `json:"fileName,omitempty"`
}

// DocumentId Document Id that uniquely identifies a document.
type DocumentId = string

// DocumentLink defines model for DocumentLink.
type DocumentLink struct {
	// ExpiresAt The date and time when the link expires.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// Url The link to the document.
	Url *string `json:"url,omitempty"`
}

// DocumentLinkRequest defines model for DocumentLinkRequest.
type DocumentLinkRequest struct {
	// TimeToLive The time-to-live of the document link in ms.
	TimeToLive *int64 `json:"timeToLive,omitempty"`
}

// DocumentMetadata Information about the document.
type DocumentMetadata struct {
	// ContentType The content type of the document.
	ContentType *string `json:"contentType,omitempty"`

	// CustomProperties Custom properties of the document.
	CustomProperties *map[string]interface{} `json:"customProperties,omitempty"`

	// ExpiresAt The date and time when the document expires.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// FileName The name of the file.
	FileName *string `json:"fileName,omitempty"`

	// ProcessDefinitionId The ID of the process definition that created the document.
	ProcessDefinitionId *ProcessDefinitionId `json:"processDefinitionId,omitempty"`

	// ProcessInstanceKey The key of the process instance that created the document.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// Size The size of the document in bytes.
	Size *int64 `json:"size,omitempty"`
}

// DocumentReference defines model for DocumentReference.
type DocumentReference struct {
	// CamundaDocumentType Document discriminator. Always set to "camunda".
	CamundaDocumentType *DocumentReferenceCamundaDocumentType `json:"camunda.document.type,omitempty"`

	// ContentHash The hash of the document.
	ContentHash *string `json:"contentHash,omitempty"`

	// DocumentId The ID of the document.
	DocumentId *DocumentId `json:"documentId,omitempty"`

	// Metadata Information about the document.
	Metadata *DocumentMetadata `json:"metadata,omitempty"`

	// StoreId The ID of the document store.
	StoreId *string `json:"storeId,omitempty"`
}

// DocumentReferenceCamundaDocumentType Document discriminator. Always set to "camunda".
type DocumentReferenceCamundaDocumentType string

// ElementId The model-defined id of an element.
type ElementId = string

// ElementInstanceFilter Element instance filter.
type ElementInstanceFilter struct {
	// ElementId The element ID for this element instance.
	ElementId *ElementId `json:"elementId,omitempty"`

	// ElementInstanceKey The assigned key, which acts as a unique identifier for this element instance.
	ElementInstanceKey *ElementInstanceKey `json:"elementInstanceKey,omitempty"`

	// ElementInstanceScopeKey The scope key of this element instance. If provided with a process instance key it will return element instances that are immediate children of the process instance. If provided with an element instance key it will return element instances that are immediate children of the element instance.
	ElementInstanceScopeKey *string `json:"elementInstanceScopeKey,omitempty"`

	// ElementName The element name. This only works for data created with 8.8 and onwards. Instances from prior versions don't contain this data and cannot be found.
	ElementName *string `json:"elementName,omitempty"`

	// EndDate The end date of this element instance.
	EndDate *DateTimeFilterProperty `json:"endDate,omitempty"`

	// HasIncident Shows whether this element instance has an incident related to.
	HasIncident *bool `json:"hasIncident,omitempty"`

	// IncidentKey The key of incident if field incident is true.
	IncidentKey *IncidentKey `json:"incidentKey,omitempty"`

	// ProcessDefinitionId The process definition ID associated to this element instance.
	ProcessDefinitionId *ProcessDefinitionId `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The process definition key associated to this element instance.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey The process instance key associated to this element instance.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// StartDate The start date of this element instance.
	StartDate *DateTimeFilterProperty `json:"startDate,omitempty"`

	// State State of element instance as defined set of values.
	State *ElementInstanceStateFilterProperty `json:"state,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Type Type of element as defined set of values.
	Type *ElementInstanceFilterType `json:"type,omitempty"`
}

// ElementInstanceFilterType Type of element as defined set of values.
type ElementInstanceFilterType string

// ElementInstanceKey Zeebe Engine resource key (Java long serialized as string)
type ElementInstanceKey = LongKey

// ElementInstanceKeyFilterProperty ElementInstanceKey property with full advanced search capabilities.
type ElementInstanceKeyFilterProperty struct {
	union json.RawMessage
}

// ElementInstanceKeyFilterProperty0 System-generated key for a element instance.
type ElementInstanceKeyFilterProperty0 = ElementInstanceKey

// ElementInstanceResult defines model for ElementInstanceResult.
type ElementInstanceResult struct {
	// ElementId The element ID for this element instance.
	ElementId ElementId `json:"elementId"`

	// ElementInstanceKey The assigned key, which acts as a unique identifier for this element instance.
	ElementInstanceKey ElementInstanceKey `json:"elementInstanceKey"`

	// ElementName The element name for this element instance.
	ElementName string `json:"elementName"`

	// EndDate Date when element instance finished.
	EndDate *time.Time `json:"endDate,omitempty"`

	// HasIncident Shows whether this element instance has an incident. If true also an incidentKey is provided.
	HasIncident bool `json:"hasIncident"`

	// IncidentKey Incident key associated with this element instance.
	IncidentKey *IncidentKey `json:"incidentKey,omitempty"`

	// ProcessDefinitionId The process definition ID associated to this element instance.
	ProcessDefinitionId ProcessDefinitionId `json:"processDefinitionId"`

	// ProcessDefinitionKey The process definition key associated to this element instance.
	ProcessDefinitionKey ProcessDefinitionKey `json:"processDefinitionKey"`

	// ProcessInstanceKey The process instance key associated to this element instance.
	ProcessInstanceKey ProcessInstanceKey `json:"processInstanceKey"`

	// StartDate Date when element instance started.
	StartDate time.Time `json:"startDate"`

	// State State of element instance as defined set of values.
	State ElementInstanceStateEnum `json:"state"`

	// TenantId The tenant ID of the incident.
	TenantId TenantId `json:"tenantId"`

	// Type Type of element as defined set of values.
	Type ElementInstanceResultType `json:"type"`
}

// ElementInstanceResultType Type of element as defined set of values.
type ElementInstanceResultType string

// ElementInstanceSearchQuery defines model for ElementInstanceSearchQuery.
type ElementInstanceSearchQuery struct {
	// Filter Element instance filter.
	Filter *ElementInstanceFilter `json:"filter,omitempty"`

	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]ElementInstanceSearchQuerySortRequest `json:"sort,omitempty"`
}

// ElementInstanceSearchQueryResult defines model for ElementInstanceSearchQueryResult.
type ElementInstanceSearchQueryResult struct {
	// Items The matching element instances.
	Items *[]ElementInstanceResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// ElementInstanceSearchQuerySortRequest defines model for ElementInstanceSearchQuerySortRequest.
type ElementInstanceSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field ElementInstanceSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// ElementInstanceSearchQuerySortRequestField The field to sort by.
type ElementInstanceSearchQuerySortRequestField string

// ElementInstanceStateEnum Element states
type ElementInstanceStateEnum string

// ElementInstanceStateFilterProperty ElementInstanceStateEnum property with full advanced search capabilities.
type ElementInstanceStateFilterProperty struct {
	union json.RawMessage
}

// ElementInstanceStateFilterProperty0 Element states
type ElementInstanceStateFilterProperty0 = ElementInstanceStateEnum

// EndCursor The end cursor in a search query result set.
type EndCursor = string

// EvaluateDecisionResult defines model for EvaluateDecisionResult.
type EvaluateDecisionResult struct {
	// DecisionDefinitionId The ID of the decision which was evaluated.
	DecisionDefinitionId DecisionDefinitionId `json:"decisionDefinitionId"`

	// DecisionDefinitionKey The unique key identifying the decision which was evaluated.
	DecisionDefinitionKey DecisionDefinitionKey `json:"decisionDefinitionKey"`

	// DecisionDefinitionName The name of the decision which was evaluated.
	DecisionDefinitionName string `json:"decisionDefinitionName"`

	// DecisionDefinitionVersion The version of the decision which was evaluated.
	DecisionDefinitionVersion int32 `json:"decisionDefinitionVersion"`

	// DecisionEvaluationKey The unique key identifying this decision evaluation.
	DecisionEvaluationKey DecisionEvaluationKey `json:"decisionEvaluationKey"`

	// DecisionInstanceKey Deprecated, please refer to `decisionEvaluationKey`.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	DecisionInstanceKey *DecisionInstanceKey `json:"decisionInstanceKey,omitempty"`

	// DecisionRequirementsId The ID of the decision requirements graph that the decision which was evaluated is part of.
	DecisionRequirementsId string `json:"decisionRequirementsId"`

	// DecisionRequirementsKey The unique key identifying the decision requirements graph that the decision which was evaluated is part of.
	DecisionRequirementsKey DecisionRequirementsKey `json:"decisionRequirementsKey"`

	// EvaluatedDecisions Decisions that were evaluated within the requested decision evaluation.
	EvaluatedDecisions []EvaluatedDecisionResult `json:"evaluatedDecisions"`

	// FailedDecisionDefinitionId The ID of the decision which failed during evaluation.
	FailedDecisionDefinitionId DecisionDefinitionId `json:"failedDecisionDefinitionId"`

	// FailureMessage Message describing why the decision which was evaluated failed.
	FailureMessage string `json:"failureMessage"`

	// Output JSON document that will instantiate the result of the decision which was evaluated.
	Output string `json:"output"`

	// TenantId The tenant ID of the evaluated decision.
	TenantId TenantId `json:"tenantId"`
}

// EvaluatedDecisionInputItem A decision input that was evaluated within this decision evaluation.
type EvaluatedDecisionInputItem struct {
	// InputId The ID of the evaluated decision input.
	InputId *string `json:"inputId,omitempty"`

	// InputName The name of the evaluated decision input.
	InputName *string `json:"inputName,omitempty"`

	// InputValue The value of the evaluated decision input.
	InputValue *string `json:"inputValue,omitempty"`
}

// EvaluatedDecisionOutputItem The evaluated decision outputs.
type EvaluatedDecisionOutputItem struct {
	// OutputId The ID of the evaluated decision output.
	OutputId *string `json:"outputId,omitempty"`

	// OutputName The name of the evaluated decision output.
	OutputName *string `json:"outputName,omitempty"`

	// OutputValue The value of the evaluated decision output.
	OutputValue *string `json:"outputValue,omitempty"`
}

// EvaluatedDecisionResult A decision that was evaluated.
type EvaluatedDecisionResult struct {
	// DecisionDefinitionId The ID of the decision which was evaluated.
	DecisionDefinitionId *DecisionDefinitionId `json:"decisionDefinitionId,omitempty"`

	// DecisionDefinitionKey The unique key identifying the decision which was evaluate.
	DecisionDefinitionKey *DecisionDefinitionKey `json:"decisionDefinitionKey,omitempty"`

	// DecisionDefinitionName The name of the decision which was evaluated.
	DecisionDefinitionName *string `json:"decisionDefinitionName,omitempty"`

	// DecisionDefinitionType The type of the decision which was evaluated.
	DecisionDefinitionType *string `json:"decisionDefinitionType,omitempty"`

	// DecisionDefinitionVersion The version of the decision which was evaluated.
	DecisionDefinitionVersion *int32 `json:"decisionDefinitionVersion,omitempty"`

	// DecisionEvaluationInstanceKey The unique key identifying this decision evaluation instance.
	DecisionEvaluationInstanceKey *DecisionEvaluationInstanceKey `json:"decisionEvaluationInstanceKey,omitempty"`

	// EvaluatedInputs The decision inputs that were evaluated within this decision evaluation.
	EvaluatedInputs *[]EvaluatedDecisionInputItem `json:"evaluatedInputs,omitempty"`

	// MatchedRules The decision rules that matched within this decision evaluation.
	MatchedRules *[]MatchedDecisionRuleItem `json:"matchedRules,omitempty"`

	// Output JSON document that will instantiate the result of the decision which was evaluated.
	Output *string `json:"output,omitempty"`

	// TenantId The tenant ID of the evaluated decision.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// FormId The user-defined id for the form
type FormId = string

// FormKey Zeebe Engine resource key (Java long serialized as string)
type FormKey = LongKey

// FormResult defines model for FormResult.
type FormResult struct {
	// FormId The user-provided identifier of the form.
	FormId *FormId `json:"formId,omitempty"`

	// FormKey The assigned key, which acts as a unique identifier for this form.
	FormKey *FormKey `json:"formKey,omitempty"`

	// Schema The form content.
	Schema *map[string]interface{} `json:"schema,omitempty"`

	// TenantId The tenant ID of the form.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version The version of the the deployed form.
	Version *int64 `json:"version,omitempty"`
}

// GroupClientResult defines model for GroupClientResult.
type GroupClientResult struct {
	// ClientId The ID of the client.
	ClientId *string `json:"clientId,omitempty"`
}

// GroupClientSearchQueryRequest defines model for GroupClientSearchQueryRequest.
type GroupClientSearchQueryRequest struct {
	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]GroupClientSearchQuerySortRequest `json:"sort,omitempty"`
}

// GroupClientSearchQuerySortRequest defines model for GroupClientSearchQuerySortRequest.
type GroupClientSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field GroupClientSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// GroupClientSearchQuerySortRequestField The field to sort by.
type GroupClientSearchQuerySortRequestField string

// GroupClientSearchResult defines model for GroupClientSearchResult.
type GroupClientSearchResult struct {
	// Items The matching client IDs.
	Items *[]GroupClientResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// GroupCreateRequest defines model for GroupCreateRequest.
type GroupCreateRequest struct {
	// Description The description of the new group.
	Description *string `json:"description,omitempty"`

	// GroupId The ID of the new group.
	GroupId string `json:"groupId"`

	// Name The display name of the new group.
	Name string `json:"name"`
}

// GroupCreateResult defines model for GroupCreateResult.
type GroupCreateResult struct {
	// Description The description of the created group.
	Description *string `json:"description,omitempty"`

	// GroupId The ID of the created group.
	GroupId *string `json:"groupId,omitempty"`

	// Name The display name of the created group.
	Name *string `json:"name,omitempty"`
}

// GroupFilter Group filter request
type GroupFilter struct {
	// GroupId The group ID search filters.
	GroupId *StringFilterProperty `json:"groupId,omitempty"`

	// Name The group name search filters.
	Name *string `json:"name,omitempty"`
}

// GroupResult Group search response item.
type GroupResult struct {
	// Description The group description.
	Description *string `json:"description,omitempty"`

	// GroupId The group ID.
	GroupId *string `json:"groupId,omitempty"`

	// Name The group name.
	Name *string `json:"name,omitempty"`
}

// GroupSearchQueryRequest defines model for GroupSearchQueryRequest.
type GroupSearchQueryRequest struct {
	// Filter Group filter request
	Filter *GroupFilter `json:"filter,omitempty"`

	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]GroupSearchQuerySortRequest `json:"sort,omitempty"`
}

// GroupSearchQueryResult defines model for GroupSearchQueryResult.
type GroupSearchQueryResult struct {
	// Items The matching groups.
	Items *[]GroupResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// GroupSearchQuerySortRequest defines model for GroupSearchQuerySortRequest.
type GroupSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field GroupSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// GroupSearchQuerySortRequestField The field to sort by.
type GroupSearchQuerySortRequestField string

// GroupUpdateRequest defines model for GroupUpdateRequest.
type GroupUpdateRequest struct {
	// Description The new description of the group.
	Description string `json:"description"`

	// Name The new name of the group.
	Name string `json:"name"`
}

// GroupUpdateResult defines model for GroupUpdateResult.
type GroupUpdateResult struct {
	// Description The description of the group.
	Description *string `json:"description,omitempty"`

	// GroupId The unique external group ID.
	GroupId *string `json:"groupId,omitempty"`

	// Name The name of the group.
	Name *string `json:"name,omitempty"`
}

// GroupUserResult defines model for GroupUserResult.
type GroupUserResult struct {
	// Username The unique name of a user.
	Username *Username `json:"username,omitempty"`
}

// GroupUserSearchQueryRequest defines model for GroupUserSearchQueryRequest.
type GroupUserSearchQueryRequest struct {
	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]GroupUserSearchQuerySortRequest `json:"sort,omitempty"`
}

// GroupUserSearchQuerySortRequest defines model for GroupUserSearchQuerySortRequest.
type GroupUserSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field GroupUserSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// GroupUserSearchQuerySortRequestField The field to sort by.
type GroupUserSearchQuerySortRequestField string

// GroupUserSearchResult defines model for GroupUserSearchResult.
type GroupUserSearchResult struct {
	// Items The matching members.
	Items *[]GroupUserResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// IncidentFilter Incident search filter.
type IncidentFilter struct {
	// CreationTime Date of incident creation.
	CreationTime *time.Time `json:"creationTime,omitempty"`

	// ElementId The element ID associated to this incident.
	ElementId *ElementId `json:"elementId,omitempty"`

	// ElementInstanceKey The element instance key associated to this incident.
	ElementInstanceKey *ElementInstanceKey `json:"elementInstanceKey,omitempty"`

	// ErrorMessage Error message which describes the error in more detail.
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// ErrorType Incident error type with a defined set of values.
	ErrorType *IncidentFilterErrorType `json:"errorType,omitempty"`

	// IncidentKey The assigned key, which acts as a unique identifier for this incident.
	IncidentKey *IncidentKey `json:"incidentKey,omitempty"`

	// JobKey The job key, if exists, associated with this incident.
	JobKey *JobKey `json:"jobKey,omitempty"`

	// ProcessDefinitionId The process definition ID associated to this incident.
	ProcessDefinitionId *ProcessDefinitionId `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The process definition key associated to this incident.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey The process instance key associated to this incident.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// State State of this incident with a defined set of values.
	State *IncidentFilterState `json:"state,omitempty"`

	// TenantId The tenant ID of the incident.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// IncidentFilterErrorType Incident error type with a defined set of values.
type IncidentFilterErrorType string

// IncidentFilterState State of this incident with a defined set of values.
type IncidentFilterState string

// IncidentKey Zeebe Engine resource key (Java long serialized as string)
type IncidentKey = LongKey

// IncidentResolutionRequest defines model for IncidentResolutionRequest.
type IncidentResolutionRequest struct {
	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
	// Must be > 0 if provided.
	OperationReference *OperationReference `json:"operationReference,omitempty"`
}

// IncidentResult defines model for IncidentResult.
type IncidentResult struct {
	// CreationTime Date of incident creation.
	CreationTime *time.Time `json:"creationTime,omitempty"`

	// ElementId The element ID associated to this incident.
	ElementId *ElementId `json:"elementId,omitempty"`

	// ElementInstanceKey The element instance key associated to this incident.
	ElementInstanceKey *ElementInstanceKey `json:"elementInstanceKey,omitempty"`

	// ErrorMessage Error message which describes the error in more detail.
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// ErrorType Incident error type with a defined set of values.
	ErrorType *IncidentResultErrorType `json:"errorType,omitempty"`

	// IncidentKey The assigned key, which acts as a unique identifier for this incident.
	IncidentKey *IncidentKey `json:"incidentKey,omitempty"`

	// JobKey The job key, if exists, associated with this incident.
	JobKey *JobKey `json:"jobKey,omitempty"`

	// ProcessDefinitionId The process definition ID associated to this incident.
	ProcessDefinitionId *ProcessDefinitionId `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The process definition key associated to this incident.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey The process instance key associated to this incident.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// State State of this incident with a defined set of values.
	State *IncidentResultState `json:"state,omitempty"`

	// TenantId The tenant ID of the incident.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// IncidentResultErrorType Incident error type with a defined set of values.
type IncidentResultErrorType string

// IncidentResultState State of this incident with a defined set of values.
type IncidentResultState string

// IncidentSearchQuery defines model for IncidentSearchQuery.
type IncidentSearchQuery struct {
	// Filter Incident search filter.
	Filter *IncidentFilter `json:"filter,omitempty"`

	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]IncidentSearchQuerySortRequest `json:"sort,omitempty"`
}

// IncidentSearchQueryResult defines model for IncidentSearchQueryResult.
type IncidentSearchQueryResult struct {
	// Items The matching incidents.
	Items *[]IncidentResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// IncidentSearchQuerySortRequest defines model for IncidentSearchQuerySortRequest.
type IncidentSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field IncidentSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// IncidentSearchQuerySortRequestField The field to sort by.
type IncidentSearchQuerySortRequestField string

// IntegerFilterProperty Integer property with advanced search capabilities.
type IntegerFilterProperty struct {
	union json.RawMessage
}

// IntegerFilterProperty0 Matches the value exactly.
type IntegerFilterProperty0 = int32

// JobActivationRequest defines model for JobActivationRequest.
type JobActivationRequest struct {
	// FetchVariable A list of variables to fetch as the job variables; if empty, all visible variables at the time of activation for the scope of the job will be returned.
	FetchVariable *[]string `json:"fetchVariable,omitempty"`

	// MaxJobsToActivate The maximum jobs to activate by this request.
	MaxJobsToActivate int32 `json:"maxJobsToActivate"`

	// RequestTimeout The request will be completed when at least one job is activated or after the requestTimeout (in ms). If the requestTimeout = 0, a default timeout is used. If the requestTimeout < 0, long polling is disabled and the request is completed immediately, even when no job is activated.
	RequestTimeout *int64 `json:"requestTimeout,omitempty"`

	// TenantIds A list of IDs of tenants for which to activate jobs.
	TenantIds *[]TenantId `json:"tenantIds,omitempty"`

	// Timeout A job returned after this call will not be activated by another call until the timeout (in ms) has been reached.
	Timeout int64 `json:"timeout"`

	// Type The job type, as defined in the BPMN process (e.g. <zeebe:taskDefinition type="payment-service" />).
	Type string `json:"type"`

	// Worker The name of the worker activating the jobs, mostly used for logging purposes.
	Worker *string `json:"worker,omitempty"`
}

// JobActivationResult The list of activated jobs
type JobActivationResult struct {
	// Jobs The activated jobs.
	Jobs []ActivatedJobResult `json:"jobs"`
}

// JobChangeset JSON object with changed job attribute values.
//
// The following attributes can be adjusted with this endpoint, additional attributes
// will be ignored:
//
// * `retries` - The new amount of retries for the job; must be a positive number.
// * `timeout` - The duration of the new timeout in ms, starting from the current moment.
//
// Providing any of those attributes with a null value or omitting it preserves the persisted attributeâ€™s value.
//
// The job cannot be completed or failed with this endpoint, use the complete job or fail job endpoints instead.
type JobChangeset struct {
	// Retries The new amount of retries for the job; must be a positive number.
	Retries *int32 `json:"retries"`

	// Timeout The duration of the new timeout in ms, starting from the current moment.
	Timeout *int64 `json:"timeout"`
}

// JobCompletionRequest defines model for JobCompletionRequest.
type JobCompletionRequest struct {
	// Result The result of the completed job as determined by the worker.
	Result *JobResult `json:"result,omitempty"`

	// Variables The variables to complete the job with.
	Variables *map[string]interface{} `json:"variables"`
}

// JobErrorRequest defines model for JobErrorRequest.
type JobErrorRequest struct {
	// ErrorCode The error code that will be matched with an error catch event.
	ErrorCode string `json:"errorCode"`

	// ErrorMessage An error message that provides additional context.
	ErrorMessage *string `json:"errorMessage"`

	// Variables JSON object that will instantiate the variables at the local scope of the error catch event that catches the thrown error.
	Variables *map[string]interface{} `json:"variables"`
}

// JobFailRequest defines model for JobFailRequest.
type JobFailRequest struct {
	// ErrorMessage An optional message describing why the job failed. This is particularly useful if a job runs out of retries and an incident is raised, as this message can help explain why an incident was raised.
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Retries The amount of retries the job should have left
	Retries *int32 `json:"retries,omitempty"`

	// RetryBackOff The backoff timeout (in ms) for the next retry.
	RetryBackOff *int64 `json:"retryBackOff,omitempty"`

	// Variables JSON object that will instantiate the variables at the local scope of the job's associated task.
	Variables *map[string]interface{} `json:"variables,omitempty"`
}

// JobFilter Job search filter.
type JobFilter struct {
	// Deadline When the job can next be activated.
	Deadline *DateTimeFilterProperty `json:"deadline"`

	// DeniedReason The reason provided by the user task listener for denying the work.
	DeniedReason *StringFilterProperty `json:"deniedReason,omitempty"`

	// ElementId The element ID associated with the job.
	ElementId *StringFilterProperty `json:"elementId,omitempty"`

	// ElementInstanceKey The element instance key associated with the job.
	ElementInstanceKey *ElementInstanceKeyFilterProperty `json:"elementInstanceKey,omitempty"`

	// EndTime When the job ended.
	EndTime *DateTimeFilterProperty `json:"endTime,omitempty"`

	// ErrorCode The error code provided for the failed job.
	ErrorCode *StringFilterProperty `json:"errorCode,omitempty"`

	// ErrorMessage The error message that provides additional context for a failed job.
	ErrorMessage *StringFilterProperty `json:"errorMessage,omitempty"`

	// HasFailedWithRetriesLeft Indicates whether the job has failed with retries left.
	HasFailedWithRetriesLeft *bool `json:"hasFailedWithRetriesLeft,omitempty"`

	// IsDenied Indicates whether the user task listener denies the work.
	IsDenied *bool `json:"isDenied"`

	// JobKey The key, a unique identifier for the job.
	JobKey *JobKeyFilterProperty `json:"jobKey,omitempty"`

	// Kind The kind of the job.
	Kind *JobKindFilterProperty `json:"kind,omitempty"`

	// ListenerEventType The listener event type of the job.
	ListenerEventType *JobListenerEventTypeFilterProperty `json:"listenerEventType,omitempty"`

	// ProcessDefinitionId The process definition ID associated with the job.
	ProcessDefinitionId *StringFilterProperty `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The process definition key associated with the job.
	ProcessDefinitionKey *ProcessDefinitionKeyFilterProperty `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey The process instance key associated with the job.
	ProcessInstanceKey *ProcessInstanceKeyFilterProperty `json:"processInstanceKey,omitempty"`

	// Retries The number of retries left.
	Retries *IntegerFilterProperty `json:"retries,omitempty"`

	// State The state of the job.
	State *JobStateFilterProperty `json:"state,omitempty"`

	// TenantId The tenant ID.
	TenantId *StringFilterProperty `json:"tenantId,omitempty"`

	// Type The type of the job.
	Type *StringFilterProperty `json:"type,omitempty"`

	// Worker The name of the worker for this job.
	Worker *StringFilterProperty `json:"worker,omitempty"`
}

// JobKey Zeebe Engine resource key (Java long serialized as string)
type JobKey = LongKey

// JobKeyFilterProperty JobKey property with full advanced search capabilities.
type JobKeyFilterProperty struct {
	union json.RawMessage
}

// JobKeyFilterProperty0 System-generated key for a job.
type JobKeyFilterProperty0 = JobKey

// JobKindEnum The job kind.
type JobKindEnum string

// JobKindFilterProperty JobKindEnum property with full advanced search capabilities.
type JobKindFilterProperty struct {
	union json.RawMessage
}

// JobKindFilterProperty0 The job kind.
type JobKindFilterProperty0 = JobKindEnum

// JobListenerEventTypeEnum The listener event type of the job.
type JobListenerEventTypeEnum string

// JobListenerEventTypeFilterProperty JobListenerEventTypeEnum property with full advanced search capabilities.
type JobListenerEventTypeFilterProperty struct {
	union json.RawMessage
}

// JobListenerEventTypeFilterProperty0 The listener event type of the job.
type JobListenerEventTypeFilterProperty0 = JobListenerEventTypeEnum

// JobResult The result of the completed job as determined by the worker.
type JobResult struct {
	// Type Used to distinguish between different types of job results.
	Type  JobResultType `json:"type"`
	union json.RawMessage
}

// JobResultType Used to distinguish between different types of job results.
type JobResultType string

// JobResultActivateElement defines model for JobResultActivateElement.
type JobResultActivateElement struct {
	// ElementId The ID of the element to activate.
	ElementId *ElementId `json:"elementId,omitempty"`

	// Variables JSON document that will create the variables on the scope of the activated element.
	// It must be a JSON object, as variables will be mapped in a key-value fashion.
	Variables *map[string]interface{} `json:"variables"`
}

// JobResultAdHocSubProcess defines model for JobResultAdHocSubProcess.
type JobResultAdHocSubProcess struct {
	// ActivateElements Indicates which elements need to be activated in the ad-hoc subprocess.
	ActivateElements *[]JobResultActivateElement `json:"activateElements,omitempty"`

	// IsCancelRemainingInstances Indicates whether the remaining instances of the ad-hoc subprocess should be canceled.
	IsCancelRemainingInstances *bool `json:"isCancelRemainingInstances,omitempty"`

	// IsCompletionConditionFulfilled Indicates whether the completion condition of the ad-hoc subprocess is fulfilled.
	IsCompletionConditionFulfilled *bool `json:"isCompletionConditionFulfilled,omitempty"`
}

// JobResultCorrections JSON object with attributes that were corrected by the worker.
//
// The following attributes can be corrected, additional attributes will be ignored:
//
// * `assignee` - clear by providing an empty String
// * `dueDate` - clear by providing an empty String
// * `followUpDate` - clear by providing an empty String
// * `candidateGroups` - clear by providing an empty list
// * `candidateUsers` - clear by providing an empty list
// * `priority` - minimum 0, maximum 100, default 50
//
// Providing any of those attributes with a `null` value or omitting it preserves
// the persisted attribute's value.
type JobResultCorrections struct {
	// Assignee Assignee of the task.
	Assignee *string `json:"assignee"`

	// CandidateGroups The list of candidate groups of the task.
	CandidateGroups *[]string `json:"candidateGroups"`

	// CandidateUsers The list of candidate users of the task.
	CandidateUsers *[]string `json:"candidateUsers"`

	// DueDate The due date of the task.
	DueDate *time.Time `json:"dueDate"`

	// FollowUpDate The follow-up date of the task.
	FollowUpDate *time.Time `json:"followUpDate"`

	// Priority The priority of the task.
	Priority *int32 `json:"priority"`
}

// JobResultUserTask defines model for JobResultUserTask.
type JobResultUserTask struct {
	// Corrections JSON object with attributes that were corrected by the worker.
	//
	// The following attributes can be corrected, additional attributes will be ignored:
	//
	// * `assignee` - clear by providing an empty String
	// * `dueDate` - clear by providing an empty String
	// * `followUpDate` - clear by providing an empty String
	// * `candidateGroups` - clear by providing an empty list
	// * `candidateUsers` - clear by providing an empty list
	// * `priority` - minimum 0, maximum 100, default 50
	//
	// Providing any of those attributes with a `null` value or omitting it preserves
	// the persisted attribute's value.
	Corrections *JobResultCorrections `json:"corrections"`

	// Denied Indicates whether the worker denies the work, i.e. explicitly doesn't approve it. For example, a user task listener can deny the completion of a task by setting this flag to true. In this example, the completion of a task is represented by a job that the worker can complete as denied. As a result, the completion request is rejected and the task remains active. Defaults to false.
	Denied *bool `json:"denied"`

	// DeniedReason The reason provided by the user task listener for denying the work.
	DeniedReason *string `json:"deniedReason"`
}

// JobSearchQuery defines model for JobSearchQuery.
type JobSearchQuery struct {
	// Filter Job search filter.
	Filter *JobFilter `json:"filter,omitempty"`

	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]JobSearchQuerySortRequest `json:"sort,omitempty"`
}

// JobSearchQueryResult defines model for JobSearchQueryResult.
type JobSearchQueryResult struct {
	// Items The matching jobs.
	Items *[]JobSearchResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// JobSearchQuerySortRequest defines model for JobSearchQuerySortRequest.
type JobSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field JobSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// JobSearchQuerySortRequestField The field to sort by.
type JobSearchQuerySortRequestField string

// JobSearchResult defines model for JobSearchResult.
type JobSearchResult struct {
	// CustomHeaders A set of custom headers defined during modelling.
	CustomHeaders map[string]string `json:"customHeaders"`

	// Deadline If the job has been activated, when it will next be available to be activated.
	Deadline *time.Time `json:"deadline"`

	// DeniedReason The reason provided by the user task listener for denying the work.
	DeniedReason *string `json:"deniedReason"`

	// ElementId The element ID associated with the job.
	ElementId ElementId `json:"elementId"`

	// ElementInstanceKey The element instance key associated with the job.
	ElementInstanceKey ElementInstanceKey `json:"elementInstanceKey"`

	// EndTime When the job ended.
	EndTime *time.Time `json:"endTime,omitempty"`

	// ErrorCode The error code provided for a failed job.
	ErrorCode *string `json:"errorCode"`

	// ErrorMessage The error message that provides additional context for a failed job.
	ErrorMessage *string `json:"errorMessage"`

	// HasFailedWithRetriesLeft Indicates whether the job has failed with retries left.
	HasFailedWithRetriesLeft bool `json:"hasFailedWithRetriesLeft"`

	// IsDenied Indicates whether the user task listener denies the work.
	IsDenied *bool `json:"isDenied"`

	// JobKey The key, a unique identifier for the job.
	JobKey JobKey `json:"jobKey"`

	// Kind The job kind.
	Kind JobKindEnum `json:"kind"`

	// ListenerEventType The listener event type of the job.
	ListenerEventType JobListenerEventTypeEnum `json:"listenerEventType"`

	// ProcessDefinitionId The process definition ID associated with the job.
	ProcessDefinitionId ProcessDefinitionId `json:"processDefinitionId"`

	// ProcessDefinitionKey The process definition key associated with the job.
	ProcessDefinitionKey ProcessDefinitionKey `json:"processDefinitionKey"`

	// ProcessInstanceKey The process instance key associated with the job.
	ProcessInstanceKey ProcessInstanceKey `json:"processInstanceKey"`

	// Retries The amount of retries left to this job.
	Retries int32 `json:"retries"`

	// State The state of the job.
	State JobStateEnum `json:"state"`

	// TenantId The unique identifier of the tenant.
	TenantId TenantId `json:"tenantId"`

	// Type The type of the job.
	Type string `json:"type"`

	// Worker The name of the worker of this job.
	Worker string `json:"worker"`
}

// JobStateEnum The state of the job.
type JobStateEnum string

// JobStateFilterProperty JobStateEnum property with full advanced search capabilities.
type JobStateFilterProperty struct {
	union json.RawMessage
}

// JobStateFilterProperty0 The state of the job.
type JobStateFilterProperty0 = JobStateEnum

// JobUpdateRequest defines model for JobUpdateRequest.
type JobUpdateRequest struct {
	// Changeset JSON object with changed job attribute values.
	//
	// The following attributes can be adjusted with this endpoint, additional attributes
	// will be ignored:
	//
	// * `retries` - The new amount of retries for the job; must be a positive number.
	// * `timeout` - The duration of the new timeout in ms, starting from the current moment.
	//
	// Providing any of those attributes with a null value or omitting it preserves the persisted attributeâ€™s value.
	//
	// The job cannot be completed or failed with this endpoint, use the complete job or fail job endpoints instead.
	Changeset JobChangeset `json:"changeset"`

	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
	// Must be > 0 if provided.
	OperationReference *OperationReference `json:"operationReference,omitempty"`
}

// LicenseResponse The response of a license request.
type LicenseResponse struct {
	// ExpiresAt The date when the Camunda license expires
	ExpiresAt *time.Time `json:"expiresAt"`

	// IsCommercial Will be false when a license contains a non-commerical=true property
	IsCommercial bool `json:"isCommercial"`

	// LicenseType Will return the license type property of the Camunda license
	LicenseType string `json:"licenseType"`

	// ValidLicense True if the Camunda license is valid, false if otherwise
	ValidLicense bool `json:"validLicense"`
}

// LikeFilter Checks if the property matches the provided like value.
//
// Supported wildcard characters are:
//
// * `*`: matches zero, one, or multiple characters.
// * `?`: matches one, single character.
//
// Wildcard characters can be escaped with backslash, for instance: `\*`.
type LikeFilter = string

// LongKey Zeebe Engine resource key (Java long serialized as string)
type LongKey = string

// MappingRuleCreateRequest defines model for MappingRuleCreateRequest.
type MappingRuleCreateRequest = MappingRuleCreateUpdateRequest

// MappingRuleCreateResult defines model for MappingRuleCreateResult.
type MappingRuleCreateResult = MappingRuleCreateUpdateResult

// MappingRuleCreateUpdateRequest defines model for MappingRuleCreateUpdateRequest.
type MappingRuleCreateUpdateRequest struct {
	// ClaimName The name of the claim to map.
	ClaimName string `json:"claimName"`

	// ClaimValue The value of the claim to map.
	ClaimValue string `json:"claimValue"`

	// Name The name of the mapping rule.
	Name string `json:"name"`
}

// MappingRuleCreateUpdateResult defines model for MappingRuleCreateUpdateResult.
type MappingRuleCreateUpdateResult struct {
	// ClaimName The name of the claim to map.
	ClaimName *string `json:"claimName,omitempty"`

	// ClaimValue The value of the claim to map.
	ClaimValue *string `json:"claimValue,omitempty"`

	// MappingRuleId The unique ID of the mapping rule.
	MappingRuleId *string `json:"mappingRuleId,omitempty"`

	// Name The name of the mapping rule.
	Name *string `json:"name,omitempty"`
}

// MappingRuleFilter Mapping rule search filter.
type MappingRuleFilter struct {
	// ClaimName The claim name to match against a token.
	ClaimName *string `json:"claimName,omitempty"`

	// ClaimValue The value of the claim to match.
	ClaimValue *string `json:"claimValue,omitempty"`

	// MappingRuleId The ID of the mapping rule.
	MappingRuleId *string `json:"mappingRuleId,omitempty"`

	// Name The name of the mapping rule.
	Name *string `json:"name,omitempty"`
}

// MappingRuleResult defines model for MappingRuleResult.
type MappingRuleResult struct {
	// ClaimName The name of the claim to map.
	ClaimName *string `json:"claimName,omitempty"`

	// ClaimValue The value of the claim to map.
	ClaimValue *string `json:"claimValue,omitempty"`

	// MappingRuleId The ID of the mapping rule.
	MappingRuleId *string `json:"mappingRuleId,omitempty"`

	// Name The name of the mapping rule.
	Name *string `json:"name,omitempty"`
}

// MappingRuleSearchQueryRequest defines model for MappingRuleSearchQueryRequest.
type MappingRuleSearchQueryRequest struct {
	// Filter Mapping rule search filter.
	Filter *MappingRuleFilter `json:"filter,omitempty"`

	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]MappingRuleSearchQuerySortRequest `json:"sort,omitempty"`
}

// MappingRuleSearchQueryResult defines model for MappingRuleSearchQueryResult.
type MappingRuleSearchQueryResult struct {
	// Items The matching mapping rules.
	Items *[]MappingRuleResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// MappingRuleSearchQuerySortRequest defines model for MappingRuleSearchQuerySortRequest.
type MappingRuleSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field MappingRuleSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// MappingRuleSearchQuerySortRequestField The field to sort by.
type MappingRuleSearchQuerySortRequestField string

// MappingRuleUpdateRequest defines model for MappingRuleUpdateRequest.
type MappingRuleUpdateRequest = MappingRuleCreateUpdateRequest

// MappingRuleUpdateResult defines model for MappingRuleUpdateResult.
type MappingRuleUpdateResult = MappingRuleCreateUpdateResult

// MatchedDecisionRuleItem A decision rule that matched within this decision evaluation.
type MatchedDecisionRuleItem struct {
	// EvaluatedOutputs The evaluated decision outputs.
	EvaluatedOutputs *[]EvaluatedDecisionOutputItem `json:"evaluatedOutputs,omitempty"`

	// RuleId The ID of the matched rule.
	RuleId *string `json:"ruleId,omitempty"`

	// RuleIndex The index of the matched rule.
	RuleIndex *int32 `json:"ruleIndex,omitempty"`
}

// MessageCorrelationKey Zeebe Engine resource key (Java long serialized as string)
type MessageCorrelationKey = LongKey

// MessageCorrelationRequest defines model for MessageCorrelationRequest.
type MessageCorrelationRequest struct {
	// CorrelationKey The correlation key of the message.
	CorrelationKey *string `json:"correlationKey,omitempty"`

	// Name The message name as defined in the BPMN process
	Name string `json:"name"`

	// TenantId the tenant for which the message is published
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Variables The message variables as JSON document
	Variables *map[string]interface{} `json:"variables,omitempty"`
}

// MessageCorrelationResult The message key of the correlated message, as well as the first process instance key it
// correlated with.
type MessageCorrelationResult struct {
	// MessageKey The key of the correlated message
	MessageKey *MessageCorrelationKey `json:"messageKey,omitempty"`

	// ProcessInstanceKey The key of the first process instance the message correlated with
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// TenantId The tenant ID of the correlated message
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// MessageKey Zeebe Engine resource key (Java long serialized as string)
type MessageKey = LongKey

// MessagePublicationRequest defines model for MessagePublicationRequest.
type MessagePublicationRequest struct {
	// CorrelationKey The correlation key of the message.
	CorrelationKey *string `json:"correlationKey,omitempty"`

	// MessageId The unique ID of the message. This is used to ensure only one message with the given ID
	// will be published during the lifetime of the message (if `timeToLive` is set).
	MessageId *string `json:"messageId,omitempty"`

	// Name The name of the message.
	Name string `json:"name"`

	// TenantId The tenant of the message sender.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// TimeToLive Timespan (in ms) to buffer the message on the broker.
	TimeToLive *int64 `json:"timeToLive,omitempty"`

	// Variables The message variables as JSON document.
	Variables *map[string]interface{} `json:"variables,omitempty"`
}

// MessagePublicationResult The message key of the published message.
type MessagePublicationResult struct {
	// MessageKey The key of the message
	MessageKey *MessageKey `json:"messageKey,omitempty"`

	// TenantId The tenant ID of the message.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// MessageSubscriptionFilter Message subscription search filter.
type MessageSubscriptionFilter struct {
	// CorrelationKey The correlation key of the message subscription.
	CorrelationKey *StringFilterProperty `json:"correlationKey,omitempty"`

	// ElementId The element ID associated with this message subscription.
	ElementId *StringFilterProperty `json:"elementId,omitempty"`

	// ElementInstanceKey The element instance key associated with this message subscription.
	ElementInstanceKey *ElementInstanceKeyFilterProperty `json:"elementInstanceKey,omitempty"`

	// LastUpdatedDate The last updated date of the message subscription.
	LastUpdatedDate *DateTimeFilterProperty `json:"lastUpdatedDate,omitempty"`

	// MessageName The name of the message associated with the message subscription.
	MessageName *StringFilterProperty `json:"messageName,omitempty"`

	// MessageSubscriptionKey The message subscription key associated with this message subscription.
	MessageSubscriptionKey *MessageSubscriptionKeyFilterProperty `json:"messageSubscriptionKey,omitempty"`

	// MessageSubscriptionState The message subscription state.
	MessageSubscriptionState *MessageSubscriptionStateFilterProperty `json:"messageSubscriptionState,omitempty"`

	// ProcessDefinitionId The process definition ID associated with this message subscription.
	ProcessDefinitionId *StringFilterProperty `json:"processDefinitionId,omitempty"`

	// ProcessInstanceKey The process instance key associated with this message subscription.
	ProcessInstanceKey *ProcessInstanceKeyFilterProperty `json:"processInstanceKey,omitempty"`

	// TenantId The unique external tenant ID.
	TenantId *StringFilterProperty `json:"tenantId,omitempty"`
}

// MessageSubscriptionKey Zeebe Engine resource key (Java long serialized as string)
type MessageSubscriptionKey = LongKey

// MessageSubscriptionKeyFilterProperty MessageSubscriptionKey property with full advanced search capabilities.
type MessageSubscriptionKeyFilterProperty struct {
	union json.RawMessage
}

// MessageSubscriptionKeyFilterProperty0 System-generated key for a message subscription.
type MessageSubscriptionKeyFilterProperty0 = MessageSubscriptionKey

// MessageSubscriptionResult defines model for MessageSubscriptionResult.
type MessageSubscriptionResult struct {
	// CorrelationKey The correlation key of the message subscription.
	CorrelationKey *MessageCorrelationKey `json:"correlationKey,omitempty"`

	// ElementId The element ID associated with this message subscription.
	ElementId *ElementId `json:"elementId,omitempty"`

	// ElementInstanceKey The element instance key associated with this message subscription.
	ElementInstanceKey *ElementInstanceKey `json:"elementInstanceKey,omitempty"`

	// LastUpdatedDate The last updated date of the message subscription.
	LastUpdatedDate *time.Time `json:"lastUpdatedDate,omitempty"`

	// MessageName The name of the message associated with the message subscription.
	MessageName *string `json:"messageName,omitempty"`

	// MessageSubscriptionKey The message subscription key associated with this message subscription.
	MessageSubscriptionKey *MessageSubscriptionKey `json:"messageSubscriptionKey,omitempty"`

	// MessageSubscriptionState The state of message subscription.
	MessageSubscriptionState *MessageSubscriptionStateEnum `json:"messageSubscriptionState,omitempty"`

	// ProcessDefinitionId The process definition ID associated with this message subscription.
	ProcessDefinitionId *ProcessDefinitionId `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The process definition key associated with this message subscription.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey The process instance key associated with this message subscription.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// MessageSubscriptionSearchQuery defines model for MessageSubscriptionSearchQuery.
type MessageSubscriptionSearchQuery struct {
	// Filter Message subscription search filter.
	Filter *MessageSubscriptionFilter `json:"filter,omitempty"`

	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]MessageSubscriptionSearchQuerySortRequest `json:"sort,omitempty"`
}

// MessageSubscriptionSearchQueryResult defines model for MessageSubscriptionSearchQueryResult.
type MessageSubscriptionSearchQueryResult struct {
	// Items The matching message subscriptions.
	Items *[]MessageSubscriptionResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// MessageSubscriptionSearchQuerySortRequest defines model for MessageSubscriptionSearchQuerySortRequest.
type MessageSubscriptionSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field MessageSubscriptionSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// MessageSubscriptionSearchQuerySortRequestField The field to sort by.
type MessageSubscriptionSearchQuerySortRequestField string

// MessageSubscriptionStateEnum The state of message subscription.
type MessageSubscriptionStateEnum string

// MessageSubscriptionStateFilterProperty MessageSubscriptionStateEnum with full advanced search capabilities.
type MessageSubscriptionStateFilterProperty struct {
	union json.RawMessage
}

// MessageSubscriptionStateFilterProperty0 The state of message subscription.
type MessageSubscriptionStateFilterProperty0 = MessageSubscriptionStateEnum

// MigrateProcessInstanceMappingInstruction The mapping instructions describe how to map elements from the source process definition to the target process definition.
type MigrateProcessInstanceMappingInstruction struct {
	// SourceElementId The element ID to migrate from.
	SourceElementId ElementId `json:"sourceElementId"`

	// TargetElementId The element ID to migrate into.
	TargetElementId ElementId `json:"targetElementId"`
}

// ModifyProcessInstanceVariableInstruction Instructions describing which variables should be created.
type ModifyProcessInstanceVariableInstruction struct {
	// ScopeId The ID of the element in which scope the variables should be created.
	// Leave empty to create the variables in the global scope of the process instance
	ScopeId *string `json:"scopeId,omitempty"`

	// Variables JSON document that will instantiate the variables for the root variable scope of the process instance.
	// It must be a JSON object, as variables will be mapped in a key-value fashion.
	Variables map[string]interface{} `json:"variables"`
}

// OffsetPagination defines model for OffsetPagination.
type OffsetPagination struct {
	// From The index of items to start searching from.
	From *int32 `json:"from,omitempty"`

	// Limit The maximum number of items to return in one request.
	Limit *int32 `json:"limit,omitempty"`
}

// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
// Must be > 0 if provided.
type OperationReference = int64

// OwnerTypeEnum The type of the owner of permissions.
type OwnerTypeEnum string

// Partition Provides information on a partition within a broker node.
type Partition struct {
	// Health Describes the current health of the partition.
	Health PartitionHealth `json:"health"`

	// PartitionId The unique ID of this partition.
	PartitionId int32 `json:"partitionId"`

	// Role Describes the Raft role of the broker for a given partition.
	Role PartitionRole `json:"role"`
}

// PartitionHealth Describes the current health of the partition.
type PartitionHealth string

// PartitionRole Describes the Raft role of the broker for a given partition.
type PartitionRole string

// PermissionTypeEnum Specifies the type of permissions.
type PermissionTypeEnum string

// ProblemDetail A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.
type ProblemDetail struct {
	// Detail An explanation of the problem in more detail.
	Detail *string `json:"detail,omitempty"`

	// Instance A URI path identifying the origin of the problem.
	Instance *string `json:"instance,omitempty"`

	// Status The HTTP status code for this problem.
	Status *int32 `json:"status,omitempty"`

	// Title A summary of the problem type.
	Title *string `json:"title,omitempty"`

	// Type A URI identifying the problem type.
	Type *string `json:"type,omitempty"`
}

// ProcessDefinitionElementStatisticsQuery Process definition element statistics request.
type ProcessDefinitionElementStatisticsQuery struct {
	// Filter The process definition statistics search filters.
	Filter *ProcessDefinitionStatisticsFilter `json:"filter,omitempty"`
}

// ProcessDefinitionElementStatisticsQueryResult Process definition element statistics query response.
type ProcessDefinitionElementStatisticsQueryResult struct {
	// Items The element statistics.
	Items *[]ProcessElementStatisticsResult `json:"items,omitempty"`
}

// ProcessDefinitionFilter Process definition search filter.
type ProcessDefinitionFilter struct {
	// HasStartForm Indicates whether the start event of the process has an associated Form Key.
	HasStartForm *bool `json:"hasStartForm,omitempty"`

	// IsLatestVersion Whether to only return the latest version of each process definition.
	// When using this filter, pagination functionality is limited, you can only paginate forward using `after` and `limit`.
	// The response contains no `startCursor` in the `page`, and requests ignore the `from` and `before` in the `page`.
	IsLatestVersion *bool `json:"isLatestVersion,omitempty"`

	// Name Name of this process definition.
	Name *StringFilterProperty `json:"name,omitempty"`

	// ProcessDefinitionId Process definition ID of this process definition.
	ProcessDefinitionId *StringFilterProperty `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The key for this process definition.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ResourceName Resource name of this process definition.
	ResourceName *string `json:"resourceName,omitempty"`

	// TenantId Tenant ID of this process definition.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version Version of this process definition.
	Version *int32 `json:"version,omitempty"`

	// VersionTag Version tag of this process definition.
	VersionTag *string `json:"versionTag,omitempty"`
}

// ProcessDefinitionId Id of a process definition, from the model. Only ids of process definitions that are deployed are useful.
type ProcessDefinitionId = string

// ProcessDefinitionKey Zeebe Engine resource key (Java long serialized as string)
type ProcessDefinitionKey = LongKey

// ProcessDefinitionKeyFilterProperty ProcessDefinitionKey property with full advanced search capabilities.
type ProcessDefinitionKeyFilterProperty struct {
	union json.RawMessage
}

// ProcessDefinitionKeyFilterProperty0 System-generated key for a deployed process definition.
type ProcessDefinitionKeyFilterProperty0 = ProcessDefinitionKey

// ProcessDefinitionResult defines model for ProcessDefinitionResult.
type ProcessDefinitionResult struct {
	// HasStartForm Indicates whether the start event of the process has an associated Form Key.
	HasStartForm *bool `json:"hasStartForm,omitempty"`

	// Name Name of this process definition.
	Name *string `json:"name,omitempty"`

	// ProcessDefinitionId Process definition ID of this process definition.
	ProcessDefinitionId *ProcessDefinitionId `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The key for this process definition.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ResourceName Resource name for this process definition.
	ResourceName *string `json:"resourceName,omitempty"`

	// TenantId Tenant ID of this process definition.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version Version of this process definition.
	Version *int32 `json:"version,omitempty"`

	// VersionTag Version tag of this process definition.
	VersionTag *string `json:"versionTag,omitempty"`
}

// ProcessDefinitionSearchQuery defines model for ProcessDefinitionSearchQuery.
type ProcessDefinitionSearchQuery struct {
	// Filter Process definition search filter.
	Filter *ProcessDefinitionFilter `json:"filter,omitempty"`

	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]ProcessDefinitionSearchQuerySortRequest `json:"sort,omitempty"`
}

// ProcessDefinitionSearchQueryResult defines model for ProcessDefinitionSearchQueryResult.
type ProcessDefinitionSearchQueryResult struct {
	// Items The matching process definitions.
	Items *[]ProcessDefinitionResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// ProcessDefinitionSearchQuerySortRequest defines model for ProcessDefinitionSearchQuerySortRequest.
type ProcessDefinitionSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field ProcessDefinitionSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// ProcessDefinitionSearchQuerySortRequestField The field to sort by.
type ProcessDefinitionSearchQuerySortRequestField string

// ProcessDefinitionStatisticsFilter defines model for ProcessDefinitionStatisticsFilter.
type ProcessDefinitionStatisticsFilter struct {
	// Or Defines a list of alternative filter groups combined using OR logic. Each object in the array is evaluated independently, and the filter matches if any one of them is satisfied.
	//
	// Top-level fields and the `$or` clause are combined using AND logic â€” meaning: (top-level filters) AND (any of the `$or` filters) must match.
	// <br>
	// <em>Example:</em>
	//
	// ```json
	// {
	//   "state": "ACTIVE",
	//   "tenantId": 123,
	//   "$or": [
	//     { "processDefinitionId": "process_v1" },
	//     { "processDefinitionId": "process_v2", "hasIncident": true }
	//   ]
	// }
	// ```
	// This matches process instances that:
	//
	// <ul style="padding-left: 20px; margin-left: 20px;">
	//   <li style="list-style-type: disc;">are in <em>ACTIVE</em> state</li>
	//   <li style="list-style-type: disc;">have tenant ID equal to <em>123</em></li>
	//   <li style="list-style-type: disc;">and match either:
	//     <ul style="padding-left: 20px; margin-left: 20px;">
	//       <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v1</em>, or</li>
	//       <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v2</em> and <code>hasIncident</code> is <em>true</em></li>
	//     </ul>
	//   </li>
	// </ul>
	// <br>
	// <p>Note: Using complex <code>$or</code> conditions may impact performance, use with caution in high-volume environments.
	Or *[]BaseProcessInstanceFilterFields `json:"$or,omitempty"`

	// BatchOperationId The batch operation ID.
	BatchOperationId *StringFilterProperty `json:"batchOperationId,omitempty"`

	// ElementId The element ID associated with the process instance.
	ElementId *StringFilterProperty `json:"elementId,omitempty"`

	// ElementInstanceState The state of the element instances associated with the process instance.
	ElementInstanceState *ElementInstanceStateFilterProperty `json:"elementInstanceState,omitempty"`

	// EndDate The end date.
	EndDate *DateTimeFilterProperty `json:"endDate,omitempty"`

	// ErrorMessage The error message related to the process.
	ErrorMessage *StringFilterProperty `json:"errorMessage,omitempty"`

	// HasElementInstanceIncident Whether the element instance has an incident or not.
	HasElementInstanceIncident *bool `json:"hasElementInstanceIncident,omitempty"`

	// HasIncident Whether this process instance has a related incident or not.
	HasIncident *bool `json:"hasIncident,omitempty"`

	// HasRetriesLeft Whether the process has failed jobs with retries left.
	HasRetriesLeft *bool `json:"hasRetriesLeft,omitempty"`

	// IncidentErrorHashCode The incident error hash code, associated with this process.
	IncidentErrorHashCode *IntegerFilterProperty `json:"incidentErrorHashCode,omitempty"`

	// ParentElementInstanceKey The parent element instance key.
	ParentElementInstanceKey *ElementInstanceKeyFilterProperty `json:"parentElementInstanceKey,omitempty"`

	// ParentProcessInstanceKey The parent process instance key.
	ParentProcessInstanceKey *ProcessInstanceKeyFilterProperty `json:"parentProcessInstanceKey,omitempty"`

	// ProcessInstanceKey The key of this process instance.
	ProcessInstanceKey *ProcessInstanceKeyFilterProperty `json:"processInstanceKey,omitempty"`

	// StartDate The start date.
	StartDate *DateTimeFilterProperty `json:"startDate,omitempty"`

	// State The process instance state.
	State *ProcessInstanceStateFilterProperty `json:"state,omitempty"`

	// Tags List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
	Tags *TagSet `json:"tags,omitempty"`

	// TenantId The tenant ID.
	TenantId *StringFilterProperty `json:"tenantId,omitempty"`

	// Variables The process instance variables.
	Variables *[]VariableValueFilterProperty `json:"variables,omitempty"`
}

// ProcessElementStatisticsResult Process element statistics response.
type ProcessElementStatisticsResult struct {
	// Active The total number of active instances of the element.
	Active *int64 `json:"active,omitempty"`

	// Canceled The total number of canceled instances of the element.
	Canceled *int64 `json:"canceled,omitempty"`

	// Completed The total number of completed instances of the element.
	Completed *int64 `json:"completed,omitempty"`

	// ElementId The element ID for which the results are aggregated.
	ElementId *ElementId `json:"elementId,omitempty"`

	// Incidents The total number of incidents for the element.
	Incidents *int64 `json:"incidents,omitempty"`
}

// ProcessInstanceCallHierarchyEntry defines model for ProcessInstanceCallHierarchyEntry.
type ProcessInstanceCallHierarchyEntry struct {
	// ProcessDefinitionKey The key of the process definition.
	ProcessDefinitionKey ProcessDefinitionKey `json:"processDefinitionKey"`

	// ProcessDefinitionName The name of the process definition (fall backs to the process definition ID if not available).
	ProcessDefinitionName string `json:"processDefinitionName"`

	// ProcessInstanceKey The key of the process instance.
	ProcessInstanceKey ProcessInstanceKey `json:"processInstanceKey"`
}

// ProcessInstanceCancellationBatchOperationRequest The process instance filter that defines which process instances should be canceled.
type ProcessInstanceCancellationBatchOperationRequest struct {
	// Filter Process instance search filter.
	Filter ProcessInstanceFilter `json:"filter"`
}

// ProcessInstanceCreationInstruction Instructions for creating a process instance. The process definition can be specified
// either by ID or by key.
type ProcessInstanceCreationInstruction struct {
	union json.RawMessage
}

// ProcessInstanceCreationInstructionById defines model for ProcessInstanceCreationInstructionById.
type ProcessInstanceCreationInstructionById struct {
	// AwaitCompletion Wait for the process instance to complete. If the process instance completion does
	// not occur within the requestTimeout, the request will be closed. This can lead to a 504
	// response status. Disabled by default.
	AwaitCompletion *bool `json:"awaitCompletion,omitempty"`

	// FetchVariables List of variables by name to be included in the response when awaitCompletion is set to true.
	// If empty, all visible variables in the root scope will be returned.
	FetchVariables *[]string `json:"fetchVariables,omitempty"`

	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
	// Must be > 0 if provided.
	OperationReference *OperationReference `json:"operationReference,omitempty"`

	// ProcessDefinitionId The BPMN process ID of the process definition to start an instance of.
	ProcessDefinitionId ProcessDefinitionId `json:"processDefinitionId"`

	// ProcessDefinitionVersion The version of the process. By default, the latest version of the process is used.
	ProcessDefinitionVersion *int32 `json:"processDefinitionVersion,omitempty"`

	// RequestTimeout Timeout (in ms) the request waits for the process to complete. By default or
	// when set to 0, the generic request timeout configured in the cluster is applied.
	RequestTimeout *int64 `json:"requestTimeout,omitempty"`

	// RuntimeInstructions Runtime instructions (alpha). List of instructions that affect the runtime behavior of
	// the process instance. Refer to specific instruction types for more details.
	//
	// This parameter is an alpha feature and may be subject to change
	// in future releases.
	RuntimeInstructions *[]ProcessInstanceCreationRuntimeInstruction `json:"runtimeInstructions,omitempty"`

	// StartInstructions List of start instructions. By default, the process instance will start at
	// the start event. If provided, the process instance will apply start instructions
	// after it has been created.
	StartInstructions *[]ProcessInstanceCreationStartInstruction `json:"startInstructions,omitempty"`

	// Tags List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
	Tags *TagSet `json:"tags,omitempty"`

	// TenantId The tenant ID of the process definition.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Variables JSON object that will instantiate the variables for the root variable scope
	// of the process instance.
	Variables *map[string]interface{} `json:"variables,omitempty"`
}

// ProcessInstanceCreationInstructionByKey defines model for ProcessInstanceCreationInstructionByKey.
type ProcessInstanceCreationInstructionByKey struct {
	// AwaitCompletion Wait for the process instance to complete. If the process instance completion does
	// not occur within the requestTimeout, the request will be closed. This can lead to a 504
	// response status. Disabled by default.
	AwaitCompletion *bool `json:"awaitCompletion,omitempty"`

	// FetchVariables List of variables by name to be included in the response when awaitCompletion is set to true.
	// If empty, all visible variables in the root scope will be returned.
	FetchVariables *[]string `json:"fetchVariables,omitempty"`

	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
	// Must be > 0 if provided.
	OperationReference *OperationReference `json:"operationReference,omitempty"`

	// ProcessDefinitionKey The unique key identifying the process definition, for example, returned for a process in the
	// deploy resources endpoint.
	ProcessDefinitionKey ProcessDefinitionKey `json:"processDefinitionKey"`

	// RequestTimeout Timeout (in ms) the request waits for the process to complete. By default or
	// when set to 0, the generic request timeout configured in the cluster is applied.
	RequestTimeout *int64 `json:"requestTimeout,omitempty"`

	// RuntimeInstructions Runtime instructions (alpha). List of instructions that affect the runtime behavior of
	// the process instance. Refer to specific instruction types for more details.
	//
	// This parameter is an alpha feature and may be subject to change
	// in future releases.
	RuntimeInstructions *[]ProcessInstanceCreationRuntimeInstruction `json:"runtimeInstructions,omitempty"`

	// StartInstructions List of start instructions. By default, the process instance will start at
	// the start event. If provided, the process instance will apply start instructions
	// after it has been created.
	StartInstructions *[]ProcessInstanceCreationStartInstruction `json:"startInstructions,omitempty"`

	// Tags List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
	Tags *TagSet `json:"tags,omitempty"`

	// TenantId The tenant ID of the process definition.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Variables JSON object that will instantiate the variables for the root variable scope
	// of the process instance.
	Variables *map[string]interface{} `json:"variables,omitempty"`
}

// ProcessInstanceCreationRuntimeInstruction Runtime instructions
type ProcessInstanceCreationRuntimeInstruction struct {
	// Type The type of the runtime instruction
	Type  ProcessInstanceCreationRuntimeInstructionType `json:"type"`
	union json.RawMessage
}

// ProcessInstanceCreationRuntimeInstructionType The type of the runtime instruction
type ProcessInstanceCreationRuntimeInstructionType string

// ProcessInstanceCreationStartInstruction defines model for ProcessInstanceCreationStartInstruction.
type ProcessInstanceCreationStartInstruction struct {
	// ElementId Future extensions might include:
	//   - different types of start instructions
	//   - ability to set local variables for different flow scopes
	//
	// For now, however, the start instruction is implicitly a "startBeforeElement" instruction
	ElementId ElementId `json:"elementId"`
}

// ProcessInstanceCreationTerminateInstruction Terminates the process instance after a specific BPMN element is completed or terminated.
type ProcessInstanceCreationTerminateInstruction struct {
	// AfterElementId The ID of the element that, once completed or terminated, will cause the process to be terminated.
	AfterElementId ElementId `json:"afterElementId"`
}

// ProcessInstanceElementStatisticsQueryResult Process instance element statistics query response.
type ProcessInstanceElementStatisticsQueryResult struct {
	// Items The element statistics.
	Items *[]ProcessElementStatisticsResult `json:"items,omitempty"`
}

// ProcessInstanceFilter defines model for ProcessInstanceFilter.
type ProcessInstanceFilter struct {
	// Or Defines a list of alternative filter groups combined using OR logic. Each object in the array is evaluated independently, and the filter matches if any one of them is satisfied.
	//
	// Top-level fields and the `$or` clause are combined using AND logic â€” meaning: (top-level filters) AND (any of the `$or` filters) must match.
	// <br>
	// <em>Example:</em>
	//
	// ```json
	// {
	//   "state": "ACTIVE",
	//   "tenantId": 123,
	//   "$or": [
	//     { "processDefinitionId": "process_v1" },
	//     { "processDefinitionId": "process_v2", "hasIncident": true }
	//   ]
	// }
	// ```
	// This matches process instances that:
	//
	// <ul style="padding-left: 20px; margin-left: 20px;">
	//   <li style="list-style-type: disc;">are in <em>ACTIVE</em> state</li>
	//   <li style="list-style-type: disc;">have tenant ID equal to <em>123</em></li>
	//   <li style="list-style-type: disc;">and match either:
	//     <ul style="padding-left: 20px; margin-left: 20px;">
	//       <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v1</em>, or</li>
	//       <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v2</em> and <code>hasIncident</code> is <em>true</em></li>
	//     </ul>
	//   </li>
	// </ul>
	// <br>
	// <p>Note: Using complex <code>$or</code> conditions may impact performance, use with caution in high-volume environments.
	Or *[]ProcessInstanceFilterFields `json:"$or,omitempty"`

	// BatchOperationId The batch operation ID.
	BatchOperationId *StringFilterProperty `json:"batchOperationId,omitempty"`

	// ElementId The element ID associated with the process instance.
	ElementId *StringFilterProperty `json:"elementId,omitempty"`

	// ElementInstanceState The state of the element instances associated with the process instance.
	ElementInstanceState *ElementInstanceStateFilterProperty `json:"elementInstanceState,omitempty"`

	// EndDate The end date.
	EndDate *DateTimeFilterProperty `json:"endDate,omitempty"`

	// ErrorMessage The error message related to the process.
	ErrorMessage *StringFilterProperty `json:"errorMessage,omitempty"`

	// HasElementInstanceIncident Whether the element instance has an incident or not.
	HasElementInstanceIncident *bool `json:"hasElementInstanceIncident,omitempty"`

	// HasIncident Whether this process instance has a related incident or not.
	HasIncident *bool `json:"hasIncident,omitempty"`

	// HasRetriesLeft Whether the process has failed jobs with retries left.
	HasRetriesLeft *bool `json:"hasRetriesLeft,omitempty"`

	// IncidentErrorHashCode The incident error hash code, associated with this process.
	IncidentErrorHashCode *IntegerFilterProperty `json:"incidentErrorHashCode,omitempty"`

	// ParentElementInstanceKey The parent element instance key.
	ParentElementInstanceKey *ElementInstanceKeyFilterProperty `json:"parentElementInstanceKey,omitempty"`

	// ParentProcessInstanceKey The parent process instance key.
	ParentProcessInstanceKey *ProcessInstanceKeyFilterProperty `json:"parentProcessInstanceKey,omitempty"`

	// ProcessDefinitionId The process definition ID.
	ProcessDefinitionId *StringFilterProperty `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The process definition key.
	ProcessDefinitionKey *ProcessDefinitionKeyFilterProperty `json:"processDefinitionKey,omitempty"`

	// ProcessDefinitionName The process definition name.
	ProcessDefinitionName *StringFilterProperty `json:"processDefinitionName,omitempty"`

	// ProcessDefinitionVersion The process definition version.
	ProcessDefinitionVersion *IntegerFilterProperty `json:"processDefinitionVersion,omitempty"`

	// ProcessDefinitionVersionTag The process definition version tag.
	ProcessDefinitionVersionTag *StringFilterProperty `json:"processDefinitionVersionTag,omitempty"`

	// ProcessInstanceKey The key of this process instance.
	ProcessInstanceKey *ProcessInstanceKeyFilterProperty `json:"processInstanceKey,omitempty"`

	// StartDate The start date.
	StartDate *DateTimeFilterProperty `json:"startDate,omitempty"`

	// State The process instance state.
	State *ProcessInstanceStateFilterProperty `json:"state,omitempty"`

	// Tags List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
	Tags *TagSet `json:"tags,omitempty"`

	// TenantId The tenant ID.
	TenantId *StringFilterProperty `json:"tenantId,omitempty"`

	// Variables The process instance variables.
	Variables *[]VariableValueFilterProperty `json:"variables,omitempty"`
}

// ProcessInstanceFilterFields defines model for ProcessInstanceFilterFields.
type ProcessInstanceFilterFields struct {
	// BatchOperationId The batch operation ID.
	BatchOperationId *StringFilterProperty `json:"batchOperationId,omitempty"`

	// ElementId The element ID associated with the process instance.
	ElementId *StringFilterProperty `json:"elementId,omitempty"`

	// ElementInstanceState The state of the element instances associated with the process instance.
	ElementInstanceState *ElementInstanceStateFilterProperty `json:"elementInstanceState,omitempty"`

	// EndDate The end date.
	EndDate *DateTimeFilterProperty `json:"endDate,omitempty"`

	// ErrorMessage The error message related to the process.
	ErrorMessage *StringFilterProperty `json:"errorMessage,omitempty"`

	// HasElementInstanceIncident Whether the element instance has an incident or not.
	HasElementInstanceIncident *bool `json:"hasElementInstanceIncident,omitempty"`

	// HasIncident Whether this process instance has a related incident or not.
	HasIncident *bool `json:"hasIncident,omitempty"`

	// HasRetriesLeft Whether the process has failed jobs with retries left.
	HasRetriesLeft *bool `json:"hasRetriesLeft,omitempty"`

	// IncidentErrorHashCode The incident error hash code, associated with this process.
	IncidentErrorHashCode *IntegerFilterProperty `json:"incidentErrorHashCode,omitempty"`

	// ParentElementInstanceKey The parent element instance key.
	ParentElementInstanceKey *ElementInstanceKeyFilterProperty `json:"parentElementInstanceKey,omitempty"`

	// ParentProcessInstanceKey The parent process instance key.
	ParentProcessInstanceKey *ProcessInstanceKeyFilterProperty `json:"parentProcessInstanceKey,omitempty"`

	// ProcessDefinitionId The process definition ID.
	ProcessDefinitionId *StringFilterProperty `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The process definition key.
	ProcessDefinitionKey *ProcessDefinitionKeyFilterProperty `json:"processDefinitionKey,omitempty"`

	// ProcessDefinitionName The process definition name.
	ProcessDefinitionName *StringFilterProperty `json:"processDefinitionName,omitempty"`

	// ProcessDefinitionVersion The process definition version.
	ProcessDefinitionVersion *IntegerFilterProperty `json:"processDefinitionVersion,omitempty"`

	// ProcessDefinitionVersionTag The process definition version tag.
	ProcessDefinitionVersionTag *StringFilterProperty `json:"processDefinitionVersionTag,omitempty"`

	// ProcessInstanceKey The key of this process instance.
	ProcessInstanceKey *ProcessInstanceKeyFilterProperty `json:"processInstanceKey,omitempty"`

	// StartDate The start date.
	StartDate *DateTimeFilterProperty `json:"startDate,omitempty"`

	// State The process instance state.
	State *ProcessInstanceStateFilterProperty `json:"state,omitempty"`

	// Tags List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
	Tags *TagSet `json:"tags,omitempty"`

	// TenantId The tenant ID.
	TenantId *StringFilterProperty `json:"tenantId,omitempty"`

	// Variables The process instance variables.
	Variables *[]VariableValueFilterProperty `json:"variables,omitempty"`
}

// ProcessInstanceIncidentResolutionBatchOperationRequest The process instance filter that defines which process instances should have their incidents resolved.
type ProcessInstanceIncidentResolutionBatchOperationRequest struct {
	// Filter Process instance search filter.
	Filter ProcessInstanceFilter `json:"filter"`
}

// ProcessInstanceIncidentSearchQuery defines model for ProcessInstanceIncidentSearchQuery.
type ProcessInstanceIncidentSearchQuery struct {
	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]IncidentSearchQuerySortRequest `json:"sort,omitempty"`
}

// ProcessInstanceKey Zeebe Engine resource key (Java long serialized as string)
type ProcessInstanceKey = LongKey

// ProcessInstanceKeyFilterProperty ProcessInstanceKey property with full advanced search capabilities.
type ProcessInstanceKeyFilterProperty struct {
	union json.RawMessage
}

// ProcessInstanceKeyFilterProperty0 System-generated key for a process instance.
type ProcessInstanceKeyFilterProperty0 = ProcessInstanceKey

// ProcessInstanceMigrationBatchOperationPlan The migration instructions describe how to migrate a process instance from one process definition to another.
type ProcessInstanceMigrationBatchOperationPlan struct {
	// MappingInstructions Element mappings from the source process instance to the target process instance.
	MappingInstructions []MigrateProcessInstanceMappingInstruction `json:"mappingInstructions"`

	// TargetProcessDefinitionKey The key of process definition to migrate the process instance to.
	TargetProcessDefinitionKey ProcessDefinitionKey `json:"targetProcessDefinitionKey"`
}

// ProcessInstanceMigrationBatchOperationRequest defines model for ProcessInstanceMigrationBatchOperationRequest.
type ProcessInstanceMigrationBatchOperationRequest struct {
	// Filter Process instance search filter.
	Filter ProcessInstanceFilter `json:"filter"`

	// MigrationPlan The migration instructions describe how to migrate a process instance from one process definition to another.
	MigrationPlan ProcessInstanceMigrationBatchOperationPlan `json:"migrationPlan"`
}

// ProcessInstanceMigrationInstruction The migration instructions describe how to migrate a process instance from one process definition to another.
type ProcessInstanceMigrationInstruction struct {
	// MappingInstructions Element mappings from the source process instance to the target process instance.
	MappingInstructions []MigrateProcessInstanceMappingInstruction `json:"mappingInstructions"`

	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
	// Must be > 0 if provided.
	OperationReference *OperationReference `json:"operationReference,omitempty"`

	// TargetProcessDefinitionKey The key of process definition to migrate the process instance to.
	TargetProcessDefinitionKey ProcessDefinitionKey `json:"targetProcessDefinitionKey"`
}

// ProcessInstanceModificationActivateInstruction Instructions describing an element that should be activated.
type ProcessInstanceModificationActivateInstruction struct {
	// AncestorElementInstanceKey The key of the ancestor scope the element instance should be created in.
	// Set to -1 to create the new element instance within an existing element instance of the
	// flow scope.
	AncestorElementInstanceKey *ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey `json:"ancestorElementInstanceKey,omitempty"`

	// ElementId The ID of the element that should be activated.
	ElementId ElementId `json:"elementId"`

	// VariableInstructions Instructions describing which variables should be created.
	VariableInstructions *[]ModifyProcessInstanceVariableInstruction `json:"variableInstructions,omitempty"`
}

// ProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0 defines model for .
type ProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0 = string

// ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey The key of the ancestor scope the element instance should be created in.
// Set to -1 to create the new element instance within an existing element instance of the
// flow scope.
type ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey struct {
	union json.RawMessage
}

// ProcessInstanceModificationBatchOperationRequest The process instance filter to define on which process instances tokens should be moved,
// as well as mapping instructions which active element instances should be terminated and which
// new element instances should be activated
type ProcessInstanceModificationBatchOperationRequest struct {
	// Filter Process instance search filter.
	Filter ProcessInstanceFilter `json:"filter"`

	// MoveInstructions Instructions describing which elements should be activated in which scopes and which variables should be created.
	MoveInstructions []ProcessInstanceModificationMoveBatchOperationInstruction `json:"moveInstructions"`
}

// ProcessInstanceModificationInstruction defines model for ProcessInstanceModificationInstruction.
type ProcessInstanceModificationInstruction struct {
	// ActivateInstructions Instructions describing which elements should be activated in which scopes and which variables should be created.
	ActivateInstructions *[]ProcessInstanceModificationActivateInstruction `json:"activateInstructions,omitempty"`

	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
	// Must be > 0 if provided.
	OperationReference *OperationReference `json:"operationReference,omitempty"`

	// TerminateInstructions Instructions describing which elements should be terminated.
	TerminateInstructions *[]ProcessInstanceModificationTerminateInstruction `json:"terminateInstructions,omitempty"`
}

// ProcessInstanceModificationMoveBatchOperationInstruction Instructions describing a move operation. This instruction will terminate all active elementInstance
// at sourceElementId and activate a new element instance for each terminated one at targetElementId.
type ProcessInstanceModificationMoveBatchOperationInstruction struct {
	// SourceElementId The ID of the element that should be terminated.
	SourceElementId ElementId `json:"sourceElementId"`

	// TargetElementId The ID of the element that should be activated.
	TargetElementId ElementId `json:"targetElementId"`
}

// ProcessInstanceModificationTerminateInstruction Instructions describing which elements should be terminated.
type ProcessInstanceModificationTerminateInstruction struct {
	// ElementInstanceKey The ID of the element that should be terminated.
	ElementInstanceKey ElementInstanceKey `json:"elementInstanceKey"`
}

// ProcessInstanceResult Process instance search response item.
type ProcessInstanceResult struct {
	// EndDate The end date.
	EndDate *time.Time `json:"endDate,omitempty"`

	// HasIncident Whether this process instance has a related incident or not.
	HasIncident bool `json:"hasIncident"`

	// ParentElementInstanceKey The parent element instance key.
	ParentElementInstanceKey *ElementInstanceKey `json:"parentElementInstanceKey,omitempty"`

	// ParentProcessInstanceKey The parent process instance key.
	ParentProcessInstanceKey *ProcessInstanceKey `json:"parentProcessInstanceKey,omitempty"`

	// ProcessDefinitionId Id of a process definition, from the model. Only ids of process definitions that are deployed are useful.
	ProcessDefinitionId ProcessDefinitionId `json:"processDefinitionId"`

	// ProcessDefinitionKey The process definition key.
	ProcessDefinitionKey ProcessDefinitionKey `json:"processDefinitionKey"`

	// ProcessDefinitionName The process definition name.
	ProcessDefinitionName string `json:"processDefinitionName"`

	// ProcessDefinitionVersion The process definition version.
	ProcessDefinitionVersion int32 `json:"processDefinitionVersion"`

	// ProcessDefinitionVersionTag The process definition version tag.
	ProcessDefinitionVersionTag *string `json:"processDefinitionVersionTag,omitempty"`

	// ProcessInstanceKey The key of this process instance.
	ProcessInstanceKey ProcessInstanceKey `json:"processInstanceKey"`

	// StartDate The start date.
	StartDate time.Time `json:"startDate"`

	// State Process instance states
	State ProcessInstanceStateEnum `json:"state"`

	// Tags List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
	Tags *TagSet `json:"tags,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId TenantId `json:"tenantId"`
}

// ProcessInstanceSearchQuery defines model for ProcessInstanceSearchQuery.
type ProcessInstanceSearchQuery struct {
	// Filter Process instance search filter.
	Filter *ProcessInstanceFilter `json:"filter,omitempty"`

	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]ProcessInstanceSearchQuerySortRequest `json:"sort,omitempty"`
}

// ProcessInstanceSearchQueryResult defines model for ProcessInstanceSearchQueryResult.
type ProcessInstanceSearchQueryResult struct {
	// Items The matching process instances.
	Items []ProcessInstanceResult `json:"items"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// ProcessInstanceSearchQuerySortRequest defines model for ProcessInstanceSearchQuerySortRequest.
type ProcessInstanceSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field ProcessInstanceSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// ProcessInstanceSearchQuerySortRequestField The field to sort by.
type ProcessInstanceSearchQuerySortRequestField string

// ProcessInstanceSequenceFlowResult Process instance sequence flow result.
type ProcessInstanceSequenceFlowResult struct {
	// ElementId The element ID for this sequence flow, as provided in the BPMN process.
	ElementId *ElementId `json:"elementId,omitempty"`

	// ProcessDefinitionId The process definition ID.
	ProcessDefinitionId *ProcessDefinitionId `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The process definition key.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey The key of this process instance.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// SequenceFlowId The sequence flow ID.
	SequenceFlowId *string `json:"sequenceFlowId,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// ProcessInstanceSequenceFlowsQueryResult Process instance sequence flows query response.
type ProcessInstanceSequenceFlowsQueryResult struct {
	// Items The sequence flows.
	Items *[]ProcessInstanceSequenceFlowResult `json:"items,omitempty"`
}

// ProcessInstanceStateEnum Process instance states
type ProcessInstanceStateEnum string

// ProcessInstanceStateFilterProperty ProcessInstanceStateEnum property with full advanced search capabilities.
type ProcessInstanceStateFilterProperty struct {
	union json.RawMessage
}

// ProcessInstanceStateFilterProperty0 Process instance states
type ProcessInstanceStateFilterProperty0 = ProcessInstanceStateEnum

// ResourceKey The system-assigned key for this resource.
type ResourceKey = string

// ResourceResult defines model for ResourceResult.
type ResourceResult struct {
	// ResourceId The resource ID of this resource.
	ResourceId *string `json:"resourceId,omitempty"`

	// ResourceKey The unique key of this resource.
	ResourceKey *ResourceKey `json:"resourceKey,omitempty"`

	// ResourceName The resource name from which this resource was parsed.
	ResourceName *string `json:"resourceName,omitempty"`

	// TenantId The tenant ID of this resource.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version The assigned resource version.
	Version *int32 `json:"version,omitempty"`

	// VersionTag The version tag of this resource.
	VersionTag *string `json:"versionTag,omitempty"`
}

// ResourceTypeEnum The type of resource to add/remove permissions to/from.
type ResourceTypeEnum string

// RoleClientResult defines model for RoleClientResult.
type RoleClientResult struct {
	// ClientId The ID of the client.
	ClientId *string `json:"clientId,omitempty"`
}

// RoleClientSearchQueryRequest defines model for RoleClientSearchQueryRequest.
type RoleClientSearchQueryRequest struct {
	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]RoleClientSearchQuerySortRequest `json:"sort,omitempty"`
}

// RoleClientSearchQuerySortRequest defines model for RoleClientSearchQuerySortRequest.
type RoleClientSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field RoleClientSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// RoleClientSearchQuerySortRequestField The field to sort by.
type RoleClientSearchQuerySortRequestField string

// RoleClientSearchResult defines model for RoleClientSearchResult.
type RoleClientSearchResult struct {
	// Items The matching clients.
	Items *[]RoleClientResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// RoleCreateRequest defines model for RoleCreateRequest.
type RoleCreateRequest struct {
	// Description The description of the new role.
	Description *string `json:"description,omitempty"`

	// Name The display name of the new role.
	Name string `json:"name"`

	// RoleId The ID of the new role.
	RoleId string `json:"roleId"`
}

// RoleCreateResult defines model for RoleCreateResult.
type RoleCreateResult struct {
	// Description The description of the created role.
	Description *string `json:"description,omitempty"`

	// Name The display name of the created role.
	Name *string `json:"name,omitempty"`

	// RoleId The ID of the created role.
	RoleId *string `json:"roleId,omitempty"`
}

// RoleFilter Role filter request
type RoleFilter struct {
	// Name The role name search filters.
	Name *string `json:"name,omitempty"`

	// RoleId The role ID search filters.
	RoleId *string `json:"roleId,omitempty"`
}

// RoleGroupResult defines model for RoleGroupResult.
type RoleGroupResult struct {
	// GroupId The id of the group.
	GroupId *string `json:"groupId,omitempty"`
}

// RoleGroupSearchQueryRequest defines model for RoleGroupSearchQueryRequest.
type RoleGroupSearchQueryRequest struct {
	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]RoleGroupSearchQuerySortRequest `json:"sort,omitempty"`
}

// RoleGroupSearchQuerySortRequest defines model for RoleGroupSearchQuerySortRequest.
type RoleGroupSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field RoleGroupSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// RoleGroupSearchQuerySortRequestField The field to sort by.
type RoleGroupSearchQuerySortRequestField string

// RoleGroupSearchResult defines model for RoleGroupSearchResult.
type RoleGroupSearchResult struct {
	// Items The matching groups.
	Items *[]RoleGroupResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// RoleResult Role search response item.
type RoleResult struct {
	// Description The description of the role.
	Description *string `json:"description,omitempty"`

	// Name The role name.
	Name *string `json:"name,omitempty"`

	// RoleId The role id.
	RoleId *string `json:"roleId,omitempty"`
}

// RoleSearchQueryRequest defines model for RoleSearchQueryRequest.
type RoleSearchQueryRequest struct {
	// Filter Role filter request
	Filter *RoleFilter `json:"filter,omitempty"`

	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]RoleSearchQuerySortRequest `json:"sort,omitempty"`
}

// RoleSearchQueryResult defines model for RoleSearchQueryResult.
type RoleSearchQueryResult struct {
	// Items The matching roles.
	Items *[]RoleResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// RoleSearchQuerySortRequest defines model for RoleSearchQuerySortRequest.
type RoleSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field RoleSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// RoleSearchQuerySortRequestField The field to sort by.
type RoleSearchQuerySortRequestField string

// RoleUpdateRequest defines model for RoleUpdateRequest.
type RoleUpdateRequest struct {
	// Description The description of the new role.
	Description string `json:"description"`

	// Name The display name of the new role.
	Name string `json:"name"`
}

// RoleUpdateResult defines model for RoleUpdateResult.
type RoleUpdateResult struct {
	// Description The description of the updated role.
	Description *string `json:"description,omitempty"`

	// Name The display name of the updated role.
	Name *string `json:"name,omitempty"`

	// RoleId The ID of the updated role.
	RoleId *string `json:"roleId,omitempty"`
}

// RoleUserResult defines model for RoleUserResult.
type RoleUserResult struct {
	// Username The unique name of a user.
	Username *Username `json:"username,omitempty"`
}

// RoleUserSearchQueryRequest defines model for RoleUserSearchQueryRequest.
type RoleUserSearchQueryRequest struct {
	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]RoleUserSearchQuerySortRequest `json:"sort,omitempty"`
}

// RoleUserSearchQuerySortRequest defines model for RoleUserSearchQuerySortRequest.
type RoleUserSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field RoleUserSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// RoleUserSearchQuerySortRequestField The field to sort by.
type RoleUserSearchQuerySortRequestField string

// RoleUserSearchResult defines model for RoleUserSearchResult.
type RoleUserSearchResult struct {
	// Items The matching users.
	Items *[]RoleUserResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// ScopeKey Zeebe Engine resource key (Java long serialized as string)
type ScopeKey = LongKey

// ScopeKeyFilterProperty ScopeKey property with full advanced search capabilities.
type ScopeKeyFilterProperty struct {
	union json.RawMessage
}

// ScopeKeyFilterProperty0 System-generated key for a scope.
type ScopeKeyFilterProperty0 = ScopeKey

// SearchQueryPageRequest Pagination criteria. Can use offset-based pagination (from/limit) OR cursor-based pagination (after/before + limit), but not both.
type SearchQueryPageRequest struct {
	union json.RawMessage
}

// SearchQueryPageResponse Pagination information about the search results.
type SearchQueryPageResponse struct {
	// EndCursor The cursor value for getting the next page of results. Use this in the `after` field of an ensuing request.
	EndCursor *EndCursor `json:"endCursor,omitempty"`

	// HasMoreTotalItems Indicates if more results exist beyond the reported totalItems value. Due to system limitations, the totalItems value can be capped.
	HasMoreTotalItems *bool `json:"hasMoreTotalItems,omitempty"`

	// StartCursor The cursor value for getting the previous page of results. Use this in the `before` field of an ensuing request.
	StartCursor *StartCursor `json:"startCursor,omitempty"`

	// TotalItems Total items matching the criteria.
	TotalItems int64 `json:"totalItems"`
}

// SearchQueryRequest defines model for SearchQueryRequest.
type SearchQueryRequest struct {
	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`
}

// SearchQueryResponse defines model for SearchQueryResponse.
type SearchQueryResponse struct {
	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// SetVariableRequest defines model for SetVariableRequest.
type SetVariableRequest struct {
	// Local If set to true, the variables are merged strictly into the local scope (as specified by the `elementInstanceKey`).
	// Otherwise, the variables are propagated to upper scopes and set at the outermost one.
	//
	// Letâ€™s consider the following example:
	//
	// There are two scopes '1' and '2'.
	// Scope '1' is the parent scope of '2'. The effective variables of the scopes are:
	// 1 => { "foo" : 2 }
	// 2 => { "bar" : 1 }
	//
	// An update request with elementInstanceKey as '2', variables { "foo" : 5 }, and local set
	// to true leaves scope '1' unchanged and adjusts scope '2' to { "bar" : 1, "foo" 5 }.
	//
	// By default, with local set to false, scope '1' will be { "foo": 5 }
	// and scope '2' will be { "bar" : 1 }.
	Local *bool `json:"local,omitempty"`

	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
	// Must be > 0 if provided.
	OperationReference *OperationReference `json:"operationReference,omitempty"`

	// Variables JSON object representing the variables to set in the elementâ€™s scope.
	Variables map[string]interface{} `json:"variables"`
}

// SignalBroadcastRequest defines model for SignalBroadcastRequest.
type SignalBroadcastRequest struct {
	// SignalName The name of the signal to broadcast.
	SignalName string `json:"signalName"`

	// TenantId The ID of the tenant that owns the signal.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Variables The signal variables as a JSON object.
	Variables *map[string]interface{} `json:"variables,omitempty"`
}

// SignalBroadcastResult defines model for SignalBroadcastResult.
type SignalBroadcastResult struct {
	// SignalKey The unique ID of the signal that was broadcast.
	SignalKey SignalKey `json:"signalKey"`

	// TenantId The tenant ID of the signal that was broadcast.
	TenantId TenantId `json:"tenantId"`
}

// SignalKey Zeebe Engine resource key (Java long serialized as string)
type SignalKey = LongKey

// SortOrderEnum The order in which to sort the related field.
type SortOrderEnum string

// StartCursor The start cursor in a search query result set.
type StartCursor = string

// StringFilterProperty String property with full advanced search capabilities.
type StringFilterProperty struct {
	union json.RawMessage
}

// StringFilterProperty0 Matches the value exactly.
type StringFilterProperty0 = string

// Tag A tag. Needs to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
type Tag = string

// TagSet List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
type TagSet = []Tag

// TenantClientResult defines model for TenantClientResult.
type TenantClientResult struct {
	// ClientId The ID of the client.
	ClientId *string `json:"clientId,omitempty"`
}

// TenantClientSearchQueryRequest defines model for TenantClientSearchQueryRequest.
type TenantClientSearchQueryRequest struct {
	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]TenantClientSearchQuerySortRequest `json:"sort,omitempty"`
}

// TenantClientSearchQuerySortRequest defines model for TenantClientSearchQuerySortRequest.
type TenantClientSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field TenantClientSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// TenantClientSearchQuerySortRequestField The field to sort by.
type TenantClientSearchQuerySortRequestField string

// TenantClientSearchResult defines model for TenantClientSearchResult.
type TenantClientSearchResult struct {
	// Items The matching clients.
	Items *[]TenantClientResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// TenantCreateRequest defines model for TenantCreateRequest.
type TenantCreateRequest struct {
	// Description The description of the tenant.
	Description *string `json:"description,omitempty"`

	// Name The name of the tenant.
	Name string `json:"name"`

	// TenantId The unique ID for the tenant. Must be 255 characters or less. Can contain letters, numbers, [`_`, `-`, `+`, `.`, `@`].
	TenantId string `json:"tenantId"`
}

// TenantCreateResult defines model for TenantCreateResult.
type TenantCreateResult struct {
	// Description The description of the tenant.
	Description *string `json:"description,omitempty"`

	// Name The name of the tenant.
	Name *string `json:"name,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// TenantFilter Tenant filter request
type TenantFilter struct {
	// Name The name of the tenant.
	Name *string `json:"name,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// TenantGroupResult defines model for TenantGroupResult.
type TenantGroupResult struct {
	// GroupId The groupId of the group.
	GroupId *string `json:"groupId,omitempty"`
}

// TenantGroupSearchQueryRequest defines model for TenantGroupSearchQueryRequest.
type TenantGroupSearchQueryRequest struct {
	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]TenantGroupSearchQuerySortRequest `json:"sort,omitempty"`
}

// TenantGroupSearchQuerySortRequest defines model for TenantGroupSearchQuerySortRequest.
type TenantGroupSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field TenantGroupSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// TenantGroupSearchQuerySortRequestField The field to sort by.
type TenantGroupSearchQuerySortRequestField string

// TenantGroupSearchResult defines model for TenantGroupSearchResult.
type TenantGroupSearchResult struct {
	// Items The matching groups.
	Items *[]TenantGroupResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// TenantId The unique identifier of the tenant.
type TenantId = string

// TenantResult Tenant search response item.
type TenantResult struct {
	// Description The tenant description.
	Description *string `json:"description,omitempty"`

	// Name The tenant name.
	Name *string `json:"name,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// TenantSearchQueryRequest defines model for TenantSearchQueryRequest.
type TenantSearchQueryRequest struct {
	// Filter Tenant filter request
	Filter *TenantFilter `json:"filter,omitempty"`

	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]TenantSearchQuerySortRequest `json:"sort,omitempty"`
}

// TenantSearchQueryResult defines model for TenantSearchQueryResult.
type TenantSearchQueryResult struct {
	// Items The matching tenants.
	Items *[]TenantResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// TenantSearchQuerySortRequest defines model for TenantSearchQuerySortRequest.
type TenantSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field TenantSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// TenantSearchQuerySortRequestField The field to sort by.
type TenantSearchQuerySortRequestField string

// TenantUpdateRequest defines model for TenantUpdateRequest.
type TenantUpdateRequest struct {
	// Description The new description of the tenant.
	Description string `json:"description"`

	// Name The new name of the tenant.
	Name string `json:"name"`
}

// TenantUpdateResult defines model for TenantUpdateResult.
type TenantUpdateResult struct {
	// Description The description of the tenant.
	Description *string `json:"description,omitempty"`

	// Name The name of the tenant.
	Name *string `json:"name,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// TenantUserResult defines model for TenantUserResult.
type TenantUserResult struct {
	// Username The unique name of a user.
	Username *Username `json:"username,omitempty"`
}

// TenantUserSearchQueryRequest defines model for TenantUserSearchQueryRequest.
type TenantUserSearchQueryRequest struct {
	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]TenantUserSearchQuerySortRequest `json:"sort,omitempty"`
}

// TenantUserSearchQuerySortRequest defines model for TenantUserSearchQuerySortRequest.
type TenantUserSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field TenantUserSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// TenantUserSearchQuerySortRequestField The field to sort by.
type TenantUserSearchQuerySortRequestField string

// TenantUserSearchResult defines model for TenantUserSearchResult.
type TenantUserSearchResult struct {
	// Items The matching users.
	Items *[]TenantUserResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// TopologyResponse The response of a topology request.
type TopologyResponse struct {
	// Brokers A list of brokers that are part of this cluster.
	Brokers []BrokerInfo `json:"brokers"`

	// ClusterSize The number of brokers in the cluster.
	ClusterSize int32 `json:"clusterSize"`

	// GatewayVersion The version of the Zeebe Gateway.
	GatewayVersion string `json:"gatewayVersion"`

	// LastCompletedChangeId ID of the last completed change
	LastCompletedChangeId string `json:"lastCompletedChangeId"`

	// PartitionsCount The number of partitions are spread across the cluster.
	PartitionsCount int32 `json:"partitionsCount"`

	// ReplicationFactor The configured replication factor for this cluster.
	ReplicationFactor int32 `json:"replicationFactor"`
}

// UsageMetricsResponse defines model for UsageMetricsResponse.
type UsageMetricsResponse = UsageMetricsResponseItem

// UsageMetricsResponseItem defines model for UsageMetricsResponseItem.
type UsageMetricsResponseItem struct {
	// Assignees The amount of unique active task users.
	Assignees *int64 `json:"assignees,omitempty"`

	// DecisionInstances The amount of executed decision instances.
	DecisionInstances *int64 `json:"decisionInstances,omitempty"`

	// ProcessInstances The amount of created root process instances.
	ProcessInstances *int64 `json:"processInstances,omitempty"`
}

// UserCreateResult defines model for UserCreateResult.
type UserCreateResult struct {
	// Email The email of the user.
	Email *string `json:"email,omitempty"`

	// Name The name of the user.
	Name *string `json:"name,omitempty"`

	// Username The unique name of a user.
	Username *Username `json:"username,omitempty"`
}

// UserFilter User search filter.
type UserFilter struct {
	// Email The email of the user.
	Email *StringFilterProperty `json:"email,omitempty"`

	// Name The name of the user.
	Name *StringFilterProperty `json:"name,omitempty"`

	// Username The username of the user.
	Username *StringFilterProperty `json:"username,omitempty"`
}

// UserRequest defines model for UserRequest.
type UserRequest struct {
	// Email The email of the user.
	Email *string `json:"email,omitempty"`

	// Name The name of the user.
	Name *string `json:"name,omitempty"`

	// Password The password of the user.
	Password string `json:"password"`

	// Username The username of the user.
	Username string `json:"username"`
}

// UserResult defines model for UserResult.
type UserResult struct {
	// Email The email of the user.
	Email *string `json:"email,omitempty"`

	// Name The name of the user.
	Name *string `json:"name,omitempty"`

	// Username The unique name of a user.
	Username *Username `json:"username,omitempty"`
}

// UserSearchQueryRequest defines model for UserSearchQueryRequest.
type UserSearchQueryRequest struct {
	// Filter User search filter.
	Filter *UserFilter `json:"filter,omitempty"`

	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]UserSearchQuerySortRequest `json:"sort,omitempty"`
}

// UserSearchQuerySortRequest defines model for UserSearchQuerySortRequest.
type UserSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field UserSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// UserSearchQuerySortRequestField The field to sort by.
type UserSearchQuerySortRequestField string

// UserSearchResult defines model for UserSearchResult.
type UserSearchResult struct {
	// Items The matching users.
	Items []UserResult `json:"items"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// UserTaskAssignmentRequest defines model for UserTaskAssignmentRequest.
type UserTaskAssignmentRequest struct {
	// Action A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "assign".
	Action *string `json:"action"`

	// AllowOverride By default, the task is reassigned if it was already assigned. Set this to `false` to return an error in such cases. The task must then first be unassigned to be assigned again. Use this when you have users picking from group task queues to prevent race conditions.
	AllowOverride *bool `json:"allowOverride"`

	// Assignee The assignee for the user task. The assignee must not be empty or `null`.
	Assignee *string `json:"assignee,omitempty"`
}

// UserTaskCompletionRequest defines model for UserTaskCompletionRequest.
type UserTaskCompletionRequest struct {
	// Action A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "complete".
	Action *string `json:"action"`

	// Variables The variables to complete the user task with.
	Variables *map[string]interface{} `json:"variables"`
}

// UserTaskFilter User task filter request.
type UserTaskFilter struct {
	// Assignee The assignee of the user task.
	Assignee *StringFilterProperty `json:"assignee,omitempty"`

	// CandidateGroup The candidate group for this user task.
	CandidateGroup *StringFilterProperty `json:"candidateGroup,omitempty"`

	// CandidateUser The candidate user for this user task.
	CandidateUser *StringFilterProperty `json:"candidateUser,omitempty"`

	// CompletionDate The user task completion date.
	CompletionDate *DateTimeFilterProperty `json:"completionDate,omitempty"`

	// CreationDate The user task creation date.
	CreationDate *DateTimeFilterProperty `json:"creationDate,omitempty"`

	// DueDate The user task due date.
	DueDate *DateTimeFilterProperty `json:"dueDate,omitempty"`

	// ElementId The element ID of the user task.
	ElementId *ElementId `json:"elementId,omitempty"`

	// ElementInstanceKey The key of the element instance.
	ElementInstanceKey *ElementInstanceKey `json:"elementInstanceKey,omitempty"`

	// FollowUpDate The user task follow-up date.
	FollowUpDate *DateTimeFilterProperty `json:"followUpDate,omitempty"`

	// LocalVariables Local variables associated with the user task.
	LocalVariables *[]VariableValueFilterProperty `json:"localVariables,omitempty"`

	// Name The task name. This only works for data created with 8.8 and onwards. Instances from prior versions don't contain this data and cannot be found.
	Name *string `json:"name,omitempty"`

	// Priority The priority of the user task.
	Priority *IntegerFilterProperty `json:"priority,omitempty"`

	// ProcessDefinitionId The ID of the process definition.
	ProcessDefinitionId *ProcessDefinitionId `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The key of the process definition.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey The key of the process instance.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// ProcessInstanceVariables Process instance variables associated with the user task.
	ProcessInstanceVariables *[]VariableValueFilterProperty `json:"processInstanceVariables,omitempty"`

	// State The user task state.
	State *UserTaskStateFilterProperty `json:"state,omitempty"`

	// TenantId Tenant ID of this user task.
	TenantId *StringFilterProperty `json:"tenantId,omitempty"`

	// UserTaskKey The key for this user task.
	UserTaskKey *UserTaskKey `json:"userTaskKey,omitempty"`
}

// UserTaskKey Zeebe Engine resource key (Java long serialized as string)
type UserTaskKey = LongKey

// UserTaskProperties Contains properties of a user task.
type UserTaskProperties struct {
	// Action The action performed on the user task.
	Action *string `json:"action,omitempty"`

	// Assignee The user assigned to the task.
	Assignee *string `json:"assignee"`

	// CandidateGroups The groups eligible to claim the task.
	CandidateGroups *[]string `json:"candidateGroups,omitempty"`

	// CandidateUsers The users eligible to claim the task.
	CandidateUsers *[]string `json:"candidateUsers,omitempty"`

	// ChangedAttributes The attributes that were changed in the task.
	ChangedAttributes *[]string `json:"changedAttributes,omitempty"`

	// DueDate The due date of the user task in ISO 8601 format.
	DueDate *time.Time `json:"dueDate"`

	// FollowUpDate The follow-up date of the user task in ISO 8601 format.
	FollowUpDate *time.Time `json:"followUpDate"`

	// FormKey The key of the form associated with the user task.
	FormKey *FormKey `json:"formKey,omitempty"`

	// Priority The priority of the user task.
	Priority *int32 `json:"priority"`

	// UserTaskKey The unique key identifying the user task.
	UserTaskKey *UserTaskKey `json:"userTaskKey"`
}

// UserTaskResult defines model for UserTaskResult.
type UserTaskResult struct {
	// Assignee The assignee of the user task.
	Assignee *string `json:"assignee,omitempty"`

	// CandidateGroups The candidate groups for this user task.
	CandidateGroups *[]string `json:"candidateGroups,omitempty"`

	// CandidateUsers The candidate users for this user task.
	CandidateUsers *[]string `json:"candidateUsers,omitempty"`

	// CompletionDate The completion date of a user task.
	CompletionDate *time.Time `json:"completionDate,omitempty"`

	// CreationDate The creation date of a user task.
	CreationDate *time.Time `json:"creationDate,omitempty"`

	// CustomHeaders Custom headers for the user task.
	CustomHeaders *map[string]string `json:"customHeaders,omitempty"`

	// DueDate The due date of a user task.
	DueDate *time.Time `json:"dueDate,omitempty"`

	// ElementId The element ID of the user task.
	ElementId *ElementId `json:"elementId,omitempty"`

	// ElementInstanceKey The key of the element instance.
	ElementInstanceKey *ElementInstanceKey `json:"elementInstanceKey,omitempty"`

	// ExternalFormReference The external form reference.
	ExternalFormReference *string `json:"externalFormReference,omitempty"`

	// FollowUpDate The follow date of a user task.
	FollowUpDate *time.Time `json:"followUpDate,omitempty"`

	// FormKey The key of the form.
	FormKey *FormKey `json:"formKey,omitempty"`

	// Name The name for this user task.
	Name *string `json:"name,omitempty"`

	// Priority The priority of a user task. The higher the value the higher the priority.
	Priority *int `json:"priority,omitempty"`

	// ProcessDefinitionId The ID of the process definition.
	ProcessDefinitionId *ProcessDefinitionId `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The key of the process definition.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ProcessDefinitionVersion The version of the process definition.
	ProcessDefinitionVersion *int32 `json:"processDefinitionVersion,omitempty"`

	// ProcessInstanceKey The key of the process instance.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// ProcessName The name of the process definition.
	ProcessName *string `json:"processName,omitempty"`

	// State The state of the user task.
	State *UserTaskStateEnum `json:"state,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// UserTaskKey The key of the user task.
	UserTaskKey *UserTaskKey `json:"userTaskKey,omitempty"`
}

// UserTaskSearchQuery defines model for UserTaskSearchQuery.
type UserTaskSearchQuery struct {
	// Filter User task filter request.
	Filter *UserTaskFilter `json:"filter,omitempty"`

	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]UserTaskSearchQuerySortRequest `json:"sort,omitempty"`
}

// UserTaskSearchQueryResult defines model for UserTaskSearchQueryResult.
type UserTaskSearchQueryResult struct {
	// Items The matching user tasks.
	Items *[]UserTaskResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// UserTaskSearchQuerySortRequest defines model for UserTaskSearchQuerySortRequest.
type UserTaskSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field UserTaskSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// UserTaskSearchQuerySortRequestField The field to sort by.
type UserTaskSearchQuerySortRequestField string

// UserTaskStateEnum The state of the user task.
type UserTaskStateEnum string

// UserTaskStateFilterProperty UserTaskStateEnum property with full advanced search capabilities.
type UserTaskStateFilterProperty struct {
	union json.RawMessage
}

// UserTaskStateFilterProperty0 The state of the user task.
type UserTaskStateFilterProperty0 = UserTaskStateEnum

// UserTaskUpdateRequest defines model for UserTaskUpdateRequest.
type UserTaskUpdateRequest struct {
	// Action A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "update".
	Action *string `json:"action"`

	// Changeset JSON object with changed task attribute values.
	//
	// The following attributes can be adjusted with this endpoint, additional attributes
	// will be ignored:
	//
	// * `candidateGroups` - reset by providing an empty list
	// * `candidateUsers` - reset by providing an empty list
	// * `dueDate` - reset by providing an empty String
	// * `followUpDate` - reset by providing an empty String
	// * `priority` - minimum 0, maximum 100, default 50
	//
	// Providing any of those attributes with a `null` value or omitting it preserves
	// the persisted attribute's value.
	//
	// The assignee cannot be adjusted with this endpoint, use the Assign task endpoint.
	// This ensures correct event emission for assignee changes.
	Changeset *Changeset `json:"changeset"`
}

// UserTaskVariableFilter The user task variable search filters.
type UserTaskVariableFilter struct {
	// Name Name of the variable.
	Name *StringFilterProperty `json:"name,omitempty"`
}

// UserTaskVariableSearchQueryRequest defines model for UserTaskVariableSearchQueryRequest.
type UserTaskVariableSearchQueryRequest struct {
	// Filter The user task variable search filters.
	Filter *UserTaskVariableFilter `json:"filter,omitempty"`

	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]UserTaskVariableSearchQuerySortRequest `json:"sort,omitempty"`
}

// UserTaskVariableSearchQuerySortRequest defines model for UserTaskVariableSearchQuerySortRequest.
type UserTaskVariableSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field UserTaskVariableSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// UserTaskVariableSearchQuerySortRequestField The field to sort by.
type UserTaskVariableSearchQuerySortRequestField string

// UserUpdateRequest defines model for UserUpdateRequest.
type UserUpdateRequest struct {
	// Email The email of the user.
	Email *string `json:"email,omitempty"`

	// Name The name of the user.
	Name *string `json:"name,omitempty"`

	// Password The password of the user. If blank, the password is unchanged.
	Password *string `json:"password,omitempty"`
}

// UserUpdateResult defines model for UserUpdateResult.
type UserUpdateResult struct {
	// Email The email of the user.
	Email *string `json:"email,omitempty"`

	// Name The name of the user.
	Name *string `json:"name,omitempty"`

	// Username The unique name of a user.
	Username *Username `json:"username,omitempty"`
}

// Username The unique name of a user.
type Username = string

// VariableFilter Variable filter request.
type VariableFilter struct {
	// IsTruncated Whether the value is truncated or not.
	IsTruncated *bool `json:"isTruncated,omitempty"`

	// Name Name of the variable.
	Name *StringFilterProperty `json:"name,omitempty"`

	// ProcessInstanceKey The key of the process instance of this variable.
	ProcessInstanceKey *ProcessInstanceKeyFilterProperty `json:"processInstanceKey,omitempty"`

	// ScopeKey The key of the scope of this variable.
	ScopeKey *ScopeKeyFilterProperty `json:"scopeKey,omitempty"`

	// TenantId Tenant ID of this variable.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Value The value of the variable.
	Value *StringFilterProperty `json:"value,omitempty"`

	// VariableKey The key for this variable.
	VariableKey *VariableKeyFilterProperty `json:"variableKey,omitempty"`
}

// VariableKey Zeebe Engine resource key (Java long serialized as string)
type VariableKey = LongKey

// VariableKeyFilterProperty VariableKey property with full advanced search capabilities.
type VariableKeyFilterProperty struct {
	union json.RawMessage
}

// VariableKeyFilterProperty0 System-generated key for a variable.
type VariableKeyFilterProperty0 = VariableKey

// VariableResult Variable response item.
type VariableResult = VariableResultBase

// VariableResultBase Variable response item.
type VariableResultBase struct {
	// Name Name of this variable.
	Name *string `json:"name,omitempty"`

	// ProcessInstanceKey The key of the process instance of this variable.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// ScopeKey The key of the scope of this variable.
	ScopeKey *ScopeKey `json:"scopeKey,omitempty"`

	// TenantId Tenant ID of this variable.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// VariableKey The key for this variable.
	VariableKey *VariableKey `json:"variableKey,omitempty"`
}

// VariableSearchQuery defines model for VariableSearchQuery.
type VariableSearchQuery struct {
	// Filter Variable filter request.
	Filter *VariableFilter `json:"filter,omitempty"`

	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`

	// Sort Sort field criteria.
	Sort *[]VariableSearchQuerySortRequest `json:"sort,omitempty"`
}

// VariableSearchQueryResult defines model for VariableSearchQueryResult.
type VariableSearchQueryResult struct {
	// Items The matching variables.
	Items *[]VariableSearchResult `json:"items,omitempty"`

	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// VariableSearchQuerySortRequest defines model for VariableSearchQuerySortRequest.
type VariableSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field VariableSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// VariableSearchQuerySortRequestField The field to sort by.
type VariableSearchQuerySortRequestField string

// VariableSearchResult Variable response item.
type VariableSearchResult = VariableResultBase

// VariableValueFilterProperty defines model for VariableValueFilterProperty.
type VariableValueFilterProperty struct {
	// Name Name of the variable.
	Name string `json:"name"`

	// Value The value of the variable.
	Value StringFilterProperty `json:"value"`
}

// Forbidden A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.
type Forbidden = ProblemDetail

// InternalServerError A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.
type InternalServerError = ProblemDetail

// InvalidData A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.
type InvalidData = ProblemDetail

// ServiceUnavailable A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.
type ServiceUnavailable = ProblemDetail

// Unauthorized A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.
type Unauthorized = ProblemDetail

// UnsupportedMediaType A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.
type UnsupportedMediaType = ProblemDetail

// CancelBatchOperationJSONBody defines parameters for CancelBatchOperation.
type CancelBatchOperationJSONBody interface{}

// ResumeBatchOperationJSONBody defines parameters for ResumeBatchOperation.
type ResumeBatchOperationJSONBody interface{}

// SuspendBatchOperationJSONBody defines parameters for SuspendBatchOperation.
type SuspendBatchOperationJSONBody interface{}

// CreateDeploymentMultipartBody defines parameters for CreateDeployment.
type CreateDeploymentMultipartBody struct {
	// Resources The binary data to create the deployment resources. It is possible to have more than one form part with different form part names for the binary data to create a deployment.
	Resources []openapi_types.File `json:"resources"`

	// TenantId The tenant to deploy the resources to.
	TenantId *string `json:"tenantId,omitempty"`
}

// CreateDocumentMultipartBody defines parameters for CreateDocument.
type CreateDocumentMultipartBody struct {
	File openapi_types.File `json:"file"`

	// Metadata Information about the document.
	Metadata *DocumentMetadata `json:"metadata,omitempty"`
}

// CreateDocumentParams defines parameters for CreateDocument.
type CreateDocumentParams struct {
	// StoreId The ID of the document store to upload the documents to. Currently, only a single document store is supported per cluster. However, this attribute is included to allow for potential future support of multiple document stores.
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`

	// DocumentId The ID of the document to upload. If not provided, a new ID will be generated. Specifying an existing ID will result in an error if the document already exists.
	DocumentId *string `form:"documentId,omitempty" json:"documentId,omitempty"`
}

// CreateDocumentsMultipartBody defines parameters for CreateDocuments.
type CreateDocumentsMultipartBody struct {
	// Files The documents to upload.
	Files []openapi_types.File `json:"files"`

	// MetadataList Optional JSON array of metadata object whose index aligns with each file entry. The metadata array must have the same length as the files array.
	MetadataList *[]DocumentMetadata `json:"metadataList,omitempty"`
}

// CreateDocumentsParams defines parameters for CreateDocuments.
type CreateDocumentsParams struct {
	// StoreId The ID of the document store to upload the documents to. Currently, only a single document store is supported per cluster. However, this attribute is included to allow for potential future support of multiple document stores.
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`
}

// DeleteDocumentParams defines parameters for DeleteDocument.
type DeleteDocumentParams struct {
	// StoreId The ID of the document store to delete the document from.
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`
}

// GetDocumentParams defines parameters for GetDocument.
type GetDocumentParams struct {
	// StoreId The ID of the document store to download the document from.
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`

	// ContentHash The hash of the document content that was computed by the document store during upload. The hash is part of the document reference that is returned when uploading a document. If the client fails to provide the correct hash, the request will be rejected.
	ContentHash string `form:"contentHash" json:"contentHash"`
}

// CreateDocumentLinkParams defines parameters for CreateDocumentLink.
type CreateDocumentLinkParams struct {
	// StoreId The ID of the document store to link the document from.
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`

	// ContentHash The hash of the document content that was computed by the document store during upload. The hash is part of the document reference that is returned when uploading a document. If the client fails to provide the correct hash, the request will be rejected.
	ContentHash string `form:"contentHash" json:"contentHash"`
}

// GetUsageMetricsParams defines parameters for GetUsageMetrics.
type GetUsageMetricsParams struct {
	// StartTime The start date for usage metrics, including this date. Value in ISO 8601 format.
	StartTime time.Time `form:"startTime" json:"startTime"`

	// EndTime The end date for usage metrics, including this date. Value in ISO 8601 format.
	EndTime time.Time `form:"endTime" json:"endTime"`

	// TenantId Restrict results to a specific tenant ID. If not provided, results for all tenants are returned.
	TenantId *TenantId `form:"tenantId,omitempty" json:"tenantId,omitempty"`

	// WithTenants Whether to return tenant metrics in addition to the total metrics or not. Default false.
	WithTenants *bool `form:"withTenants,omitempty" json:"withTenants,omitempty"`
}

// CreateAuthorizationJSONRequestBody defines body for CreateAuthorization for application/json ContentType.
type CreateAuthorizationJSONRequestBody = AuthorizationRequest

// SearchAuthorizationsJSONRequestBody defines body for SearchAuthorizations for application/json ContentType.
type SearchAuthorizationsJSONRequestBody = AuthorizationSearchQuery

// UpdateAuthorizationJSONRequestBody defines body for UpdateAuthorization for application/json ContentType.
type UpdateAuthorizationJSONRequestBody = AuthorizationRequest

// SearchBatchOperationItemsJSONRequestBody defines body for SearchBatchOperationItems for application/json ContentType.
type SearchBatchOperationItemsJSONRequestBody = BatchOperationItemSearchQuery

// SearchBatchOperationsJSONRequestBody defines body for SearchBatchOperations for application/json ContentType.
type SearchBatchOperationsJSONRequestBody = BatchOperationSearchQuery

// CancelBatchOperationJSONRequestBody defines body for CancelBatchOperation for application/json ContentType.
type CancelBatchOperationJSONRequestBody CancelBatchOperationJSONBody

// ResumeBatchOperationJSONRequestBody defines body for ResumeBatchOperation for application/json ContentType.
type ResumeBatchOperationJSONRequestBody ResumeBatchOperationJSONBody

// SuspendBatchOperationJSONRequestBody defines body for SuspendBatchOperation for application/json ContentType.
type SuspendBatchOperationJSONRequestBody SuspendBatchOperationJSONBody

// PinClockJSONRequestBody defines body for PinClock for application/json ContentType.
type PinClockJSONRequestBody = ClockPinRequest

// SearchCorrelatedMessageSubscriptionsJSONRequestBody defines body for SearchCorrelatedMessageSubscriptions for application/json ContentType.
type SearchCorrelatedMessageSubscriptionsJSONRequestBody = CorrelatedMessageSubscriptionSearchQuery

// EvaluateDecisionJSONRequestBody defines body for EvaluateDecision for application/json ContentType.
type EvaluateDecisionJSONRequestBody = DecisionEvaluationInstruction

// SearchDecisionDefinitionsJSONRequestBody defines body for SearchDecisionDefinitions for application/json ContentType.
type SearchDecisionDefinitionsJSONRequestBody = DecisionDefinitionSearchQuery

// SearchDecisionInstancesJSONRequestBody defines body for SearchDecisionInstances for application/json ContentType.
type SearchDecisionInstancesJSONRequestBody = DecisionInstanceSearchQuery

// SearchDecisionRequirementsJSONRequestBody defines body for SearchDecisionRequirements for application/json ContentType.
type SearchDecisionRequirementsJSONRequestBody = DecisionRequirementsSearchQuery

// CreateDeploymentMultipartRequestBody defines body for CreateDeployment for multipart/form-data ContentType.
type CreateDeploymentMultipartRequestBody CreateDeploymentMultipartBody

// CreateDocumentMultipartRequestBody defines body for CreateDocument for multipart/form-data ContentType.
type CreateDocumentMultipartRequestBody CreateDocumentMultipartBody

// CreateDocumentsMultipartRequestBody defines body for CreateDocuments for multipart/form-data ContentType.
type CreateDocumentsMultipartRequestBody CreateDocumentsMultipartBody

// CreateDocumentLinkJSONRequestBody defines body for CreateDocumentLink for application/json ContentType.
type CreateDocumentLinkJSONRequestBody = DocumentLinkRequest

// ActivateAdHocSubProcessActivitiesJSONRequestBody defines body for ActivateAdHocSubProcessActivities for application/json ContentType.
type ActivateAdHocSubProcessActivitiesJSONRequestBody = AdHocSubProcessActivateActivitiesInstruction

// SearchElementInstancesJSONRequestBody defines body for SearchElementInstances for application/json ContentType.
type SearchElementInstancesJSONRequestBody = ElementInstanceSearchQuery

// CreateElementInstanceVariablesJSONRequestBody defines body for CreateElementInstanceVariables for application/json ContentType.
type CreateElementInstanceVariablesJSONRequestBody = SetVariableRequest

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody = GroupCreateRequest

// SearchGroupsJSONRequestBody defines body for SearchGroups for application/json ContentType.
type SearchGroupsJSONRequestBody = GroupSearchQueryRequest

// UpdateGroupJSONRequestBody defines body for UpdateGroup for application/json ContentType.
type UpdateGroupJSONRequestBody = GroupUpdateRequest

// SearchClientsForGroupJSONRequestBody defines body for SearchClientsForGroup for application/json ContentType.
type SearchClientsForGroupJSONRequestBody = GroupClientSearchQueryRequest

// SearchMappingRulesForGroupJSONRequestBody defines body for SearchMappingRulesForGroup for application/json ContentType.
type SearchMappingRulesForGroupJSONRequestBody = MappingRuleSearchQueryRequest

// SearchRolesForGroupJSONRequestBody defines body for SearchRolesForGroup for application/json ContentType.
type SearchRolesForGroupJSONRequestBody = RoleSearchQueryRequest

// SearchUsersForGroupJSONRequestBody defines body for SearchUsersForGroup for application/json ContentType.
type SearchUsersForGroupJSONRequestBody = GroupUserSearchQueryRequest

// SearchIncidentsJSONRequestBody defines body for SearchIncidents for application/json ContentType.
type SearchIncidentsJSONRequestBody = IncidentSearchQuery

// ResolveIncidentJSONRequestBody defines body for ResolveIncident for application/json ContentType.
type ResolveIncidentJSONRequestBody = IncidentResolutionRequest

// ActivateJobsJSONRequestBody defines body for ActivateJobs for application/json ContentType.
type ActivateJobsJSONRequestBody = JobActivationRequest

// SearchJobsJSONRequestBody defines body for SearchJobs for application/json ContentType.
type SearchJobsJSONRequestBody = JobSearchQuery

// UpdateJobJSONRequestBody defines body for UpdateJob for application/json ContentType.
type UpdateJobJSONRequestBody = JobUpdateRequest

// CompleteJobJSONRequestBody defines body for CompleteJob for application/json ContentType.
type CompleteJobJSONRequestBody = JobCompletionRequest

// ThrowJobErrorJSONRequestBody defines body for ThrowJobError for application/json ContentType.
type ThrowJobErrorJSONRequestBody = JobErrorRequest

// FailJobJSONRequestBody defines body for FailJob for application/json ContentType.
type FailJobJSONRequestBody = JobFailRequest

// CreateMappingRuleJSONRequestBody defines body for CreateMappingRule for application/json ContentType.
type CreateMappingRuleJSONRequestBody = MappingRuleCreateRequest

// SearchMappingRuleJSONRequestBody defines body for SearchMappingRule for application/json ContentType.
type SearchMappingRuleJSONRequestBody = MappingRuleSearchQueryRequest

// UpdateMappingRuleJSONRequestBody defines body for UpdateMappingRule for application/json ContentType.
type UpdateMappingRuleJSONRequestBody = MappingRuleUpdateRequest

// SearchMessageSubscriptionsJSONRequestBody defines body for SearchMessageSubscriptions for application/json ContentType.
type SearchMessageSubscriptionsJSONRequestBody = MessageSubscriptionSearchQuery

// CorrelateMessageJSONRequestBody defines body for CorrelateMessage for application/json ContentType.
type CorrelateMessageJSONRequestBody = MessageCorrelationRequest

// PublishMessageJSONRequestBody defines body for PublishMessage for application/json ContentType.
type PublishMessageJSONRequestBody = MessagePublicationRequest

// SearchProcessDefinitionsJSONRequestBody defines body for SearchProcessDefinitions for application/json ContentType.
type SearchProcessDefinitionsJSONRequestBody = ProcessDefinitionSearchQuery

// GetProcessDefinitionStatisticsJSONRequestBody defines body for GetProcessDefinitionStatistics for application/json ContentType.
type GetProcessDefinitionStatisticsJSONRequestBody = ProcessDefinitionElementStatisticsQuery

// CreateProcessInstanceJSONRequestBody defines body for CreateProcessInstance for application/json ContentType.
type CreateProcessInstanceJSONRequestBody = ProcessInstanceCreationInstruction

// CancelProcessInstancesBatchOperationJSONRequestBody defines body for CancelProcessInstancesBatchOperation for application/json ContentType.
type CancelProcessInstancesBatchOperationJSONRequestBody = ProcessInstanceCancellationBatchOperationRequest

// ResolveIncidentsBatchOperationJSONRequestBody defines body for ResolveIncidentsBatchOperation for application/json ContentType.
type ResolveIncidentsBatchOperationJSONRequestBody = ProcessInstanceIncidentResolutionBatchOperationRequest

// MigrateProcessInstancesBatchOperationJSONRequestBody defines body for MigrateProcessInstancesBatchOperation for application/json ContentType.
type MigrateProcessInstancesBatchOperationJSONRequestBody = ProcessInstanceMigrationBatchOperationRequest

// ModifyProcessInstancesBatchOperationJSONRequestBody defines body for ModifyProcessInstancesBatchOperation for application/json ContentType.
type ModifyProcessInstancesBatchOperationJSONRequestBody = ProcessInstanceModificationBatchOperationRequest

// SearchProcessInstancesJSONRequestBody defines body for SearchProcessInstances for application/json ContentType.
type SearchProcessInstancesJSONRequestBody = ProcessInstanceSearchQuery

// CancelProcessInstanceJSONRequestBody defines body for CancelProcessInstance for application/json ContentType.
type CancelProcessInstanceJSONRequestBody = CancelProcessInstanceRequest

// SearchProcessInstanceIncidentsJSONRequestBody defines body for SearchProcessInstanceIncidents for application/json ContentType.
type SearchProcessInstanceIncidentsJSONRequestBody = ProcessInstanceIncidentSearchQuery

// MigrateProcessInstanceJSONRequestBody defines body for MigrateProcessInstance for application/json ContentType.
type MigrateProcessInstanceJSONRequestBody = ProcessInstanceMigrationInstruction

// ModifyProcessInstanceJSONRequestBody defines body for ModifyProcessInstance for application/json ContentType.
type ModifyProcessInstanceJSONRequestBody = ProcessInstanceModificationInstruction

// DeleteResourceJSONRequestBody defines body for DeleteResource for application/json ContentType.
type DeleteResourceJSONRequestBody = DeleteResourceRequest

// CreateRoleJSONRequestBody defines body for CreateRole for application/json ContentType.
type CreateRoleJSONRequestBody = RoleCreateRequest

// SearchRolesJSONRequestBody defines body for SearchRoles for application/json ContentType.
type SearchRolesJSONRequestBody = RoleSearchQueryRequest

// UpdateRoleJSONRequestBody defines body for UpdateRole for application/json ContentType.
type UpdateRoleJSONRequestBody = RoleUpdateRequest

// SearchClientsForRoleJSONRequestBody defines body for SearchClientsForRole for application/json ContentType.
type SearchClientsForRoleJSONRequestBody = RoleClientSearchQueryRequest

// SearchGroupsForRoleJSONRequestBody defines body for SearchGroupsForRole for application/json ContentType.
type SearchGroupsForRoleJSONRequestBody = RoleGroupSearchQueryRequest

// SearchMappingRulesForRoleJSONRequestBody defines body for SearchMappingRulesForRole for application/json ContentType.
type SearchMappingRulesForRoleJSONRequestBody = MappingRuleSearchQueryRequest

// SearchUsersForRoleJSONRequestBody defines body for SearchUsersForRole for application/json ContentType.
type SearchUsersForRoleJSONRequestBody = RoleUserSearchQueryRequest

// CreateAdminUserJSONRequestBody defines body for CreateAdminUser for application/json ContentType.
type CreateAdminUserJSONRequestBody = UserRequest

// BroadcastSignalJSONRequestBody defines body for BroadcastSignal for application/json ContentType.
type BroadcastSignalJSONRequestBody = SignalBroadcastRequest

// CreateTenantJSONRequestBody defines body for CreateTenant for application/json ContentType.
type CreateTenantJSONRequestBody = TenantCreateRequest

// SearchTenantsJSONRequestBody defines body for SearchTenants for application/json ContentType.
type SearchTenantsJSONRequestBody = TenantSearchQueryRequest

// UpdateTenantJSONRequestBody defines body for UpdateTenant for application/json ContentType.
type UpdateTenantJSONRequestBody = TenantUpdateRequest

// SearchClientsForTenantJSONRequestBody defines body for SearchClientsForTenant for application/json ContentType.
type SearchClientsForTenantJSONRequestBody = TenantClientSearchQueryRequest

// SearchGroupIdsForTenantJSONRequestBody defines body for SearchGroupIdsForTenant for application/json ContentType.
type SearchGroupIdsForTenantJSONRequestBody = TenantGroupSearchQueryRequest

// SearchMappingRulesForTenantJSONRequestBody defines body for SearchMappingRulesForTenant for application/json ContentType.
type SearchMappingRulesForTenantJSONRequestBody = MappingRuleSearchQueryRequest

// SearchRolesForTenantJSONRequestBody defines body for SearchRolesForTenant for application/json ContentType.
type SearchRolesForTenantJSONRequestBody = RoleSearchQueryRequest

// SearchUsersForTenantJSONRequestBody defines body for SearchUsersForTenant for application/json ContentType.
type SearchUsersForTenantJSONRequestBody = TenantUserSearchQueryRequest

// SearchUserTasksJSONRequestBody defines body for SearchUserTasks for application/json ContentType.
type SearchUserTasksJSONRequestBody = UserTaskSearchQuery

// UpdateUserTaskJSONRequestBody defines body for UpdateUserTask for application/json ContentType.
type UpdateUserTaskJSONRequestBody = UserTaskUpdateRequest

// AssignUserTaskJSONRequestBody defines body for AssignUserTask for application/json ContentType.
type AssignUserTaskJSONRequestBody = UserTaskAssignmentRequest

// CompleteUserTaskJSONRequestBody defines body for CompleteUserTask for application/json ContentType.
type CompleteUserTaskJSONRequestBody = UserTaskCompletionRequest

// SearchUserTaskVariablesJSONRequestBody defines body for SearchUserTaskVariables for application/json ContentType.
type SearchUserTaskVariablesJSONRequestBody = UserTaskVariableSearchQueryRequest

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = UserRequest

// SearchUsersJSONRequestBody defines body for SearchUsers for application/json ContentType.
type SearchUsersJSONRequestBody = UserSearchQueryRequest

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = UserUpdateRequest

// SearchVariablesJSONRequestBody defines body for SearchVariables for application/json ContentType.
type SearchVariablesJSONRequestBody = VariableSearchQuery

// Getter for additional properties for Changeset. Returns the specified
// element and whether it was found
func (a Changeset) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Changeset
func (a *Changeset) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Changeset to handle AdditionalProperties
func (a *Changeset) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["candidateGroups"]; found {
		err = json.Unmarshal(raw, &a.CandidateGroups)
		if err != nil {
			return fmt.Errorf("error reading 'candidateGroups': %w", err)
		}
		delete(object, "candidateGroups")
	}

	if raw, found := object["candidateUsers"]; found {
		err = json.Unmarshal(raw, &a.CandidateUsers)
		if err != nil {
			return fmt.Errorf("error reading 'candidateUsers': %w", err)
		}
		delete(object, "candidateUsers")
	}

	if raw, found := object["dueDate"]; found {
		err = json.Unmarshal(raw, &a.DueDate)
		if err != nil {
			return fmt.Errorf("error reading 'dueDate': %w", err)
		}
		delete(object, "dueDate")
	}

	if raw, found := object["followUpDate"]; found {
		err = json.Unmarshal(raw, &a.FollowUpDate)
		if err != nil {
			return fmt.Errorf("error reading 'followUpDate': %w", err)
		}
		delete(object, "followUpDate")
	}

	if raw, found := object["priority"]; found {
		err = json.Unmarshal(raw, &a.Priority)
		if err != nil {
			return fmt.Errorf("error reading 'priority': %w", err)
		}
		delete(object, "priority")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Changeset to handle AdditionalProperties
func (a Changeset) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.CandidateGroups != nil {
		object["candidateGroups"], err = json.Marshal(a.CandidateGroups)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'candidateGroups': %w", err)
		}
	}

	if a.CandidateUsers != nil {
		object["candidateUsers"], err = json.Marshal(a.CandidateUsers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'candidateUsers': %w", err)
		}
	}

	if a.DueDate != nil {
		object["dueDate"], err = json.Marshal(a.DueDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dueDate': %w", err)
		}
	}

	if a.FollowUpDate != nil {
		object["followUpDate"], err = json.Marshal(a.FollowUpDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'followUpDate': %w", err)
		}
	}

	if a.Priority != nil {
		object["priority"], err = json.Marshal(a.Priority)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'priority': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsBasicStringFilterProperty0 returns the union data inside the BasicStringFilterProperty as a BasicStringFilterProperty0
func (t BasicStringFilterProperty) AsBasicStringFilterProperty0() (BasicStringFilterProperty0, error) {
	var body BasicStringFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBasicStringFilterProperty0 overwrites any union data inside the BasicStringFilterProperty as the provided BasicStringFilterProperty0
func (t *BasicStringFilterProperty) FromBasicStringFilterProperty0(v BasicStringFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBasicStringFilterProperty0 performs a merge with any union data inside the BasicStringFilterProperty, using the provided BasicStringFilterProperty0
func (t *BasicStringFilterProperty) MergeBasicStringFilterProperty0(v BasicStringFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBasicStringFilter returns the union data inside the BasicStringFilterProperty as a BasicStringFilter
func (t BasicStringFilterProperty) AsBasicStringFilter() (BasicStringFilter, error) {
	var body BasicStringFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBasicStringFilter overwrites any union data inside the BasicStringFilterProperty as the provided BasicStringFilter
func (t *BasicStringFilterProperty) FromBasicStringFilter(v BasicStringFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBasicStringFilter performs a merge with any union data inside the BasicStringFilterProperty, using the provided BasicStringFilter
func (t *BasicStringFilterProperty) MergeBasicStringFilter(v BasicStringFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BasicStringFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BasicStringFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBatchOperationItemStateFilterProperty0 returns the union data inside the BatchOperationItemStateFilterProperty as a BatchOperationItemStateFilterProperty0
func (t BatchOperationItemStateFilterProperty) AsBatchOperationItemStateFilterProperty0() (BatchOperationItemStateFilterProperty0, error) {
	var body BatchOperationItemStateFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBatchOperationItemStateFilterProperty0 overwrites any union data inside the BatchOperationItemStateFilterProperty as the provided BatchOperationItemStateFilterProperty0
func (t *BatchOperationItemStateFilterProperty) FromBatchOperationItemStateFilterProperty0(v BatchOperationItemStateFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBatchOperationItemStateFilterProperty0 performs a merge with any union data inside the BatchOperationItemStateFilterProperty, using the provided BatchOperationItemStateFilterProperty0
func (t *BatchOperationItemStateFilterProperty) MergeBatchOperationItemStateFilterProperty0(v BatchOperationItemStateFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedBatchOperationItemStateFilter returns the union data inside the BatchOperationItemStateFilterProperty as a AdvancedBatchOperationItemStateFilter
func (t BatchOperationItemStateFilterProperty) AsAdvancedBatchOperationItemStateFilter() (AdvancedBatchOperationItemStateFilter, error) {
	var body AdvancedBatchOperationItemStateFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedBatchOperationItemStateFilter overwrites any union data inside the BatchOperationItemStateFilterProperty as the provided AdvancedBatchOperationItemStateFilter
func (t *BatchOperationItemStateFilterProperty) FromAdvancedBatchOperationItemStateFilter(v AdvancedBatchOperationItemStateFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedBatchOperationItemStateFilter performs a merge with any union data inside the BatchOperationItemStateFilterProperty, using the provided AdvancedBatchOperationItemStateFilter
func (t *BatchOperationItemStateFilterProperty) MergeAdvancedBatchOperationItemStateFilter(v AdvancedBatchOperationItemStateFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BatchOperationItemStateFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BatchOperationItemStateFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBatchOperationStateFilterProperty0 returns the union data inside the BatchOperationStateFilterProperty as a BatchOperationStateFilterProperty0
func (t BatchOperationStateFilterProperty) AsBatchOperationStateFilterProperty0() (BatchOperationStateFilterProperty0, error) {
	var body BatchOperationStateFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBatchOperationStateFilterProperty0 overwrites any union data inside the BatchOperationStateFilterProperty as the provided BatchOperationStateFilterProperty0
func (t *BatchOperationStateFilterProperty) FromBatchOperationStateFilterProperty0(v BatchOperationStateFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBatchOperationStateFilterProperty0 performs a merge with any union data inside the BatchOperationStateFilterProperty, using the provided BatchOperationStateFilterProperty0
func (t *BatchOperationStateFilterProperty) MergeBatchOperationStateFilterProperty0(v BatchOperationStateFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedBatchOperationStateFilter returns the union data inside the BatchOperationStateFilterProperty as a AdvancedBatchOperationStateFilter
func (t BatchOperationStateFilterProperty) AsAdvancedBatchOperationStateFilter() (AdvancedBatchOperationStateFilter, error) {
	var body AdvancedBatchOperationStateFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedBatchOperationStateFilter overwrites any union data inside the BatchOperationStateFilterProperty as the provided AdvancedBatchOperationStateFilter
func (t *BatchOperationStateFilterProperty) FromAdvancedBatchOperationStateFilter(v AdvancedBatchOperationStateFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedBatchOperationStateFilter performs a merge with any union data inside the BatchOperationStateFilterProperty, using the provided AdvancedBatchOperationStateFilter
func (t *BatchOperationStateFilterProperty) MergeAdvancedBatchOperationStateFilter(v AdvancedBatchOperationStateFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BatchOperationStateFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BatchOperationStateFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBatchOperationTypeFilterProperty0 returns the union data inside the BatchOperationTypeFilterProperty as a BatchOperationTypeFilterProperty0
func (t BatchOperationTypeFilterProperty) AsBatchOperationTypeFilterProperty0() (BatchOperationTypeFilterProperty0, error) {
	var body BatchOperationTypeFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBatchOperationTypeFilterProperty0 overwrites any union data inside the BatchOperationTypeFilterProperty as the provided BatchOperationTypeFilterProperty0
func (t *BatchOperationTypeFilterProperty) FromBatchOperationTypeFilterProperty0(v BatchOperationTypeFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBatchOperationTypeFilterProperty0 performs a merge with any union data inside the BatchOperationTypeFilterProperty, using the provided BatchOperationTypeFilterProperty0
func (t *BatchOperationTypeFilterProperty) MergeBatchOperationTypeFilterProperty0(v BatchOperationTypeFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedBatchOperationTypeFilter returns the union data inside the BatchOperationTypeFilterProperty as a AdvancedBatchOperationTypeFilter
func (t BatchOperationTypeFilterProperty) AsAdvancedBatchOperationTypeFilter() (AdvancedBatchOperationTypeFilter, error) {
	var body AdvancedBatchOperationTypeFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedBatchOperationTypeFilter overwrites any union data inside the BatchOperationTypeFilterProperty as the provided AdvancedBatchOperationTypeFilter
func (t *BatchOperationTypeFilterProperty) FromAdvancedBatchOperationTypeFilter(v AdvancedBatchOperationTypeFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedBatchOperationTypeFilter performs a merge with any union data inside the BatchOperationTypeFilterProperty, using the provided AdvancedBatchOperationTypeFilter
func (t *BatchOperationTypeFilterProperty) MergeAdvancedBatchOperationTypeFilter(v AdvancedBatchOperationTypeFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BatchOperationTypeFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BatchOperationTypeFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDateTimeFilterProperty0 returns the union data inside the DateTimeFilterProperty as a DateTimeFilterProperty0
func (t DateTimeFilterProperty) AsDateTimeFilterProperty0() (DateTimeFilterProperty0, error) {
	var body DateTimeFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDateTimeFilterProperty0 overwrites any union data inside the DateTimeFilterProperty as the provided DateTimeFilterProperty0
func (t *DateTimeFilterProperty) FromDateTimeFilterProperty0(v DateTimeFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDateTimeFilterProperty0 performs a merge with any union data inside the DateTimeFilterProperty, using the provided DateTimeFilterProperty0
func (t *DateTimeFilterProperty) MergeDateTimeFilterProperty0(v DateTimeFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedDateTimeFilter returns the union data inside the DateTimeFilterProperty as a AdvancedDateTimeFilter
func (t DateTimeFilterProperty) AsAdvancedDateTimeFilter() (AdvancedDateTimeFilter, error) {
	var body AdvancedDateTimeFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedDateTimeFilter overwrites any union data inside the DateTimeFilterProperty as the provided AdvancedDateTimeFilter
func (t *DateTimeFilterProperty) FromAdvancedDateTimeFilter(v AdvancedDateTimeFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedDateTimeFilter performs a merge with any union data inside the DateTimeFilterProperty, using the provided AdvancedDateTimeFilter
func (t *DateTimeFilterProperty) MergeAdvancedDateTimeFilter(v AdvancedDateTimeFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DateTimeFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DateTimeFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDecisionDefinitionKeyFilterProperty0 returns the union data inside the DecisionDefinitionKeyFilterProperty as a DecisionDefinitionKeyFilterProperty0
func (t DecisionDefinitionKeyFilterProperty) AsDecisionDefinitionKeyFilterProperty0() (DecisionDefinitionKeyFilterProperty0, error) {
	var body DecisionDefinitionKeyFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDecisionDefinitionKeyFilterProperty0 overwrites any union data inside the DecisionDefinitionKeyFilterProperty as the provided DecisionDefinitionKeyFilterProperty0
func (t *DecisionDefinitionKeyFilterProperty) FromDecisionDefinitionKeyFilterProperty0(v DecisionDefinitionKeyFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDecisionDefinitionKeyFilterProperty0 performs a merge with any union data inside the DecisionDefinitionKeyFilterProperty, using the provided DecisionDefinitionKeyFilterProperty0
func (t *DecisionDefinitionKeyFilterProperty) MergeDecisionDefinitionKeyFilterProperty0(v DecisionDefinitionKeyFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedDecisionDefinitionKeyFilter returns the union data inside the DecisionDefinitionKeyFilterProperty as a AdvancedDecisionDefinitionKeyFilter
func (t DecisionDefinitionKeyFilterProperty) AsAdvancedDecisionDefinitionKeyFilter() (AdvancedDecisionDefinitionKeyFilter, error) {
	var body AdvancedDecisionDefinitionKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedDecisionDefinitionKeyFilter overwrites any union data inside the DecisionDefinitionKeyFilterProperty as the provided AdvancedDecisionDefinitionKeyFilter
func (t *DecisionDefinitionKeyFilterProperty) FromAdvancedDecisionDefinitionKeyFilter(v AdvancedDecisionDefinitionKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedDecisionDefinitionKeyFilter performs a merge with any union data inside the DecisionDefinitionKeyFilterProperty, using the provided AdvancedDecisionDefinitionKeyFilter
func (t *DecisionDefinitionKeyFilterProperty) MergeAdvancedDecisionDefinitionKeyFilter(v AdvancedDecisionDefinitionKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DecisionDefinitionKeyFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DecisionDefinitionKeyFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDecisionEvaluationById returns the union data inside the DecisionEvaluationInstruction as a DecisionEvaluationById
func (t DecisionEvaluationInstruction) AsDecisionEvaluationById() (DecisionEvaluationById, error) {
	var body DecisionEvaluationById
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDecisionEvaluationById overwrites any union data inside the DecisionEvaluationInstruction as the provided DecisionEvaluationById
func (t *DecisionEvaluationInstruction) FromDecisionEvaluationById(v DecisionEvaluationById) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDecisionEvaluationById performs a merge with any union data inside the DecisionEvaluationInstruction, using the provided DecisionEvaluationById
func (t *DecisionEvaluationInstruction) MergeDecisionEvaluationById(v DecisionEvaluationById) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDecisionEvaluationByKey returns the union data inside the DecisionEvaluationInstruction as a DecisionEvaluationByKey
func (t DecisionEvaluationInstruction) AsDecisionEvaluationByKey() (DecisionEvaluationByKey, error) {
	var body DecisionEvaluationByKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDecisionEvaluationByKey overwrites any union data inside the DecisionEvaluationInstruction as the provided DecisionEvaluationByKey
func (t *DecisionEvaluationInstruction) FromDecisionEvaluationByKey(v DecisionEvaluationByKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDecisionEvaluationByKey performs a merge with any union data inside the DecisionEvaluationInstruction, using the provided DecisionEvaluationByKey
func (t *DecisionEvaluationInstruction) MergeDecisionEvaluationByKey(v DecisionEvaluationByKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DecisionEvaluationInstruction) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DecisionEvaluationInstruction) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsElementInstanceKeyFilterProperty0 returns the union data inside the ElementInstanceKeyFilterProperty as a ElementInstanceKeyFilterProperty0
func (t ElementInstanceKeyFilterProperty) AsElementInstanceKeyFilterProperty0() (ElementInstanceKeyFilterProperty0, error) {
	var body ElementInstanceKeyFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromElementInstanceKeyFilterProperty0 overwrites any union data inside the ElementInstanceKeyFilterProperty as the provided ElementInstanceKeyFilterProperty0
func (t *ElementInstanceKeyFilterProperty) FromElementInstanceKeyFilterProperty0(v ElementInstanceKeyFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeElementInstanceKeyFilterProperty0 performs a merge with any union data inside the ElementInstanceKeyFilterProperty, using the provided ElementInstanceKeyFilterProperty0
func (t *ElementInstanceKeyFilterProperty) MergeElementInstanceKeyFilterProperty0(v ElementInstanceKeyFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedElementInstanceKeyFilter returns the union data inside the ElementInstanceKeyFilterProperty as a AdvancedElementInstanceKeyFilter
func (t ElementInstanceKeyFilterProperty) AsAdvancedElementInstanceKeyFilter() (AdvancedElementInstanceKeyFilter, error) {
	var body AdvancedElementInstanceKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedElementInstanceKeyFilter overwrites any union data inside the ElementInstanceKeyFilterProperty as the provided AdvancedElementInstanceKeyFilter
func (t *ElementInstanceKeyFilterProperty) FromAdvancedElementInstanceKeyFilter(v AdvancedElementInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedElementInstanceKeyFilter performs a merge with any union data inside the ElementInstanceKeyFilterProperty, using the provided AdvancedElementInstanceKeyFilter
func (t *ElementInstanceKeyFilterProperty) MergeAdvancedElementInstanceKeyFilter(v AdvancedElementInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ElementInstanceKeyFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ElementInstanceKeyFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsElementInstanceStateFilterProperty0 returns the union data inside the ElementInstanceStateFilterProperty as a ElementInstanceStateFilterProperty0
func (t ElementInstanceStateFilterProperty) AsElementInstanceStateFilterProperty0() (ElementInstanceStateFilterProperty0, error) {
	var body ElementInstanceStateFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromElementInstanceStateFilterProperty0 overwrites any union data inside the ElementInstanceStateFilterProperty as the provided ElementInstanceStateFilterProperty0
func (t *ElementInstanceStateFilterProperty) FromElementInstanceStateFilterProperty0(v ElementInstanceStateFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeElementInstanceStateFilterProperty0 performs a merge with any union data inside the ElementInstanceStateFilterProperty, using the provided ElementInstanceStateFilterProperty0
func (t *ElementInstanceStateFilterProperty) MergeElementInstanceStateFilterProperty0(v ElementInstanceStateFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedElementInstanceStateFilter returns the union data inside the ElementInstanceStateFilterProperty as a AdvancedElementInstanceStateFilter
func (t ElementInstanceStateFilterProperty) AsAdvancedElementInstanceStateFilter() (AdvancedElementInstanceStateFilter, error) {
	var body AdvancedElementInstanceStateFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedElementInstanceStateFilter overwrites any union data inside the ElementInstanceStateFilterProperty as the provided AdvancedElementInstanceStateFilter
func (t *ElementInstanceStateFilterProperty) FromAdvancedElementInstanceStateFilter(v AdvancedElementInstanceStateFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedElementInstanceStateFilter performs a merge with any union data inside the ElementInstanceStateFilterProperty, using the provided AdvancedElementInstanceStateFilter
func (t *ElementInstanceStateFilterProperty) MergeAdvancedElementInstanceStateFilter(v AdvancedElementInstanceStateFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ElementInstanceStateFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ElementInstanceStateFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIntegerFilterProperty0 returns the union data inside the IntegerFilterProperty as a IntegerFilterProperty0
func (t IntegerFilterProperty) AsIntegerFilterProperty0() (IntegerFilterProperty0, error) {
	var body IntegerFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerFilterProperty0 overwrites any union data inside the IntegerFilterProperty as the provided IntegerFilterProperty0
func (t *IntegerFilterProperty) FromIntegerFilterProperty0(v IntegerFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerFilterProperty0 performs a merge with any union data inside the IntegerFilterProperty, using the provided IntegerFilterProperty0
func (t *IntegerFilterProperty) MergeIntegerFilterProperty0(v IntegerFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedIntegerFilter returns the union data inside the IntegerFilterProperty as a AdvancedIntegerFilter
func (t IntegerFilterProperty) AsAdvancedIntegerFilter() (AdvancedIntegerFilter, error) {
	var body AdvancedIntegerFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedIntegerFilter overwrites any union data inside the IntegerFilterProperty as the provided AdvancedIntegerFilter
func (t *IntegerFilterProperty) FromAdvancedIntegerFilter(v AdvancedIntegerFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedIntegerFilter performs a merge with any union data inside the IntegerFilterProperty, using the provided AdvancedIntegerFilter
func (t *IntegerFilterProperty) MergeAdvancedIntegerFilter(v AdvancedIntegerFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IntegerFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IntegerFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJobKeyFilterProperty0 returns the union data inside the JobKeyFilterProperty as a JobKeyFilterProperty0
func (t JobKeyFilterProperty) AsJobKeyFilterProperty0() (JobKeyFilterProperty0, error) {
	var body JobKeyFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJobKeyFilterProperty0 overwrites any union data inside the JobKeyFilterProperty as the provided JobKeyFilterProperty0
func (t *JobKeyFilterProperty) FromJobKeyFilterProperty0(v JobKeyFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJobKeyFilterProperty0 performs a merge with any union data inside the JobKeyFilterProperty, using the provided JobKeyFilterProperty0
func (t *JobKeyFilterProperty) MergeJobKeyFilterProperty0(v JobKeyFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedJobKeyFilter returns the union data inside the JobKeyFilterProperty as a AdvancedJobKeyFilter
func (t JobKeyFilterProperty) AsAdvancedJobKeyFilter() (AdvancedJobKeyFilter, error) {
	var body AdvancedJobKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedJobKeyFilter overwrites any union data inside the JobKeyFilterProperty as the provided AdvancedJobKeyFilter
func (t *JobKeyFilterProperty) FromAdvancedJobKeyFilter(v AdvancedJobKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedJobKeyFilter performs a merge with any union data inside the JobKeyFilterProperty, using the provided AdvancedJobKeyFilter
func (t *JobKeyFilterProperty) MergeAdvancedJobKeyFilter(v AdvancedJobKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JobKeyFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *JobKeyFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJobKindFilterProperty0 returns the union data inside the JobKindFilterProperty as a JobKindFilterProperty0
func (t JobKindFilterProperty) AsJobKindFilterProperty0() (JobKindFilterProperty0, error) {
	var body JobKindFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJobKindFilterProperty0 overwrites any union data inside the JobKindFilterProperty as the provided JobKindFilterProperty0
func (t *JobKindFilterProperty) FromJobKindFilterProperty0(v JobKindFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJobKindFilterProperty0 performs a merge with any union data inside the JobKindFilterProperty, using the provided JobKindFilterProperty0
func (t *JobKindFilterProperty) MergeJobKindFilterProperty0(v JobKindFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedJobKindFilter returns the union data inside the JobKindFilterProperty as a AdvancedJobKindFilter
func (t JobKindFilterProperty) AsAdvancedJobKindFilter() (AdvancedJobKindFilter, error) {
	var body AdvancedJobKindFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedJobKindFilter overwrites any union data inside the JobKindFilterProperty as the provided AdvancedJobKindFilter
func (t *JobKindFilterProperty) FromAdvancedJobKindFilter(v AdvancedJobKindFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedJobKindFilter performs a merge with any union data inside the JobKindFilterProperty, using the provided AdvancedJobKindFilter
func (t *JobKindFilterProperty) MergeAdvancedJobKindFilter(v AdvancedJobKindFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JobKindFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *JobKindFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJobListenerEventTypeFilterProperty0 returns the union data inside the JobListenerEventTypeFilterProperty as a JobListenerEventTypeFilterProperty0
func (t JobListenerEventTypeFilterProperty) AsJobListenerEventTypeFilterProperty0() (JobListenerEventTypeFilterProperty0, error) {
	var body JobListenerEventTypeFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJobListenerEventTypeFilterProperty0 overwrites any union data inside the JobListenerEventTypeFilterProperty as the provided JobListenerEventTypeFilterProperty0
func (t *JobListenerEventTypeFilterProperty) FromJobListenerEventTypeFilterProperty0(v JobListenerEventTypeFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJobListenerEventTypeFilterProperty0 performs a merge with any union data inside the JobListenerEventTypeFilterProperty, using the provided JobListenerEventTypeFilterProperty0
func (t *JobListenerEventTypeFilterProperty) MergeJobListenerEventTypeFilterProperty0(v JobListenerEventTypeFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedJobListenerEventTypeFilter returns the union data inside the JobListenerEventTypeFilterProperty as a AdvancedJobListenerEventTypeFilter
func (t JobListenerEventTypeFilterProperty) AsAdvancedJobListenerEventTypeFilter() (AdvancedJobListenerEventTypeFilter, error) {
	var body AdvancedJobListenerEventTypeFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedJobListenerEventTypeFilter overwrites any union data inside the JobListenerEventTypeFilterProperty as the provided AdvancedJobListenerEventTypeFilter
func (t *JobListenerEventTypeFilterProperty) FromAdvancedJobListenerEventTypeFilter(v AdvancedJobListenerEventTypeFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedJobListenerEventTypeFilter performs a merge with any union data inside the JobListenerEventTypeFilterProperty, using the provided AdvancedJobListenerEventTypeFilter
func (t *JobListenerEventTypeFilterProperty) MergeAdvancedJobListenerEventTypeFilter(v AdvancedJobListenerEventTypeFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JobListenerEventTypeFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *JobListenerEventTypeFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJobResultUserTask returns the union data inside the JobResult as a JobResultUserTask
func (t JobResult) AsJobResultUserTask() (JobResultUserTask, error) {
	var body JobResultUserTask
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJobResultUserTask overwrites any union data inside the JobResult as the provided JobResultUserTask
func (t *JobResult) FromJobResultUserTask(v JobResultUserTask) error {
	t.Type = "userTask"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJobResultUserTask performs a merge with any union data inside the JobResult, using the provided JobResultUserTask
func (t *JobResult) MergeJobResultUserTask(v JobResultUserTask) error {
	t.Type = "userTask"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJobResultAdHocSubProcess returns the union data inside the JobResult as a JobResultAdHocSubProcess
func (t JobResult) AsJobResultAdHocSubProcess() (JobResultAdHocSubProcess, error) {
	var body JobResultAdHocSubProcess
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJobResultAdHocSubProcess overwrites any union data inside the JobResult as the provided JobResultAdHocSubProcess
func (t *JobResult) FromJobResultAdHocSubProcess(v JobResultAdHocSubProcess) error {
	t.Type = "adHocSubProcess"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJobResultAdHocSubProcess performs a merge with any union data inside the JobResult, using the provided JobResultAdHocSubProcess
func (t *JobResult) MergeJobResultAdHocSubProcess(v JobResultAdHocSubProcess) error {
	t.Type = "adHocSubProcess"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JobResult) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t JobResult) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "adHocSubProcess":
		return t.AsJobResultAdHocSubProcess()
	case "userTask":
		return t.AsJobResultUserTask()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t JobResult) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *JobResult) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsJobStateFilterProperty0 returns the union data inside the JobStateFilterProperty as a JobStateFilterProperty0
func (t JobStateFilterProperty) AsJobStateFilterProperty0() (JobStateFilterProperty0, error) {
	var body JobStateFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJobStateFilterProperty0 overwrites any union data inside the JobStateFilterProperty as the provided JobStateFilterProperty0
func (t *JobStateFilterProperty) FromJobStateFilterProperty0(v JobStateFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJobStateFilterProperty0 performs a merge with any union data inside the JobStateFilterProperty, using the provided JobStateFilterProperty0
func (t *JobStateFilterProperty) MergeJobStateFilterProperty0(v JobStateFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedJobStateFilter returns the union data inside the JobStateFilterProperty as a AdvancedJobStateFilter
func (t JobStateFilterProperty) AsAdvancedJobStateFilter() (AdvancedJobStateFilter, error) {
	var body AdvancedJobStateFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedJobStateFilter overwrites any union data inside the JobStateFilterProperty as the provided AdvancedJobStateFilter
func (t *JobStateFilterProperty) FromAdvancedJobStateFilter(v AdvancedJobStateFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedJobStateFilter performs a merge with any union data inside the JobStateFilterProperty, using the provided AdvancedJobStateFilter
func (t *JobStateFilterProperty) MergeAdvancedJobStateFilter(v AdvancedJobStateFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JobStateFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *JobStateFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMessageSubscriptionKeyFilterProperty0 returns the union data inside the MessageSubscriptionKeyFilterProperty as a MessageSubscriptionKeyFilterProperty0
func (t MessageSubscriptionKeyFilterProperty) AsMessageSubscriptionKeyFilterProperty0() (MessageSubscriptionKeyFilterProperty0, error) {
	var body MessageSubscriptionKeyFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageSubscriptionKeyFilterProperty0 overwrites any union data inside the MessageSubscriptionKeyFilterProperty as the provided MessageSubscriptionKeyFilterProperty0
func (t *MessageSubscriptionKeyFilterProperty) FromMessageSubscriptionKeyFilterProperty0(v MessageSubscriptionKeyFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageSubscriptionKeyFilterProperty0 performs a merge with any union data inside the MessageSubscriptionKeyFilterProperty, using the provided MessageSubscriptionKeyFilterProperty0
func (t *MessageSubscriptionKeyFilterProperty) MergeMessageSubscriptionKeyFilterProperty0(v MessageSubscriptionKeyFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedMessageSubscriptionKeyFilter returns the union data inside the MessageSubscriptionKeyFilterProperty as a AdvancedMessageSubscriptionKeyFilter
func (t MessageSubscriptionKeyFilterProperty) AsAdvancedMessageSubscriptionKeyFilter() (AdvancedMessageSubscriptionKeyFilter, error) {
	var body AdvancedMessageSubscriptionKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedMessageSubscriptionKeyFilter overwrites any union data inside the MessageSubscriptionKeyFilterProperty as the provided AdvancedMessageSubscriptionKeyFilter
func (t *MessageSubscriptionKeyFilterProperty) FromAdvancedMessageSubscriptionKeyFilter(v AdvancedMessageSubscriptionKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedMessageSubscriptionKeyFilter performs a merge with any union data inside the MessageSubscriptionKeyFilterProperty, using the provided AdvancedMessageSubscriptionKeyFilter
func (t *MessageSubscriptionKeyFilterProperty) MergeAdvancedMessageSubscriptionKeyFilter(v AdvancedMessageSubscriptionKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MessageSubscriptionKeyFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MessageSubscriptionKeyFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMessageSubscriptionStateFilterProperty0 returns the union data inside the MessageSubscriptionStateFilterProperty as a MessageSubscriptionStateFilterProperty0
func (t MessageSubscriptionStateFilterProperty) AsMessageSubscriptionStateFilterProperty0() (MessageSubscriptionStateFilterProperty0, error) {
	var body MessageSubscriptionStateFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageSubscriptionStateFilterProperty0 overwrites any union data inside the MessageSubscriptionStateFilterProperty as the provided MessageSubscriptionStateFilterProperty0
func (t *MessageSubscriptionStateFilterProperty) FromMessageSubscriptionStateFilterProperty0(v MessageSubscriptionStateFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageSubscriptionStateFilterProperty0 performs a merge with any union data inside the MessageSubscriptionStateFilterProperty, using the provided MessageSubscriptionStateFilterProperty0
func (t *MessageSubscriptionStateFilterProperty) MergeMessageSubscriptionStateFilterProperty0(v MessageSubscriptionStateFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedMessageSubscriptionStateFilter returns the union data inside the MessageSubscriptionStateFilterProperty as a AdvancedMessageSubscriptionStateFilter
func (t MessageSubscriptionStateFilterProperty) AsAdvancedMessageSubscriptionStateFilter() (AdvancedMessageSubscriptionStateFilter, error) {
	var body AdvancedMessageSubscriptionStateFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedMessageSubscriptionStateFilter overwrites any union data inside the MessageSubscriptionStateFilterProperty as the provided AdvancedMessageSubscriptionStateFilter
func (t *MessageSubscriptionStateFilterProperty) FromAdvancedMessageSubscriptionStateFilter(v AdvancedMessageSubscriptionStateFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedMessageSubscriptionStateFilter performs a merge with any union data inside the MessageSubscriptionStateFilterProperty, using the provided AdvancedMessageSubscriptionStateFilter
func (t *MessageSubscriptionStateFilterProperty) MergeAdvancedMessageSubscriptionStateFilter(v AdvancedMessageSubscriptionStateFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MessageSubscriptionStateFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MessageSubscriptionStateFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProcessDefinitionKeyFilterProperty0 returns the union data inside the ProcessDefinitionKeyFilterProperty as a ProcessDefinitionKeyFilterProperty0
func (t ProcessDefinitionKeyFilterProperty) AsProcessDefinitionKeyFilterProperty0() (ProcessDefinitionKeyFilterProperty0, error) {
	var body ProcessDefinitionKeyFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessDefinitionKeyFilterProperty0 overwrites any union data inside the ProcessDefinitionKeyFilterProperty as the provided ProcessDefinitionKeyFilterProperty0
func (t *ProcessDefinitionKeyFilterProperty) FromProcessDefinitionKeyFilterProperty0(v ProcessDefinitionKeyFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessDefinitionKeyFilterProperty0 performs a merge with any union data inside the ProcessDefinitionKeyFilterProperty, using the provided ProcessDefinitionKeyFilterProperty0
func (t *ProcessDefinitionKeyFilterProperty) MergeProcessDefinitionKeyFilterProperty0(v ProcessDefinitionKeyFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedProcessDefinitionKeyFilter returns the union data inside the ProcessDefinitionKeyFilterProperty as a AdvancedProcessDefinitionKeyFilter
func (t ProcessDefinitionKeyFilterProperty) AsAdvancedProcessDefinitionKeyFilter() (AdvancedProcessDefinitionKeyFilter, error) {
	var body AdvancedProcessDefinitionKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedProcessDefinitionKeyFilter overwrites any union data inside the ProcessDefinitionKeyFilterProperty as the provided AdvancedProcessDefinitionKeyFilter
func (t *ProcessDefinitionKeyFilterProperty) FromAdvancedProcessDefinitionKeyFilter(v AdvancedProcessDefinitionKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedProcessDefinitionKeyFilter performs a merge with any union data inside the ProcessDefinitionKeyFilterProperty, using the provided AdvancedProcessDefinitionKeyFilter
func (t *ProcessDefinitionKeyFilterProperty) MergeAdvancedProcessDefinitionKeyFilter(v AdvancedProcessDefinitionKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ProcessDefinitionKeyFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ProcessDefinitionKeyFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProcessInstanceCreationInstructionById returns the union data inside the ProcessInstanceCreationInstruction as a ProcessInstanceCreationInstructionById
func (t ProcessInstanceCreationInstruction) AsProcessInstanceCreationInstructionById() (ProcessInstanceCreationInstructionById, error) {
	var body ProcessInstanceCreationInstructionById
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessInstanceCreationInstructionById overwrites any union data inside the ProcessInstanceCreationInstruction as the provided ProcessInstanceCreationInstructionById
func (t *ProcessInstanceCreationInstruction) FromProcessInstanceCreationInstructionById(v ProcessInstanceCreationInstructionById) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessInstanceCreationInstructionById performs a merge with any union data inside the ProcessInstanceCreationInstruction, using the provided ProcessInstanceCreationInstructionById
func (t *ProcessInstanceCreationInstruction) MergeProcessInstanceCreationInstructionById(v ProcessInstanceCreationInstructionById) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsProcessInstanceCreationInstructionByKey returns the union data inside the ProcessInstanceCreationInstruction as a ProcessInstanceCreationInstructionByKey
func (t ProcessInstanceCreationInstruction) AsProcessInstanceCreationInstructionByKey() (ProcessInstanceCreationInstructionByKey, error) {
	var body ProcessInstanceCreationInstructionByKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessInstanceCreationInstructionByKey overwrites any union data inside the ProcessInstanceCreationInstruction as the provided ProcessInstanceCreationInstructionByKey
func (t *ProcessInstanceCreationInstruction) FromProcessInstanceCreationInstructionByKey(v ProcessInstanceCreationInstructionByKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessInstanceCreationInstructionByKey performs a merge with any union data inside the ProcessInstanceCreationInstruction, using the provided ProcessInstanceCreationInstructionByKey
func (t *ProcessInstanceCreationInstruction) MergeProcessInstanceCreationInstructionByKey(v ProcessInstanceCreationInstructionByKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ProcessInstanceCreationInstruction) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ProcessInstanceCreationInstruction) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProcessInstanceCreationTerminateInstruction returns the union data inside the ProcessInstanceCreationRuntimeInstruction as a ProcessInstanceCreationTerminateInstruction
func (t ProcessInstanceCreationRuntimeInstruction) AsProcessInstanceCreationTerminateInstruction() (ProcessInstanceCreationTerminateInstruction, error) {
	var body ProcessInstanceCreationTerminateInstruction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessInstanceCreationTerminateInstruction overwrites any union data inside the ProcessInstanceCreationRuntimeInstruction as the provided ProcessInstanceCreationTerminateInstruction
func (t *ProcessInstanceCreationRuntimeInstruction) FromProcessInstanceCreationTerminateInstruction(v ProcessInstanceCreationTerminateInstruction) error {
	t.Type = "TERMINATE_PROCESS_INSTANCE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessInstanceCreationTerminateInstruction performs a merge with any union data inside the ProcessInstanceCreationRuntimeInstruction, using the provided ProcessInstanceCreationTerminateInstruction
func (t *ProcessInstanceCreationRuntimeInstruction) MergeProcessInstanceCreationTerminateInstruction(v ProcessInstanceCreationTerminateInstruction) error {
	t.Type = "TERMINATE_PROCESS_INSTANCE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ProcessInstanceCreationRuntimeInstruction) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ProcessInstanceCreationRuntimeInstruction) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "TERMINATE_PROCESS_INSTANCE":
		return t.AsProcessInstanceCreationTerminateInstruction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ProcessInstanceCreationRuntimeInstruction) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ProcessInstanceCreationRuntimeInstruction) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsProcessInstanceKeyFilterProperty0 returns the union data inside the ProcessInstanceKeyFilterProperty as a ProcessInstanceKeyFilterProperty0
func (t ProcessInstanceKeyFilterProperty) AsProcessInstanceKeyFilterProperty0() (ProcessInstanceKeyFilterProperty0, error) {
	var body ProcessInstanceKeyFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessInstanceKeyFilterProperty0 overwrites any union data inside the ProcessInstanceKeyFilterProperty as the provided ProcessInstanceKeyFilterProperty0
func (t *ProcessInstanceKeyFilterProperty) FromProcessInstanceKeyFilterProperty0(v ProcessInstanceKeyFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessInstanceKeyFilterProperty0 performs a merge with any union data inside the ProcessInstanceKeyFilterProperty, using the provided ProcessInstanceKeyFilterProperty0
func (t *ProcessInstanceKeyFilterProperty) MergeProcessInstanceKeyFilterProperty0(v ProcessInstanceKeyFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedProcessInstanceKeyFilter returns the union data inside the ProcessInstanceKeyFilterProperty as a AdvancedProcessInstanceKeyFilter
func (t ProcessInstanceKeyFilterProperty) AsAdvancedProcessInstanceKeyFilter() (AdvancedProcessInstanceKeyFilter, error) {
	var body AdvancedProcessInstanceKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedProcessInstanceKeyFilter overwrites any union data inside the ProcessInstanceKeyFilterProperty as the provided AdvancedProcessInstanceKeyFilter
func (t *ProcessInstanceKeyFilterProperty) FromAdvancedProcessInstanceKeyFilter(v AdvancedProcessInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedProcessInstanceKeyFilter performs a merge with any union data inside the ProcessInstanceKeyFilterProperty, using the provided AdvancedProcessInstanceKeyFilter
func (t *ProcessInstanceKeyFilterProperty) MergeAdvancedProcessInstanceKeyFilter(v AdvancedProcessInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ProcessInstanceKeyFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ProcessInstanceKeyFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0 returns the union data inside the ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey as a ProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0
func (t ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey) AsProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0() (ProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0, error) {
	var body ProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0 overwrites any union data inside the ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey as the provided ProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0
func (t *ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey) FromProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0(v ProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0 performs a merge with any union data inside the ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey, using the provided ProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0
func (t *ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey) MergeProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0(v ProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsElementInstanceKey returns the union data inside the ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey as a ElementInstanceKey
func (t ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey) AsElementInstanceKey() (ElementInstanceKey, error) {
	var body ElementInstanceKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromElementInstanceKey overwrites any union data inside the ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey as the provided ElementInstanceKey
func (t *ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey) FromElementInstanceKey(v ElementInstanceKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeElementInstanceKey performs a merge with any union data inside the ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey, using the provided ElementInstanceKey
func (t *ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey) MergeElementInstanceKey(v ElementInstanceKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProcessInstanceStateFilterProperty0 returns the union data inside the ProcessInstanceStateFilterProperty as a ProcessInstanceStateFilterProperty0
func (t ProcessInstanceStateFilterProperty) AsProcessInstanceStateFilterProperty0() (ProcessInstanceStateFilterProperty0, error) {
	var body ProcessInstanceStateFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessInstanceStateFilterProperty0 overwrites any union data inside the ProcessInstanceStateFilterProperty as the provided ProcessInstanceStateFilterProperty0
func (t *ProcessInstanceStateFilterProperty) FromProcessInstanceStateFilterProperty0(v ProcessInstanceStateFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessInstanceStateFilterProperty0 performs a merge with any union data inside the ProcessInstanceStateFilterProperty, using the provided ProcessInstanceStateFilterProperty0
func (t *ProcessInstanceStateFilterProperty) MergeProcessInstanceStateFilterProperty0(v ProcessInstanceStateFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedProcessInstanceStateFilter returns the union data inside the ProcessInstanceStateFilterProperty as a AdvancedProcessInstanceStateFilter
func (t ProcessInstanceStateFilterProperty) AsAdvancedProcessInstanceStateFilter() (AdvancedProcessInstanceStateFilter, error) {
	var body AdvancedProcessInstanceStateFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedProcessInstanceStateFilter overwrites any union data inside the ProcessInstanceStateFilterProperty as the provided AdvancedProcessInstanceStateFilter
func (t *ProcessInstanceStateFilterProperty) FromAdvancedProcessInstanceStateFilter(v AdvancedProcessInstanceStateFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedProcessInstanceStateFilter performs a merge with any union data inside the ProcessInstanceStateFilterProperty, using the provided AdvancedProcessInstanceStateFilter
func (t *ProcessInstanceStateFilterProperty) MergeAdvancedProcessInstanceStateFilter(v AdvancedProcessInstanceStateFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ProcessInstanceStateFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ProcessInstanceStateFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsScopeKeyFilterProperty0 returns the union data inside the ScopeKeyFilterProperty as a ScopeKeyFilterProperty0
func (t ScopeKeyFilterProperty) AsScopeKeyFilterProperty0() (ScopeKeyFilterProperty0, error) {
	var body ScopeKeyFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScopeKeyFilterProperty0 overwrites any union data inside the ScopeKeyFilterProperty as the provided ScopeKeyFilterProperty0
func (t *ScopeKeyFilterProperty) FromScopeKeyFilterProperty0(v ScopeKeyFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScopeKeyFilterProperty0 performs a merge with any union data inside the ScopeKeyFilterProperty, using the provided ScopeKeyFilterProperty0
func (t *ScopeKeyFilterProperty) MergeScopeKeyFilterProperty0(v ScopeKeyFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedScopeKeyFilter returns the union data inside the ScopeKeyFilterProperty as a AdvancedScopeKeyFilter
func (t ScopeKeyFilterProperty) AsAdvancedScopeKeyFilter() (AdvancedScopeKeyFilter, error) {
	var body AdvancedScopeKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedScopeKeyFilter overwrites any union data inside the ScopeKeyFilterProperty as the provided AdvancedScopeKeyFilter
func (t *ScopeKeyFilterProperty) FromAdvancedScopeKeyFilter(v AdvancedScopeKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedScopeKeyFilter performs a merge with any union data inside the ScopeKeyFilterProperty, using the provided AdvancedScopeKeyFilter
func (t *ScopeKeyFilterProperty) MergeAdvancedScopeKeyFilter(v AdvancedScopeKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ScopeKeyFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScopeKeyFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOffsetPagination returns the union data inside the SearchQueryPageRequest as a OffsetPagination
func (t SearchQueryPageRequest) AsOffsetPagination() (OffsetPagination, error) {
	var body OffsetPagination
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOffsetPagination overwrites any union data inside the SearchQueryPageRequest as the provided OffsetPagination
func (t *SearchQueryPageRequest) FromOffsetPagination(v OffsetPagination) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOffsetPagination performs a merge with any union data inside the SearchQueryPageRequest, using the provided OffsetPagination
func (t *SearchQueryPageRequest) MergeOffsetPagination(v OffsetPagination) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCursorForwardPagination returns the union data inside the SearchQueryPageRequest as a CursorForwardPagination
func (t SearchQueryPageRequest) AsCursorForwardPagination() (CursorForwardPagination, error) {
	var body CursorForwardPagination
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCursorForwardPagination overwrites any union data inside the SearchQueryPageRequest as the provided CursorForwardPagination
func (t *SearchQueryPageRequest) FromCursorForwardPagination(v CursorForwardPagination) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCursorForwardPagination performs a merge with any union data inside the SearchQueryPageRequest, using the provided CursorForwardPagination
func (t *SearchQueryPageRequest) MergeCursorForwardPagination(v CursorForwardPagination) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCursorBackwardPagination returns the union data inside the SearchQueryPageRequest as a CursorBackwardPagination
func (t SearchQueryPageRequest) AsCursorBackwardPagination() (CursorBackwardPagination, error) {
	var body CursorBackwardPagination
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCursorBackwardPagination overwrites any union data inside the SearchQueryPageRequest as the provided CursorBackwardPagination
func (t *SearchQueryPageRequest) FromCursorBackwardPagination(v CursorBackwardPagination) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCursorBackwardPagination performs a merge with any union data inside the SearchQueryPageRequest, using the provided CursorBackwardPagination
func (t *SearchQueryPageRequest) MergeCursorBackwardPagination(v CursorBackwardPagination) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SearchQueryPageRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SearchQueryPageRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStringFilterProperty0 returns the union data inside the StringFilterProperty as a StringFilterProperty0
func (t StringFilterProperty) AsStringFilterProperty0() (StringFilterProperty0, error) {
	var body StringFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStringFilterProperty0 overwrites any union data inside the StringFilterProperty as the provided StringFilterProperty0
func (t *StringFilterProperty) FromStringFilterProperty0(v StringFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStringFilterProperty0 performs a merge with any union data inside the StringFilterProperty, using the provided StringFilterProperty0
func (t *StringFilterProperty) MergeStringFilterProperty0(v StringFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedStringFilter returns the union data inside the StringFilterProperty as a AdvancedStringFilter
func (t StringFilterProperty) AsAdvancedStringFilter() (AdvancedStringFilter, error) {
	var body AdvancedStringFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedStringFilter overwrites any union data inside the StringFilterProperty as the provided AdvancedStringFilter
func (t *StringFilterProperty) FromAdvancedStringFilter(v AdvancedStringFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedStringFilter performs a merge with any union data inside the StringFilterProperty, using the provided AdvancedStringFilter
func (t *StringFilterProperty) MergeAdvancedStringFilter(v AdvancedStringFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StringFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StringFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUserTaskStateFilterProperty0 returns the union data inside the UserTaskStateFilterProperty as a UserTaskStateFilterProperty0
func (t UserTaskStateFilterProperty) AsUserTaskStateFilterProperty0() (UserTaskStateFilterProperty0, error) {
	var body UserTaskStateFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserTaskStateFilterProperty0 overwrites any union data inside the UserTaskStateFilterProperty as the provided UserTaskStateFilterProperty0
func (t *UserTaskStateFilterProperty) FromUserTaskStateFilterProperty0(v UserTaskStateFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserTaskStateFilterProperty0 performs a merge with any union data inside the UserTaskStateFilterProperty, using the provided UserTaskStateFilterProperty0
func (t *UserTaskStateFilterProperty) MergeUserTaskStateFilterProperty0(v UserTaskStateFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedUserTaskStateFilter returns the union data inside the UserTaskStateFilterProperty as a AdvancedUserTaskStateFilter
func (t UserTaskStateFilterProperty) AsAdvancedUserTaskStateFilter() (AdvancedUserTaskStateFilter, error) {
	var body AdvancedUserTaskStateFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedUserTaskStateFilter overwrites any union data inside the UserTaskStateFilterProperty as the provided AdvancedUserTaskStateFilter
func (t *UserTaskStateFilterProperty) FromAdvancedUserTaskStateFilter(v AdvancedUserTaskStateFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedUserTaskStateFilter performs a merge with any union data inside the UserTaskStateFilterProperty, using the provided AdvancedUserTaskStateFilter
func (t *UserTaskStateFilterProperty) MergeAdvancedUserTaskStateFilter(v AdvancedUserTaskStateFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UserTaskStateFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UserTaskStateFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVariableKeyFilterProperty0 returns the union data inside the VariableKeyFilterProperty as a VariableKeyFilterProperty0
func (t VariableKeyFilterProperty) AsVariableKeyFilterProperty0() (VariableKeyFilterProperty0, error) {
	var body VariableKeyFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVariableKeyFilterProperty0 overwrites any union data inside the VariableKeyFilterProperty as the provided VariableKeyFilterProperty0
func (t *VariableKeyFilterProperty) FromVariableKeyFilterProperty0(v VariableKeyFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVariableKeyFilterProperty0 performs a merge with any union data inside the VariableKeyFilterProperty, using the provided VariableKeyFilterProperty0
func (t *VariableKeyFilterProperty) MergeVariableKeyFilterProperty0(v VariableKeyFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedVariableKeyFilter returns the union data inside the VariableKeyFilterProperty as a AdvancedVariableKeyFilter
func (t VariableKeyFilterProperty) AsAdvancedVariableKeyFilter() (AdvancedVariableKeyFilter, error) {
	var body AdvancedVariableKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedVariableKeyFilter overwrites any union data inside the VariableKeyFilterProperty as the provided AdvancedVariableKeyFilter
func (t *VariableKeyFilterProperty) FromAdvancedVariableKeyFilter(v AdvancedVariableKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedVariableKeyFilter performs a merge with any union data inside the VariableKeyFilterProperty, using the provided AdvancedVariableKeyFilter
func (t *VariableKeyFilterProperty) MergeAdvancedVariableKeyFilter(v AdvancedVariableKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VariableKeyFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VariableKeyFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAuthentication request
	GetAuthentication(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAuthorizationWithBody request with any body
	CreateAuthorizationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAuthorization(ctx context.Context, body CreateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchAuthorizationsWithBody request with any body
	SearchAuthorizationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchAuthorizations(ctx context.Context, body SearchAuthorizationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAuthorization request
	DeleteAuthorization(ctx context.Context, authorizationKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthorization request
	GetAuthorization(ctx context.Context, authorizationKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAuthorizationWithBody request with any body
	UpdateAuthorizationWithBody(ctx context.Context, authorizationKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAuthorization(ctx context.Context, authorizationKey string, body UpdateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchBatchOperationItemsWithBody request with any body
	SearchBatchOperationItemsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchBatchOperationItems(ctx context.Context, body SearchBatchOperationItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchBatchOperationsWithBody request with any body
	SearchBatchOperationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchBatchOperations(ctx context.Context, body SearchBatchOperationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBatchOperation request
	GetBatchOperation(ctx context.Context, batchOperationKey BatchOperationKey, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelBatchOperationWithBody request with any body
	CancelBatchOperationWithBody(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelBatchOperation(ctx context.Context, batchOperationKey BatchOperationKey, body CancelBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResumeBatchOperationWithBody request with any body
	ResumeBatchOperationWithBody(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResumeBatchOperation(ctx context.Context, batchOperationKey BatchOperationKey, body ResumeBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SuspendBatchOperationWithBody request with any body
	SuspendBatchOperationWithBody(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SuspendBatchOperation(ctx context.Context, batchOperationKey BatchOperationKey, body SuspendBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PinClockWithBody request with any body
	PinClockWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PinClock(ctx context.Context, body PinClockJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetClock request
	ResetClock(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchCorrelatedMessageSubscriptionsWithBody request with any body
	SearchCorrelatedMessageSubscriptionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchCorrelatedMessageSubscriptions(ctx context.Context, body SearchCorrelatedMessageSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EvaluateDecisionWithBody request with any body
	EvaluateDecisionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EvaluateDecision(ctx context.Context, body EvaluateDecisionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchDecisionDefinitionsWithBody request with any body
	SearchDecisionDefinitionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchDecisionDefinitions(ctx context.Context, body SearchDecisionDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionDefinition request
	GetDecisionDefinition(ctx context.Context, decisionDefinitionKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionDefinitionXML request
	GetDecisionDefinitionXML(ctx context.Context, decisionDefinitionKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchDecisionInstancesWithBody request with any body
	SearchDecisionInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchDecisionInstances(ctx context.Context, body SearchDecisionInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionInstance request
	GetDecisionInstance(ctx context.Context, decisionEvaluationInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchDecisionRequirementsWithBody request with any body
	SearchDecisionRequirementsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchDecisionRequirements(ctx context.Context, body SearchDecisionRequirementsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionRequirements request
	GetDecisionRequirements(ctx context.Context, decisionRequirementsKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionRequirementsXML request
	GetDecisionRequirementsXML(ctx context.Context, decisionRequirementsKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDeploymentWithBody request with any body
	CreateDeploymentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDocumentWithBody request with any body
	CreateDocumentWithBody(ctx context.Context, params *CreateDocumentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDocumentsWithBody request with any body
	CreateDocumentsWithBody(ctx context.Context, params *CreateDocumentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDocument request
	DeleteDocument(ctx context.Context, documentId DocumentId, params *DeleteDocumentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDocument request
	GetDocument(ctx context.Context, documentId DocumentId, params *GetDocumentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDocumentLinkWithBody request with any body
	CreateDocumentLinkWithBody(ctx context.Context, documentId DocumentId, params *CreateDocumentLinkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDocumentLink(ctx context.Context, documentId DocumentId, params *CreateDocumentLinkParams, body CreateDocumentLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivateAdHocSubProcessActivitiesWithBody request with any body
	ActivateAdHocSubProcessActivitiesWithBody(ctx context.Context, adHocSubProcessInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActivateAdHocSubProcessActivities(ctx context.Context, adHocSubProcessInstanceKey string, body ActivateAdHocSubProcessActivitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchElementInstancesWithBody request with any body
	SearchElementInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchElementInstances(ctx context.Context, body SearchElementInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetElementInstance request
	GetElementInstance(ctx context.Context, elementInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateElementInstanceVariablesWithBody request with any body
	CreateElementInstanceVariablesWithBody(ctx context.Context, elementInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateElementInstanceVariables(ctx context.Context, elementInstanceKey string, body CreateElementInstanceVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGroupWithBody request with any body
	CreateGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGroup(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchGroupsWithBody request with any body
	SearchGroupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchGroups(ctx context.Context, body SearchGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroup request
	DeleteGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroup request
	GetGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGroupWithBody request with any body
	UpdateGroupWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGroup(ctx context.Context, groupId string, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchClientsForGroupWithBody request with any body
	SearchClientsForGroupWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchClientsForGroup(ctx context.Context, groupId string, body SearchClientsForGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignClientFromGroup request
	UnassignClientFromGroup(ctx context.Context, groupId string, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignClientToGroup request
	AssignClientToGroup(ctx context.Context, groupId string, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchMappingRulesForGroupWithBody request with any body
	SearchMappingRulesForGroupWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchMappingRulesForGroup(ctx context.Context, groupId string, body SearchMappingRulesForGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignMappingRuleFromGroup request
	UnassignMappingRuleFromGroup(ctx context.Context, groupId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignMappingRuleToGroup request
	AssignMappingRuleToGroup(ctx context.Context, groupId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchRolesForGroupWithBody request with any body
	SearchRolesForGroupWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchRolesForGroup(ctx context.Context, groupId string, body SearchRolesForGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchUsersForGroupWithBody request with any body
	SearchUsersForGroupWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchUsersForGroup(ctx context.Context, groupId string, body SearchUsersForGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignUserFromGroup request
	UnassignUserFromGroup(ctx context.Context, groupId string, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignUserToGroup request
	AssignUserToGroup(ctx context.Context, groupId string, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchIncidentsWithBody request with any body
	SearchIncidentsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchIncidents(ctx context.Context, body SearchIncidentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIncident request
	GetIncident(ctx context.Context, incidentKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResolveIncidentWithBody request with any body
	ResolveIncidentWithBody(ctx context.Context, incidentKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResolveIncident(ctx context.Context, incidentKey string, body ResolveIncidentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivateJobsWithBody request with any body
	ActivateJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActivateJobs(ctx context.Context, body ActivateJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchJobsWithBody request with any body
	SearchJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchJobs(ctx context.Context, body SearchJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateJobWithBody request with any body
	UpdateJobWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateJob(ctx context.Context, jobKey string, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompleteJobWithBody request with any body
	CompleteJobWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CompleteJob(ctx context.Context, jobKey string, body CompleteJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ThrowJobErrorWithBody request with any body
	ThrowJobErrorWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ThrowJobError(ctx context.Context, jobKey string, body ThrowJobErrorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FailJobWithBody request with any body
	FailJobWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FailJob(ctx context.Context, jobKey string, body FailJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLicense request
	GetLicense(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMappingRuleWithBody request with any body
	CreateMappingRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMappingRule(ctx context.Context, body CreateMappingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchMappingRuleWithBody request with any body
	SearchMappingRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchMappingRule(ctx context.Context, body SearchMappingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMappingRule request
	DeleteMappingRule(ctx context.Context, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMappingRule request
	GetMappingRule(ctx context.Context, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMappingRuleWithBody request with any body
	UpdateMappingRuleWithBody(ctx context.Context, mappingRuleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMappingRule(ctx context.Context, mappingRuleId string, body UpdateMappingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchMessageSubscriptionsWithBody request with any body
	SearchMessageSubscriptionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchMessageSubscriptions(ctx context.Context, body SearchMessageSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CorrelateMessageWithBody request with any body
	CorrelateMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CorrelateMessage(ctx context.Context, body CorrelateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PublishMessageWithBody request with any body
	PublishMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PublishMessage(ctx context.Context, body PublishMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchProcessDefinitionsWithBody request with any body
	SearchProcessDefinitionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchProcessDefinitions(ctx context.Context, body SearchProcessDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessDefinition request
	GetProcessDefinition(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStartProcessForm request
	GetStartProcessForm(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessDefinitionStatisticsWithBody request with any body
	GetProcessDefinitionStatisticsWithBody(ctx context.Context, processDefinitionKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetProcessDefinitionStatistics(ctx context.Context, processDefinitionKey string, body GetProcessDefinitionStatisticsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessDefinitionXML request
	GetProcessDefinitionXML(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProcessInstanceWithBody request with any body
	CreateProcessInstanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProcessInstance(ctx context.Context, body CreateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelProcessInstancesBatchOperationWithBody request with any body
	CancelProcessInstancesBatchOperationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelProcessInstancesBatchOperation(ctx context.Context, body CancelProcessInstancesBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResolveIncidentsBatchOperationWithBody request with any body
	ResolveIncidentsBatchOperationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResolveIncidentsBatchOperation(ctx context.Context, body ResolveIncidentsBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrateProcessInstancesBatchOperationWithBody request with any body
	MigrateProcessInstancesBatchOperationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MigrateProcessInstancesBatchOperation(ctx context.Context, body MigrateProcessInstancesBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyProcessInstancesBatchOperationWithBody request with any body
	ModifyProcessInstancesBatchOperationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyProcessInstancesBatchOperation(ctx context.Context, body ModifyProcessInstancesBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchProcessInstancesWithBody request with any body
	SearchProcessInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchProcessInstances(ctx context.Context, body SearchProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessInstance request
	GetProcessInstance(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessInstanceCallHierarchy request
	GetProcessInstanceCallHierarchy(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelProcessInstanceWithBody request with any body
	CancelProcessInstanceWithBody(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelProcessInstance(ctx context.Context, processInstanceKey string, body CancelProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchProcessInstanceIncidentsWithBody request with any body
	SearchProcessInstanceIncidentsWithBody(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchProcessInstanceIncidents(ctx context.Context, processInstanceKey string, body SearchProcessInstanceIncidentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrateProcessInstanceWithBody request with any body
	MigrateProcessInstanceWithBody(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MigrateProcessInstance(ctx context.Context, processInstanceKey string, body MigrateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyProcessInstanceWithBody request with any body
	ModifyProcessInstanceWithBody(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyProcessInstance(ctx context.Context, processInstanceKey string, body ModifyProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessInstanceSequenceFlows request
	GetProcessInstanceSequenceFlows(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessInstanceStatistics request
	GetProcessInstanceStatistics(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResource request
	GetResource(ctx context.Context, resourceKey ResourceKey, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceContent request
	GetResourceContent(ctx context.Context, resourceKey ResourceKey, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteResourceWithBody request with any body
	DeleteResourceWithBody(ctx context.Context, resourceKey ResourceKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteResource(ctx context.Context, resourceKey ResourceKey, body DeleteResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRoleWithBody request with any body
	CreateRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRole(ctx context.Context, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchRolesWithBody request with any body
	SearchRolesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchRoles(ctx context.Context, body SearchRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRole request
	DeleteRole(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRole request
	GetRole(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRoleWithBody request with any body
	UpdateRoleWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRole(ctx context.Context, roleId string, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchClientsForRoleWithBody request with any body
	SearchClientsForRoleWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchClientsForRole(ctx context.Context, roleId string, body SearchClientsForRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignRoleFromClient request
	UnassignRoleFromClient(ctx context.Context, roleId string, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignRoleToClient request
	AssignRoleToClient(ctx context.Context, roleId string, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchGroupsForRoleWithBody request with any body
	SearchGroupsForRoleWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchGroupsForRole(ctx context.Context, roleId string, body SearchGroupsForRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignRoleFromGroup request
	UnassignRoleFromGroup(ctx context.Context, roleId string, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignRoleToGroup request
	AssignRoleToGroup(ctx context.Context, roleId string, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchMappingRulesForRoleWithBody request with any body
	SearchMappingRulesForRoleWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchMappingRulesForRole(ctx context.Context, roleId string, body SearchMappingRulesForRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignRoleFromMappingRule request
	UnassignRoleFromMappingRule(ctx context.Context, roleId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignRoleToMappingRule request
	AssignRoleToMappingRule(ctx context.Context, roleId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchUsersForRoleWithBody request with any body
	SearchUsersForRoleWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchUsersForRole(ctx context.Context, roleId string, body SearchUsersForRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignRoleFromUser request
	UnassignRoleFromUser(ctx context.Context, roleId string, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignRoleToUser request
	AssignRoleToUser(ctx context.Context, roleId string, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAdminUserWithBody request with any body
	CreateAdminUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAdminUser(ctx context.Context, body CreateAdminUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BroadcastSignalWithBody request with any body
	BroadcastSignalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BroadcastSignal(ctx context.Context, body BroadcastSignalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatus request
	GetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsageMetrics request
	GetUsageMetrics(ctx context.Context, params *GetUsageMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTenantWithBody request with any body
	CreateTenantWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTenant(ctx context.Context, body CreateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchTenantsWithBody request with any body
	SearchTenantsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchTenants(ctx context.Context, body SearchTenantsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTenant request
	DeleteTenant(ctx context.Context, tenantId TenantId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTenant request
	GetTenant(ctx context.Context, tenantId TenantId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTenantWithBody request with any body
	UpdateTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTenant(ctx context.Context, tenantId TenantId, body UpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchClientsForTenantWithBody request with any body
	SearchClientsForTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchClientsForTenant(ctx context.Context, tenantId TenantId, body SearchClientsForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignClientFromTenant request
	UnassignClientFromTenant(ctx context.Context, tenantId TenantId, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignClientToTenant request
	AssignClientToTenant(ctx context.Context, tenantId TenantId, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchGroupIdsForTenantWithBody request with any body
	SearchGroupIdsForTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchGroupIdsForTenant(ctx context.Context, tenantId TenantId, body SearchGroupIdsForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignGroupFromTenant request
	UnassignGroupFromTenant(ctx context.Context, tenantId TenantId, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignGroupToTenant request
	AssignGroupToTenant(ctx context.Context, tenantId TenantId, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchMappingRulesForTenantWithBody request with any body
	SearchMappingRulesForTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchMappingRulesForTenant(ctx context.Context, tenantId TenantId, body SearchMappingRulesForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignMappingRuleFromTenant request
	UnassignMappingRuleFromTenant(ctx context.Context, tenantId TenantId, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignMappingRuleToTenant request
	AssignMappingRuleToTenant(ctx context.Context, tenantId TenantId, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchRolesForTenantWithBody request with any body
	SearchRolesForTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchRolesForTenant(ctx context.Context, tenantId TenantId, body SearchRolesForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignRoleFromTenant request
	UnassignRoleFromTenant(ctx context.Context, tenantId TenantId, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignRoleToTenant request
	AssignRoleToTenant(ctx context.Context, tenantId TenantId, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchUsersForTenantWithBody request with any body
	SearchUsersForTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchUsersForTenant(ctx context.Context, tenantId TenantId, body SearchUsersForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignUserFromTenant request
	UnassignUserFromTenant(ctx context.Context, tenantId TenantId, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignUserToTenant request
	AssignUserToTenant(ctx context.Context, tenantId TenantId, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTopology request
	GetTopology(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchUserTasksWithBody request with any body
	SearchUserTasksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchUserTasks(ctx context.Context, body SearchUserTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserTask request
	GetUserTask(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserTaskWithBody request with any body
	UpdateUserTaskWithBody(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserTask(ctx context.Context, userTaskKey string, body UpdateUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignUserTask request
	UnassignUserTask(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignUserTaskWithBody request with any body
	AssignUserTaskWithBody(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssignUserTask(ctx context.Context, userTaskKey string, body AssignUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompleteUserTaskWithBody request with any body
	CompleteUserTaskWithBody(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CompleteUserTask(ctx context.Context, userTaskKey string, body CompleteUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserTaskForm request
	GetUserTaskForm(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchUserTaskVariablesWithBody request with any body
	SearchUserTaskVariablesWithBody(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchUserTaskVariables(ctx context.Context, userTaskKey string, body SearchUserTaskVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserWithBody request with any body
	CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchUsersWithBody request with any body
	SearchUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchUsers(ctx context.Context, body SearchUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserWithBody request with any body
	UpdateUserWithBody(ctx context.Context, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, username Username, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchVariablesWithBody request with any body
	SearchVariablesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchVariables(ctx context.Context, body SearchVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVariable request
	GetVariable(ctx context.Context, variableKey string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAuthentication(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthenticationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAuthorizationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuthorizationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAuthorization(ctx context.Context, body CreateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuthorizationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchAuthorizationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchAuthorizationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchAuthorizations(ctx context.Context, body SearchAuthorizationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchAuthorizationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAuthorization(ctx context.Context, authorizationKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAuthorizationRequest(c.Server, authorizationKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthorization(ctx context.Context, authorizationKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthorizationRequest(c.Server, authorizationKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAuthorizationWithBody(ctx context.Context, authorizationKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAuthorizationRequestWithBody(c.Server, authorizationKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAuthorization(ctx context.Context, authorizationKey string, body UpdateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAuthorizationRequest(c.Server, authorizationKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchBatchOperationItemsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchBatchOperationItemsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchBatchOperationItems(ctx context.Context, body SearchBatchOperationItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchBatchOperationItemsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchBatchOperationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchBatchOperationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchBatchOperations(ctx context.Context, body SearchBatchOperationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchBatchOperationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBatchOperation(ctx context.Context, batchOperationKey BatchOperationKey, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBatchOperationRequest(c.Server, batchOperationKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelBatchOperationWithBody(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelBatchOperationRequestWithBody(c.Server, batchOperationKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelBatchOperation(ctx context.Context, batchOperationKey BatchOperationKey, body CancelBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelBatchOperationRequest(c.Server, batchOperationKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeBatchOperationWithBody(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeBatchOperationRequestWithBody(c.Server, batchOperationKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeBatchOperation(ctx context.Context, batchOperationKey BatchOperationKey, body ResumeBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeBatchOperationRequest(c.Server, batchOperationKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SuspendBatchOperationWithBody(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSuspendBatchOperationRequestWithBody(c.Server, batchOperationKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SuspendBatchOperation(ctx context.Context, batchOperationKey BatchOperationKey, body SuspendBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSuspendBatchOperationRequest(c.Server, batchOperationKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PinClockWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPinClockRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PinClock(ctx context.Context, body PinClockJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPinClockRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetClock(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetClockRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchCorrelatedMessageSubscriptionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchCorrelatedMessageSubscriptionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchCorrelatedMessageSubscriptions(ctx context.Context, body SearchCorrelatedMessageSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchCorrelatedMessageSubscriptionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EvaluateDecisionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEvaluateDecisionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EvaluateDecision(ctx context.Context, body EvaluateDecisionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEvaluateDecisionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDecisionDefinitionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDecisionDefinitionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDecisionDefinitions(ctx context.Context, body SearchDecisionDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDecisionDefinitionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionDefinition(ctx context.Context, decisionDefinitionKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionDefinitionRequest(c.Server, decisionDefinitionKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionDefinitionXML(ctx context.Context, decisionDefinitionKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionDefinitionXMLRequest(c.Server, decisionDefinitionKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDecisionInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDecisionInstancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDecisionInstances(ctx context.Context, body SearchDecisionInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDecisionInstancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionInstance(ctx context.Context, decisionEvaluationInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionInstanceRequest(c.Server, decisionEvaluationInstanceKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDecisionRequirementsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDecisionRequirementsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDecisionRequirements(ctx context.Context, body SearchDecisionRequirementsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDecisionRequirementsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionRequirements(ctx context.Context, decisionRequirementsKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionRequirementsRequest(c.Server, decisionRequirementsKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionRequirementsXML(ctx context.Context, decisionRequirementsKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionRequirementsXMLRequest(c.Server, decisionRequirementsKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDeploymentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeploymentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDocumentWithBody(ctx context.Context, params *CreateDocumentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDocumentRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDocumentsWithBody(ctx context.Context, params *CreateDocumentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDocumentsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDocument(ctx context.Context, documentId DocumentId, params *DeleteDocumentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDocumentRequest(c.Server, documentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDocument(ctx context.Context, documentId DocumentId, params *GetDocumentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDocumentRequest(c.Server, documentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDocumentLinkWithBody(ctx context.Context, documentId DocumentId, params *CreateDocumentLinkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDocumentLinkRequestWithBody(c.Server, documentId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDocumentLink(ctx context.Context, documentId DocumentId, params *CreateDocumentLinkParams, body CreateDocumentLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDocumentLinkRequest(c.Server, documentId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateAdHocSubProcessActivitiesWithBody(ctx context.Context, adHocSubProcessInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateAdHocSubProcessActivitiesRequestWithBody(c.Server, adHocSubProcessInstanceKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateAdHocSubProcessActivities(ctx context.Context, adHocSubProcessInstanceKey string, body ActivateAdHocSubProcessActivitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateAdHocSubProcessActivitiesRequest(c.Server, adHocSubProcessInstanceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchElementInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchElementInstancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchElementInstances(ctx context.Context, body SearchElementInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchElementInstancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetElementInstance(ctx context.Context, elementInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetElementInstanceRequest(c.Server, elementInstanceKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateElementInstanceVariablesWithBody(ctx context.Context, elementInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateElementInstanceVariablesRequestWithBody(c.Server, elementInstanceKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateElementInstanceVariables(ctx context.Context, elementInstanceKey string, body CreateElementInstanceVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateElementInstanceVariablesRequest(c.Server, elementInstanceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroup(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGroupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGroupsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGroups(ctx context.Context, body SearchGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGroupsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroupWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroup(ctx context.Context, groupId string, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchClientsForGroupWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchClientsForGroupRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchClientsForGroup(ctx context.Context, groupId string, body SearchClientsForGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchClientsForGroupRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignClientFromGroup(ctx context.Context, groupId string, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignClientFromGroupRequest(c.Server, groupId, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignClientToGroup(ctx context.Context, groupId string, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignClientToGroupRequest(c.Server, groupId, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchMappingRulesForGroupWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchMappingRulesForGroupRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchMappingRulesForGroup(ctx context.Context, groupId string, body SearchMappingRulesForGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchMappingRulesForGroupRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignMappingRuleFromGroup(ctx context.Context, groupId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignMappingRuleFromGroupRequest(c.Server, groupId, mappingRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignMappingRuleToGroup(ctx context.Context, groupId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignMappingRuleToGroupRequest(c.Server, groupId, mappingRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRolesForGroupWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRolesForGroupRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRolesForGroup(ctx context.Context, groupId string, body SearchRolesForGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRolesForGroupRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUsersForGroupWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUsersForGroupRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUsersForGroup(ctx context.Context, groupId string, body SearchUsersForGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUsersForGroupRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignUserFromGroup(ctx context.Context, groupId string, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignUserFromGroupRequest(c.Server, groupId, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignUserToGroup(ctx context.Context, groupId string, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignUserToGroupRequest(c.Server, groupId, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchIncidentsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchIncidentsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchIncidents(ctx context.Context, body SearchIncidentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchIncidentsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIncident(ctx context.Context, incidentKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIncidentRequest(c.Server, incidentKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResolveIncidentWithBody(ctx context.Context, incidentKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResolveIncidentRequestWithBody(c.Server, incidentKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResolveIncident(ctx context.Context, incidentKey string, body ResolveIncidentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResolveIncidentRequest(c.Server, incidentKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateJobsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateJobs(ctx context.Context, body ActivateJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateJobsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchJobsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchJobs(ctx context.Context, body SearchJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchJobsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateJobWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateJobRequestWithBody(c.Server, jobKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateJob(ctx context.Context, jobKey string, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateJobRequest(c.Server, jobKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteJobWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteJobRequestWithBody(c.Server, jobKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteJob(ctx context.Context, jobKey string, body CompleteJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteJobRequest(c.Server, jobKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ThrowJobErrorWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewThrowJobErrorRequestWithBody(c.Server, jobKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ThrowJobError(ctx context.Context, jobKey string, body ThrowJobErrorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewThrowJobErrorRequest(c.Server, jobKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FailJobWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFailJobRequestWithBody(c.Server, jobKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FailJob(ctx context.Context, jobKey string, body FailJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFailJobRequest(c.Server, jobKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLicense(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLicenseRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMappingRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMappingRuleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMappingRule(ctx context.Context, body CreateMappingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMappingRuleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchMappingRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchMappingRuleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchMappingRule(ctx context.Context, body SearchMappingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchMappingRuleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMappingRule(ctx context.Context, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMappingRuleRequest(c.Server, mappingRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMappingRule(ctx context.Context, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMappingRuleRequest(c.Server, mappingRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMappingRuleWithBody(ctx context.Context, mappingRuleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMappingRuleRequestWithBody(c.Server, mappingRuleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMappingRule(ctx context.Context, mappingRuleId string, body UpdateMappingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMappingRuleRequest(c.Server, mappingRuleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchMessageSubscriptionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchMessageSubscriptionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchMessageSubscriptions(ctx context.Context, body SearchMessageSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchMessageSubscriptionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CorrelateMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCorrelateMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CorrelateMessage(ctx context.Context, body CorrelateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCorrelateMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublishMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublishMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublishMessage(ctx context.Context, body PublishMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublishMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchProcessDefinitionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchProcessDefinitionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchProcessDefinitions(ctx context.Context, body SearchProcessDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchProcessDefinitionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessDefinition(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessDefinitionRequest(c.Server, processDefinitionKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStartProcessForm(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStartProcessFormRequest(c.Server, processDefinitionKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessDefinitionStatisticsWithBody(ctx context.Context, processDefinitionKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessDefinitionStatisticsRequestWithBody(c.Server, processDefinitionKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessDefinitionStatistics(ctx context.Context, processDefinitionKey string, body GetProcessDefinitionStatisticsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessDefinitionStatisticsRequest(c.Server, processDefinitionKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessDefinitionXML(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessDefinitionXMLRequest(c.Server, processDefinitionKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProcessInstanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProcessInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProcessInstance(ctx context.Context, body CreateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProcessInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelProcessInstancesBatchOperationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelProcessInstancesBatchOperationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelProcessInstancesBatchOperation(ctx context.Context, body CancelProcessInstancesBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelProcessInstancesBatchOperationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResolveIncidentsBatchOperationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResolveIncidentsBatchOperationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResolveIncidentsBatchOperation(ctx context.Context, body ResolveIncidentsBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResolveIncidentsBatchOperationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateProcessInstancesBatchOperationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateProcessInstancesBatchOperationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateProcessInstancesBatchOperation(ctx context.Context, body MigrateProcessInstancesBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateProcessInstancesBatchOperationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyProcessInstancesBatchOperationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyProcessInstancesBatchOperationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyProcessInstancesBatchOperation(ctx context.Context, body ModifyProcessInstancesBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyProcessInstancesBatchOperationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchProcessInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchProcessInstancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchProcessInstances(ctx context.Context, body SearchProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchProcessInstancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessInstance(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessInstanceRequest(c.Server, processInstanceKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessInstanceCallHierarchy(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessInstanceCallHierarchyRequest(c.Server, processInstanceKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelProcessInstanceWithBody(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelProcessInstanceRequestWithBody(c.Server, processInstanceKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelProcessInstance(ctx context.Context, processInstanceKey string, body CancelProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelProcessInstanceRequest(c.Server, processInstanceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchProcessInstanceIncidentsWithBody(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchProcessInstanceIncidentsRequestWithBody(c.Server, processInstanceKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchProcessInstanceIncidents(ctx context.Context, processInstanceKey string, body SearchProcessInstanceIncidentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchProcessInstanceIncidentsRequest(c.Server, processInstanceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateProcessInstanceWithBody(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateProcessInstanceRequestWithBody(c.Server, processInstanceKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateProcessInstance(ctx context.Context, processInstanceKey string, body MigrateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateProcessInstanceRequest(c.Server, processInstanceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyProcessInstanceWithBody(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyProcessInstanceRequestWithBody(c.Server, processInstanceKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyProcessInstance(ctx context.Context, processInstanceKey string, body ModifyProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyProcessInstanceRequest(c.Server, processInstanceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessInstanceSequenceFlows(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessInstanceSequenceFlowsRequest(c.Server, processInstanceKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessInstanceStatistics(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessInstanceStatisticsRequest(c.Server, processInstanceKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResource(ctx context.Context, resourceKey ResourceKey, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceRequest(c.Server, resourceKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceContent(ctx context.Context, resourceKey ResourceKey, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceContentRequest(c.Server, resourceKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteResourceWithBody(ctx context.Context, resourceKey ResourceKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteResourceRequestWithBody(c.Server, resourceKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteResource(ctx context.Context, resourceKey ResourceKey, body DeleteResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteResourceRequest(c.Server, resourceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRole(ctx context.Context, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRolesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRolesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRoles(ctx context.Context, body SearchRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRolesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRole(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRoleRequest(c.Server, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRole(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleRequest(c.Server, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoleWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleRequestWithBody(c.Server, roleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRole(ctx context.Context, roleId string, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleRequest(c.Server, roleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchClientsForRoleWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchClientsForRoleRequestWithBody(c.Server, roleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchClientsForRole(ctx context.Context, roleId string, body SearchClientsForRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchClientsForRoleRequest(c.Server, roleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignRoleFromClient(ctx context.Context, roleId string, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignRoleFromClientRequest(c.Server, roleId, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignRoleToClient(ctx context.Context, roleId string, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignRoleToClientRequest(c.Server, roleId, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGroupsForRoleWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGroupsForRoleRequestWithBody(c.Server, roleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGroupsForRole(ctx context.Context, roleId string, body SearchGroupsForRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGroupsForRoleRequest(c.Server, roleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignRoleFromGroup(ctx context.Context, roleId string, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignRoleFromGroupRequest(c.Server, roleId, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignRoleToGroup(ctx context.Context, roleId string, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignRoleToGroupRequest(c.Server, roleId, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchMappingRulesForRoleWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchMappingRulesForRoleRequestWithBody(c.Server, roleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchMappingRulesForRole(ctx context.Context, roleId string, body SearchMappingRulesForRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchMappingRulesForRoleRequest(c.Server, roleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignRoleFromMappingRule(ctx context.Context, roleId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignRoleFromMappingRuleRequest(c.Server, roleId, mappingRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignRoleToMappingRule(ctx context.Context, roleId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignRoleToMappingRuleRequest(c.Server, roleId, mappingRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUsersForRoleWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUsersForRoleRequestWithBody(c.Server, roleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUsersForRole(ctx context.Context, roleId string, body SearchUsersForRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUsersForRoleRequest(c.Server, roleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignRoleFromUser(ctx context.Context, roleId string, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignRoleFromUserRequest(c.Server, roleId, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignRoleToUser(ctx context.Context, roleId string, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignRoleToUserRequest(c.Server, roleId, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAdminUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAdminUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAdminUser(ctx context.Context, body CreateAdminUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAdminUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BroadcastSignalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBroadcastSignalRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BroadcastSignal(ctx context.Context, body BroadcastSignalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBroadcastSignalRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsageMetrics(ctx context.Context, params *GetUsageMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsageMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTenantWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTenantRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTenant(ctx context.Context, body CreateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTenantRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchTenantsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchTenantsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchTenants(ctx context.Context, body SearchTenantsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchTenantsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTenant(ctx context.Context, tenantId TenantId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTenantRequest(c.Server, tenantId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTenant(ctx context.Context, tenantId TenantId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTenantRequest(c.Server, tenantId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTenantRequestWithBody(c.Server, tenantId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTenant(ctx context.Context, tenantId TenantId, body UpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTenantRequest(c.Server, tenantId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchClientsForTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchClientsForTenantRequestWithBody(c.Server, tenantId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchClientsForTenant(ctx context.Context, tenantId TenantId, body SearchClientsForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchClientsForTenantRequest(c.Server, tenantId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignClientFromTenant(ctx context.Context, tenantId TenantId, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignClientFromTenantRequest(c.Server, tenantId, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignClientToTenant(ctx context.Context, tenantId TenantId, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignClientToTenantRequest(c.Server, tenantId, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGroupIdsForTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGroupIdsForTenantRequestWithBody(c.Server, tenantId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGroupIdsForTenant(ctx context.Context, tenantId TenantId, body SearchGroupIdsForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGroupIdsForTenantRequest(c.Server, tenantId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignGroupFromTenant(ctx context.Context, tenantId TenantId, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignGroupFromTenantRequest(c.Server, tenantId, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignGroupToTenant(ctx context.Context, tenantId TenantId, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignGroupToTenantRequest(c.Server, tenantId, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchMappingRulesForTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchMappingRulesForTenantRequestWithBody(c.Server, tenantId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchMappingRulesForTenant(ctx context.Context, tenantId TenantId, body SearchMappingRulesForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchMappingRulesForTenantRequest(c.Server, tenantId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignMappingRuleFromTenant(ctx context.Context, tenantId TenantId, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignMappingRuleFromTenantRequest(c.Server, tenantId, mappingRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignMappingRuleToTenant(ctx context.Context, tenantId TenantId, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignMappingRuleToTenantRequest(c.Server, tenantId, mappingRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRolesForTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRolesForTenantRequestWithBody(c.Server, tenantId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRolesForTenant(ctx context.Context, tenantId TenantId, body SearchRolesForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRolesForTenantRequest(c.Server, tenantId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignRoleFromTenant(ctx context.Context, tenantId TenantId, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignRoleFromTenantRequest(c.Server, tenantId, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignRoleToTenant(ctx context.Context, tenantId TenantId, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignRoleToTenantRequest(c.Server, tenantId, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUsersForTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUsersForTenantRequestWithBody(c.Server, tenantId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUsersForTenant(ctx context.Context, tenantId TenantId, body SearchUsersForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUsersForTenantRequest(c.Server, tenantId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignUserFromTenant(ctx context.Context, tenantId TenantId, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignUserFromTenantRequest(c.Server, tenantId, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignUserToTenant(ctx context.Context, tenantId TenantId, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignUserToTenantRequest(c.Server, tenantId, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTopology(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTopologyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUserTasksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUserTasksRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUserTasks(ctx context.Context, body SearchUserTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUserTasksRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserTask(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserTaskRequest(c.Server, userTaskKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserTaskWithBody(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserTaskRequestWithBody(c.Server, userTaskKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserTask(ctx context.Context, userTaskKey string, body UpdateUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserTaskRequest(c.Server, userTaskKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignUserTask(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignUserTaskRequest(c.Server, userTaskKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignUserTaskWithBody(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignUserTaskRequestWithBody(c.Server, userTaskKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignUserTask(ctx context.Context, userTaskKey string, body AssignUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignUserTaskRequest(c.Server, userTaskKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteUserTaskWithBody(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteUserTaskRequestWithBody(c.Server, userTaskKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteUserTask(ctx context.Context, userTaskKey string, body CompleteUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteUserTaskRequest(c.Server, userTaskKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserTaskForm(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserTaskFormRequest(c.Server, userTaskKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUserTaskVariablesWithBody(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUserTaskVariablesRequestWithBody(c.Server, userTaskKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUserTaskVariables(ctx context.Context, userTaskKey string, body SearchUserTaskVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUserTaskVariablesRequest(c.Server, userTaskKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUsersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUsers(ctx context.Context, body SearchUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUsersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, username, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, username Username, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, username, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchVariablesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchVariablesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchVariables(ctx context.Context, body SearchVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchVariablesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVariable(ctx context.Context, variableKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVariableRequest(c.Server, variableKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAuthenticationRequest generates requests for GetAuthentication
func NewGetAuthenticationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authentication/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAuthorizationRequest calls the generic CreateAuthorization builder with application/json body
func NewCreateAuthorizationRequest(server string, body CreateAuthorizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAuthorizationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAuthorizationRequestWithBody generates requests for CreateAuthorization with any type of body
func NewCreateAuthorizationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchAuthorizationsRequest calls the generic SearchAuthorizations builder with application/json body
func NewSearchAuthorizationsRequest(server string, body SearchAuthorizationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchAuthorizationsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchAuthorizationsRequestWithBody generates requests for SearchAuthorizations with any type of body
func NewSearchAuthorizationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAuthorizationRequest generates requests for DeleteAuthorization
func NewDeleteAuthorizationRequest(server string, authorizationKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorizationKey", runtime.ParamLocationPath, authorizationKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuthorizationRequest generates requests for GetAuthorization
func NewGetAuthorizationRequest(server string, authorizationKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorizationKey", runtime.ParamLocationPath, authorizationKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAuthorizationRequest calls the generic UpdateAuthorization builder with application/json body
func NewUpdateAuthorizationRequest(server string, authorizationKey string, body UpdateAuthorizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAuthorizationRequestWithBody(server, authorizationKey, "application/json", bodyReader)
}

// NewUpdateAuthorizationRequestWithBody generates requests for UpdateAuthorization with any type of body
func NewUpdateAuthorizationRequestWithBody(server string, authorizationKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorizationKey", runtime.ParamLocationPath, authorizationKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchBatchOperationItemsRequest calls the generic SearchBatchOperationItems builder with application/json body
func NewSearchBatchOperationItemsRequest(server string, body SearchBatchOperationItemsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchBatchOperationItemsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchBatchOperationItemsRequestWithBody generates requests for SearchBatchOperationItems with any type of body
func NewSearchBatchOperationItemsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch-operation-items/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchBatchOperationsRequest calls the generic SearchBatchOperations builder with application/json body
func NewSearchBatchOperationsRequest(server string, body SearchBatchOperationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchBatchOperationsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchBatchOperationsRequestWithBody generates requests for SearchBatchOperations with any type of body
func NewSearchBatchOperationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch-operations/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBatchOperationRequest generates requests for GetBatchOperation
func NewGetBatchOperationRequest(server string, batchOperationKey BatchOperationKey) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "batchOperationKey", runtime.ParamLocationPath, batchOperationKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch-operations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelBatchOperationRequest calls the generic CancelBatchOperation builder with application/json body
func NewCancelBatchOperationRequest(server string, batchOperationKey BatchOperationKey, body CancelBatchOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelBatchOperationRequestWithBody(server, batchOperationKey, "application/json", bodyReader)
}

// NewCancelBatchOperationRequestWithBody generates requests for CancelBatchOperation with any type of body
func NewCancelBatchOperationRequestWithBody(server string, batchOperationKey BatchOperationKey, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "batchOperationKey", runtime.ParamLocationPath, batchOperationKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch-operations/%s/cancellation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResumeBatchOperationRequest calls the generic ResumeBatchOperation builder with application/json body
func NewResumeBatchOperationRequest(server string, batchOperationKey BatchOperationKey, body ResumeBatchOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResumeBatchOperationRequestWithBody(server, batchOperationKey, "application/json", bodyReader)
}

// NewResumeBatchOperationRequestWithBody generates requests for ResumeBatchOperation with any type of body
func NewResumeBatchOperationRequestWithBody(server string, batchOperationKey BatchOperationKey, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "batchOperationKey", runtime.ParamLocationPath, batchOperationKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch-operations/%s/resumption", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSuspendBatchOperationRequest calls the generic SuspendBatchOperation builder with application/json body
func NewSuspendBatchOperationRequest(server string, batchOperationKey BatchOperationKey, body SuspendBatchOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSuspendBatchOperationRequestWithBody(server, batchOperationKey, "application/json", bodyReader)
}

// NewSuspendBatchOperationRequestWithBody generates requests for SuspendBatchOperation with any type of body
func NewSuspendBatchOperationRequestWithBody(server string, batchOperationKey BatchOperationKey, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "batchOperationKey", runtime.ParamLocationPath, batchOperationKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch-operations/%s/suspension", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPinClockRequest calls the generic PinClock builder with application/json body
func NewPinClockRequest(server string, body PinClockJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPinClockRequestWithBody(server, "application/json", bodyReader)
}

// NewPinClockRequestWithBody generates requests for PinClock with any type of body
func NewPinClockRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clock")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResetClockRequest generates requests for ResetClock
func NewResetClockRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clock/reset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchCorrelatedMessageSubscriptionsRequest calls the generic SearchCorrelatedMessageSubscriptions builder with application/json body
func NewSearchCorrelatedMessageSubscriptionsRequest(server string, body SearchCorrelatedMessageSubscriptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchCorrelatedMessageSubscriptionsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchCorrelatedMessageSubscriptionsRequestWithBody generates requests for SearchCorrelatedMessageSubscriptions with any type of body
func NewSearchCorrelatedMessageSubscriptionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/correlated-message-subscriptions/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEvaluateDecisionRequest calls the generic EvaluateDecision builder with application/json body
func NewEvaluateDecisionRequest(server string, body EvaluateDecisionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEvaluateDecisionRequestWithBody(server, "application/json", bodyReader)
}

// NewEvaluateDecisionRequestWithBody generates requests for EvaluateDecision with any type of body
func NewEvaluateDecisionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-definitions/evaluation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchDecisionDefinitionsRequest calls the generic SearchDecisionDefinitions builder with application/json body
func NewSearchDecisionDefinitionsRequest(server string, body SearchDecisionDefinitionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchDecisionDefinitionsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchDecisionDefinitionsRequestWithBody generates requests for SearchDecisionDefinitions with any type of body
func NewSearchDecisionDefinitionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-definitions/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDecisionDefinitionRequest generates requests for GetDecisionDefinition
func NewGetDecisionDefinitionRequest(server string, decisionDefinitionKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "decisionDefinitionKey", runtime.ParamLocationPath, decisionDefinitionKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-definitions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDecisionDefinitionXMLRequest generates requests for GetDecisionDefinitionXML
func NewGetDecisionDefinitionXMLRequest(server string, decisionDefinitionKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "decisionDefinitionKey", runtime.ParamLocationPath, decisionDefinitionKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-definitions/%s/xml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchDecisionInstancesRequest calls the generic SearchDecisionInstances builder with application/json body
func NewSearchDecisionInstancesRequest(server string, body SearchDecisionInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchDecisionInstancesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchDecisionInstancesRequestWithBody generates requests for SearchDecisionInstances with any type of body
func NewSearchDecisionInstancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-instances/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDecisionInstanceRequest generates requests for GetDecisionInstance
func NewGetDecisionInstanceRequest(server string, decisionEvaluationInstanceKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "decisionEvaluationInstanceKey", runtime.ParamLocationPath, decisionEvaluationInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchDecisionRequirementsRequest calls the generic SearchDecisionRequirements builder with application/json body
func NewSearchDecisionRequirementsRequest(server string, body SearchDecisionRequirementsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchDecisionRequirementsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchDecisionRequirementsRequestWithBody generates requests for SearchDecisionRequirements with any type of body
func NewSearchDecisionRequirementsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-requirements/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDecisionRequirementsRequest generates requests for GetDecisionRequirements
func NewGetDecisionRequirementsRequest(server string, decisionRequirementsKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "decisionRequirementsKey", runtime.ParamLocationPath, decisionRequirementsKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-requirements/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDecisionRequirementsXMLRequest generates requests for GetDecisionRequirementsXML
func NewGetDecisionRequirementsXMLRequest(server string, decisionRequirementsKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "decisionRequirementsKey", runtime.ParamLocationPath, decisionRequirementsKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-requirements/%s/xml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDeploymentRequestWithBody generates requests for CreateDeployment with any type of body
func NewCreateDeploymentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deployments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDocumentRequestWithBody generates requests for CreateDocument with any type of body
func NewCreateDocumentRequestWithBody(server string, params *CreateDocumentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/documents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DocumentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "documentId", runtime.ParamLocationQuery, *params.DocumentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDocumentsRequestWithBody generates requests for CreateDocuments with any type of body
func NewCreateDocumentsRequestWithBody(server string, params *CreateDocumentsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/documents/batch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDocumentRequest generates requests for DeleteDocument
func NewDeleteDocumentRequest(server string, documentId DocumentId, params *DeleteDocumentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "documentId", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/documents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDocumentRequest generates requests for GetDocument
func NewGetDocumentRequest(server string, documentId DocumentId, params *GetDocumentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "documentId", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/documents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contentHash", runtime.ParamLocationQuery, params.ContentHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDocumentLinkRequest calls the generic CreateDocumentLink builder with application/json body
func NewCreateDocumentLinkRequest(server string, documentId DocumentId, params *CreateDocumentLinkParams, body CreateDocumentLinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDocumentLinkRequestWithBody(server, documentId, params, "application/json", bodyReader)
}

// NewCreateDocumentLinkRequestWithBody generates requests for CreateDocumentLink with any type of body
func NewCreateDocumentLinkRequestWithBody(server string, documentId DocumentId, params *CreateDocumentLinkParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "documentId", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/documents/%s/links", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contentHash", runtime.ParamLocationQuery, params.ContentHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActivateAdHocSubProcessActivitiesRequest calls the generic ActivateAdHocSubProcessActivities builder with application/json body
func NewActivateAdHocSubProcessActivitiesRequest(server string, adHocSubProcessInstanceKey string, body ActivateAdHocSubProcessActivitiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActivateAdHocSubProcessActivitiesRequestWithBody(server, adHocSubProcessInstanceKey, "application/json", bodyReader)
}

// NewActivateAdHocSubProcessActivitiesRequestWithBody generates requests for ActivateAdHocSubProcessActivities with any type of body
func NewActivateAdHocSubProcessActivitiesRequestWithBody(server string, adHocSubProcessInstanceKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "adHocSubProcessInstanceKey", runtime.ParamLocationPath, adHocSubProcessInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/element-instances/ad-hoc-activities/%s/activation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchElementInstancesRequest calls the generic SearchElementInstances builder with application/json body
func NewSearchElementInstancesRequest(server string, body SearchElementInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchElementInstancesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchElementInstancesRequestWithBody generates requests for SearchElementInstances with any type of body
func NewSearchElementInstancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/element-instances/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetElementInstanceRequest generates requests for GetElementInstance
func NewGetElementInstanceRequest(server string, elementInstanceKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "elementInstanceKey", runtime.ParamLocationPath, elementInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/element-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateElementInstanceVariablesRequest calls the generic CreateElementInstanceVariables builder with application/json body
func NewCreateElementInstanceVariablesRequest(server string, elementInstanceKey string, body CreateElementInstanceVariablesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateElementInstanceVariablesRequestWithBody(server, elementInstanceKey, "application/json", bodyReader)
}

// NewCreateElementInstanceVariablesRequestWithBody generates requests for CreateElementInstanceVariables with any type of body
func NewCreateElementInstanceVariablesRequestWithBody(server string, elementInstanceKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "elementInstanceKey", runtime.ParamLocationPath, elementInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/element-instances/%s/variables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateGroupRequest calls the generic CreateGroup builder with application/json body
func NewCreateGroupRequest(server string, body CreateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateGroupRequestWithBody generates requests for CreateGroup with any type of body
func NewCreateGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchGroupsRequest calls the generic SearchGroups builder with application/json body
func NewSearchGroupsRequest(server string, body SearchGroupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchGroupsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchGroupsRequestWithBody generates requests for SearchGroups with any type of body
func NewSearchGroupsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupRequest generates requests for DeleteGroup
func NewDeleteGroupRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupRequest generates requests for GetGroup
func NewGetGroupRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGroupRequest calls the generic UpdateGroup builder with application/json body
func NewUpdateGroupRequest(server string, groupId string, body UpdateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGroupRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewUpdateGroupRequestWithBody generates requests for UpdateGroup with any type of body
func NewUpdateGroupRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchClientsForGroupRequest calls the generic SearchClientsForGroup builder with application/json body
func NewSearchClientsForGroupRequest(server string, groupId string, body SearchClientsForGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchClientsForGroupRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewSearchClientsForGroupRequestWithBody generates requests for SearchClientsForGroup with any type of body
func NewSearchClientsForGroupRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/clients/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignClientFromGroupRequest generates requests for UnassignClientFromGroup
func NewUnassignClientFromGroupRequest(server string, groupId string, clientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/clients/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignClientToGroupRequest generates requests for AssignClientToGroup
func NewAssignClientToGroupRequest(server string, groupId string, clientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/clients/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchMappingRulesForGroupRequest calls the generic SearchMappingRulesForGroup builder with application/json body
func NewSearchMappingRulesForGroupRequest(server string, groupId string, body SearchMappingRulesForGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchMappingRulesForGroupRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewSearchMappingRulesForGroupRequestWithBody generates requests for SearchMappingRulesForGroup with any type of body
func NewSearchMappingRulesForGroupRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/mapping-rules/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignMappingRuleFromGroupRequest generates requests for UnassignMappingRuleFromGroup
func NewUnassignMappingRuleFromGroupRequest(server string, groupId string, mappingRuleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "mappingRuleId", runtime.ParamLocationPath, mappingRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/mapping-rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignMappingRuleToGroupRequest generates requests for AssignMappingRuleToGroup
func NewAssignMappingRuleToGroupRequest(server string, groupId string, mappingRuleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "mappingRuleId", runtime.ParamLocationPath, mappingRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/mapping-rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchRolesForGroupRequest calls the generic SearchRolesForGroup builder with application/json body
func NewSearchRolesForGroupRequest(server string, groupId string, body SearchRolesForGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchRolesForGroupRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewSearchRolesForGroupRequestWithBody generates requests for SearchRolesForGroup with any type of body
func NewSearchRolesForGroupRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/roles/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchUsersForGroupRequest calls the generic SearchUsersForGroup builder with application/json body
func NewSearchUsersForGroupRequest(server string, groupId string, body SearchUsersForGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchUsersForGroupRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewSearchUsersForGroupRequestWithBody generates requests for SearchUsersForGroup with any type of body
func NewSearchUsersForGroupRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/users/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignUserFromGroupRequest generates requests for UnassignUserFromGroup
func NewUnassignUserFromGroupRequest(server string, groupId string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignUserToGroupRequest generates requests for AssignUserToGroup
func NewAssignUserToGroupRequest(server string, groupId string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchIncidentsRequest calls the generic SearchIncidents builder with application/json body
func NewSearchIncidentsRequest(server string, body SearchIncidentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchIncidentsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchIncidentsRequestWithBody generates requests for SearchIncidents with any type of body
func NewSearchIncidentsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIncidentRequest generates requests for GetIncident
func NewGetIncidentRequest(server string, incidentKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "incidentKey", runtime.ParamLocationPath, incidentKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResolveIncidentRequest calls the generic ResolveIncident builder with application/json body
func NewResolveIncidentRequest(server string, incidentKey string, body ResolveIncidentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResolveIncidentRequestWithBody(server, incidentKey, "application/json", bodyReader)
}

// NewResolveIncidentRequestWithBody generates requests for ResolveIncident with any type of body
func NewResolveIncidentRequestWithBody(server string, incidentKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "incidentKey", runtime.ParamLocationPath, incidentKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents/%s/resolution", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActivateJobsRequest calls the generic ActivateJobs builder with application/json body
func NewActivateJobsRequest(server string, body ActivateJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActivateJobsRequestWithBody(server, "application/json", bodyReader)
}

// NewActivateJobsRequestWithBody generates requests for ActivateJobs with any type of body
func NewActivateJobsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/activation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchJobsRequest calls the generic SearchJobs builder with application/json body
func NewSearchJobsRequest(server string, body SearchJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchJobsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchJobsRequestWithBody generates requests for SearchJobs with any type of body
func NewSearchJobsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateJobRequest calls the generic UpdateJob builder with application/json body
func NewUpdateJobRequest(server string, jobKey string, body UpdateJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateJobRequestWithBody(server, jobKey, "application/json", bodyReader)
}

// NewUpdateJobRequestWithBody generates requests for UpdateJob with any type of body
func NewUpdateJobRequestWithBody(server string, jobKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobKey", runtime.ParamLocationPath, jobKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCompleteJobRequest calls the generic CompleteJob builder with application/json body
func NewCompleteJobRequest(server string, jobKey string, body CompleteJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCompleteJobRequestWithBody(server, jobKey, "application/json", bodyReader)
}

// NewCompleteJobRequestWithBody generates requests for CompleteJob with any type of body
func NewCompleteJobRequestWithBody(server string, jobKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobKey", runtime.ParamLocationPath, jobKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/completion", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewThrowJobErrorRequest calls the generic ThrowJobError builder with application/json body
func NewThrowJobErrorRequest(server string, jobKey string, body ThrowJobErrorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewThrowJobErrorRequestWithBody(server, jobKey, "application/json", bodyReader)
}

// NewThrowJobErrorRequestWithBody generates requests for ThrowJobError with any type of body
func NewThrowJobErrorRequestWithBody(server string, jobKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobKey", runtime.ParamLocationPath, jobKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/error", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFailJobRequest calls the generic FailJob builder with application/json body
func NewFailJobRequest(server string, jobKey string, body FailJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFailJobRequestWithBody(server, jobKey, "application/json", bodyReader)
}

// NewFailJobRequestWithBody generates requests for FailJob with any type of body
func NewFailJobRequestWithBody(server string, jobKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobKey", runtime.ParamLocationPath, jobKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/failure", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLicenseRequest generates requests for GetLicense
func NewGetLicenseRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/license")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMappingRuleRequest calls the generic CreateMappingRule builder with application/json body
func NewCreateMappingRuleRequest(server string, body CreateMappingRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMappingRuleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateMappingRuleRequestWithBody generates requests for CreateMappingRule with any type of body
func NewCreateMappingRuleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mapping-rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchMappingRuleRequest calls the generic SearchMappingRule builder with application/json body
func NewSearchMappingRuleRequest(server string, body SearchMappingRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchMappingRuleRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchMappingRuleRequestWithBody generates requests for SearchMappingRule with any type of body
func NewSearchMappingRuleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mapping-rules/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMappingRuleRequest generates requests for DeleteMappingRule
func NewDeleteMappingRuleRequest(server string, mappingRuleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mappingRuleId", runtime.ParamLocationPath, mappingRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mapping-rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMappingRuleRequest generates requests for GetMappingRule
func NewGetMappingRuleRequest(server string, mappingRuleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mappingRuleId", runtime.ParamLocationPath, mappingRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mapping-rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMappingRuleRequest calls the generic UpdateMappingRule builder with application/json body
func NewUpdateMappingRuleRequest(server string, mappingRuleId string, body UpdateMappingRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMappingRuleRequestWithBody(server, mappingRuleId, "application/json", bodyReader)
}

// NewUpdateMappingRuleRequestWithBody generates requests for UpdateMappingRule with any type of body
func NewUpdateMappingRuleRequestWithBody(server string, mappingRuleId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mappingRuleId", runtime.ParamLocationPath, mappingRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mapping-rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchMessageSubscriptionsRequest calls the generic SearchMessageSubscriptions builder with application/json body
func NewSearchMessageSubscriptionsRequest(server string, body SearchMessageSubscriptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchMessageSubscriptionsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchMessageSubscriptionsRequestWithBody generates requests for SearchMessageSubscriptions with any type of body
func NewSearchMessageSubscriptionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/message-subscriptions/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCorrelateMessageRequest calls the generic CorrelateMessage builder with application/json body
func NewCorrelateMessageRequest(server string, body CorrelateMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCorrelateMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewCorrelateMessageRequestWithBody generates requests for CorrelateMessage with any type of body
func NewCorrelateMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/correlation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPublishMessageRequest calls the generic PublishMessage builder with application/json body
func NewPublishMessageRequest(server string, body PublishMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPublishMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewPublishMessageRequestWithBody generates requests for PublishMessage with any type of body
func NewPublishMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/publication")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchProcessDefinitionsRequest calls the generic SearchProcessDefinitions builder with application/json body
func NewSearchProcessDefinitionsRequest(server string, body SearchProcessDefinitionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchProcessDefinitionsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchProcessDefinitionsRequestWithBody generates requests for SearchProcessDefinitions with any type of body
func NewSearchProcessDefinitionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-definitions/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProcessDefinitionRequest generates requests for GetProcessDefinition
func NewGetProcessDefinitionRequest(server string, processDefinitionKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processDefinitionKey", runtime.ParamLocationPath, processDefinitionKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-definitions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStartProcessFormRequest generates requests for GetStartProcessForm
func NewGetStartProcessFormRequest(server string, processDefinitionKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processDefinitionKey", runtime.ParamLocationPath, processDefinitionKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-definitions/%s/form", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProcessDefinitionStatisticsRequest calls the generic GetProcessDefinitionStatistics builder with application/json body
func NewGetProcessDefinitionStatisticsRequest(server string, processDefinitionKey string, body GetProcessDefinitionStatisticsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetProcessDefinitionStatisticsRequestWithBody(server, processDefinitionKey, "application/json", bodyReader)
}

// NewGetProcessDefinitionStatisticsRequestWithBody generates requests for GetProcessDefinitionStatistics with any type of body
func NewGetProcessDefinitionStatisticsRequestWithBody(server string, processDefinitionKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processDefinitionKey", runtime.ParamLocationPath, processDefinitionKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-definitions/%s/statistics/element-instances", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProcessDefinitionXMLRequest generates requests for GetProcessDefinitionXML
func NewGetProcessDefinitionXMLRequest(server string, processDefinitionKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processDefinitionKey", runtime.ParamLocationPath, processDefinitionKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-definitions/%s/xml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProcessInstanceRequest calls the generic CreateProcessInstance builder with application/json body
func NewCreateProcessInstanceRequest(server string, body CreateProcessInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProcessInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateProcessInstanceRequestWithBody generates requests for CreateProcessInstance with any type of body
func NewCreateProcessInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelProcessInstancesBatchOperationRequest calls the generic CancelProcessInstancesBatchOperation builder with application/json body
func NewCancelProcessInstancesBatchOperationRequest(server string, body CancelProcessInstancesBatchOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelProcessInstancesBatchOperationRequestWithBody(server, "application/json", bodyReader)
}

// NewCancelProcessInstancesBatchOperationRequestWithBody generates requests for CancelProcessInstancesBatchOperation with any type of body
func NewCancelProcessInstancesBatchOperationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/cancellation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResolveIncidentsBatchOperationRequest calls the generic ResolveIncidentsBatchOperation builder with application/json body
func NewResolveIncidentsBatchOperationRequest(server string, body ResolveIncidentsBatchOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResolveIncidentsBatchOperationRequestWithBody(server, "application/json", bodyReader)
}

// NewResolveIncidentsBatchOperationRequestWithBody generates requests for ResolveIncidentsBatchOperation with any type of body
func NewResolveIncidentsBatchOperationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/incident-resolution")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMigrateProcessInstancesBatchOperationRequest calls the generic MigrateProcessInstancesBatchOperation builder with application/json body
func NewMigrateProcessInstancesBatchOperationRequest(server string, body MigrateProcessInstancesBatchOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMigrateProcessInstancesBatchOperationRequestWithBody(server, "application/json", bodyReader)
}

// NewMigrateProcessInstancesBatchOperationRequestWithBody generates requests for MigrateProcessInstancesBatchOperation with any type of body
func NewMigrateProcessInstancesBatchOperationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/migration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewModifyProcessInstancesBatchOperationRequest calls the generic ModifyProcessInstancesBatchOperation builder with application/json body
func NewModifyProcessInstancesBatchOperationRequest(server string, body ModifyProcessInstancesBatchOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyProcessInstancesBatchOperationRequestWithBody(server, "application/json", bodyReader)
}

// NewModifyProcessInstancesBatchOperationRequestWithBody generates requests for ModifyProcessInstancesBatchOperation with any type of body
func NewModifyProcessInstancesBatchOperationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/modification")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchProcessInstancesRequest calls the generic SearchProcessInstances builder with application/json body
func NewSearchProcessInstancesRequest(server string, body SearchProcessInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchProcessInstancesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchProcessInstancesRequestWithBody generates requests for SearchProcessInstances with any type of body
func NewSearchProcessInstancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProcessInstanceRequest generates requests for GetProcessInstance
func NewGetProcessInstanceRequest(server string, processInstanceKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processInstanceKey", runtime.ParamLocationPath, processInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProcessInstanceCallHierarchyRequest generates requests for GetProcessInstanceCallHierarchy
func NewGetProcessInstanceCallHierarchyRequest(server string, processInstanceKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processInstanceKey", runtime.ParamLocationPath, processInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s/call-hierarchy", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelProcessInstanceRequest calls the generic CancelProcessInstance builder with application/json body
func NewCancelProcessInstanceRequest(server string, processInstanceKey string, body CancelProcessInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelProcessInstanceRequestWithBody(server, processInstanceKey, "application/json", bodyReader)
}

// NewCancelProcessInstanceRequestWithBody generates requests for CancelProcessInstance with any type of body
func NewCancelProcessInstanceRequestWithBody(server string, processInstanceKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processInstanceKey", runtime.ParamLocationPath, processInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s/cancellation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchProcessInstanceIncidentsRequest calls the generic SearchProcessInstanceIncidents builder with application/json body
func NewSearchProcessInstanceIncidentsRequest(server string, processInstanceKey string, body SearchProcessInstanceIncidentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchProcessInstanceIncidentsRequestWithBody(server, processInstanceKey, "application/json", bodyReader)
}

// NewSearchProcessInstanceIncidentsRequestWithBody generates requests for SearchProcessInstanceIncidents with any type of body
func NewSearchProcessInstanceIncidentsRequestWithBody(server string, processInstanceKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processInstanceKey", runtime.ParamLocationPath, processInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s/incidents/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMigrateProcessInstanceRequest calls the generic MigrateProcessInstance builder with application/json body
func NewMigrateProcessInstanceRequest(server string, processInstanceKey string, body MigrateProcessInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMigrateProcessInstanceRequestWithBody(server, processInstanceKey, "application/json", bodyReader)
}

// NewMigrateProcessInstanceRequestWithBody generates requests for MigrateProcessInstance with any type of body
func NewMigrateProcessInstanceRequestWithBody(server string, processInstanceKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processInstanceKey", runtime.ParamLocationPath, processInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s/migration", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewModifyProcessInstanceRequest calls the generic ModifyProcessInstance builder with application/json body
func NewModifyProcessInstanceRequest(server string, processInstanceKey string, body ModifyProcessInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyProcessInstanceRequestWithBody(server, processInstanceKey, "application/json", bodyReader)
}

// NewModifyProcessInstanceRequestWithBody generates requests for ModifyProcessInstance with any type of body
func NewModifyProcessInstanceRequestWithBody(server string, processInstanceKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processInstanceKey", runtime.ParamLocationPath, processInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s/modification", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProcessInstanceSequenceFlowsRequest generates requests for GetProcessInstanceSequenceFlows
func NewGetProcessInstanceSequenceFlowsRequest(server string, processInstanceKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processInstanceKey", runtime.ParamLocationPath, processInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s/sequence-flows", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProcessInstanceStatisticsRequest generates requests for GetProcessInstanceStatistics
func NewGetProcessInstanceStatisticsRequest(server string, processInstanceKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processInstanceKey", runtime.ParamLocationPath, processInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s/statistics/element-instances", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceRequest generates requests for GetResource
func NewGetResourceRequest(server string, resourceKey ResourceKey) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceKey", runtime.ParamLocationPath, resourceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceContentRequest generates requests for GetResourceContent
func NewGetResourceContentRequest(server string, resourceKey ResourceKey) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceKey", runtime.ParamLocationPath, resourceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/%s/content", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteResourceRequest calls the generic DeleteResource builder with application/json body
func NewDeleteResourceRequest(server string, resourceKey ResourceKey, body DeleteResourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteResourceRequestWithBody(server, resourceKey, "application/json", bodyReader)
}

// NewDeleteResourceRequestWithBody generates requests for DeleteResource with any type of body
func NewDeleteResourceRequestWithBody(server string, resourceKey ResourceKey, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceKey", runtime.ParamLocationPath, resourceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/%s/deletion", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateRoleRequest calls the generic CreateRole builder with application/json body
func NewCreateRoleRequest(server string, body CreateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRoleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRoleRequestWithBody generates requests for CreateRole with any type of body
func NewCreateRoleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchRolesRequest calls the generic SearchRoles builder with application/json body
func NewSearchRolesRequest(server string, body SearchRolesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchRolesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchRolesRequestWithBody generates requests for SearchRoles with any type of body
func NewSearchRolesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRoleRequest generates requests for DeleteRole
func NewDeleteRoleRequest(server string, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRoleRequest generates requests for GetRole
func NewGetRoleRequest(server string, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRoleRequest calls the generic UpdateRole builder with application/json body
func NewUpdateRoleRequest(server string, roleId string, body UpdateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRoleRequestWithBody(server, roleId, "application/json", bodyReader)
}

// NewUpdateRoleRequestWithBody generates requests for UpdateRole with any type of body
func NewUpdateRoleRequestWithBody(server string, roleId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchClientsForRoleRequest calls the generic SearchClientsForRole builder with application/json body
func NewSearchClientsForRoleRequest(server string, roleId string, body SearchClientsForRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchClientsForRoleRequestWithBody(server, roleId, "application/json", bodyReader)
}

// NewSearchClientsForRoleRequestWithBody generates requests for SearchClientsForRole with any type of body
func NewSearchClientsForRoleRequestWithBody(server string, roleId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/clients/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignRoleFromClientRequest generates requests for UnassignRoleFromClient
func NewUnassignRoleFromClientRequest(server string, roleId string, clientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/clients/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignRoleToClientRequest generates requests for AssignRoleToClient
func NewAssignRoleToClientRequest(server string, roleId string, clientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/clients/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchGroupsForRoleRequest calls the generic SearchGroupsForRole builder with application/json body
func NewSearchGroupsForRoleRequest(server string, roleId string, body SearchGroupsForRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchGroupsForRoleRequestWithBody(server, roleId, "application/json", bodyReader)
}

// NewSearchGroupsForRoleRequestWithBody generates requests for SearchGroupsForRole with any type of body
func NewSearchGroupsForRoleRequestWithBody(server string, roleId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/groups/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignRoleFromGroupRequest generates requests for UnassignRoleFromGroup
func NewUnassignRoleFromGroupRequest(server string, roleId string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignRoleToGroupRequest generates requests for AssignRoleToGroup
func NewAssignRoleToGroupRequest(server string, roleId string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchMappingRulesForRoleRequest calls the generic SearchMappingRulesForRole builder with application/json body
func NewSearchMappingRulesForRoleRequest(server string, roleId string, body SearchMappingRulesForRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchMappingRulesForRoleRequestWithBody(server, roleId, "application/json", bodyReader)
}

// NewSearchMappingRulesForRoleRequestWithBody generates requests for SearchMappingRulesForRole with any type of body
func NewSearchMappingRulesForRoleRequestWithBody(server string, roleId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/mapping-rules/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignRoleFromMappingRuleRequest generates requests for UnassignRoleFromMappingRule
func NewUnassignRoleFromMappingRuleRequest(server string, roleId string, mappingRuleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "mappingRuleId", runtime.ParamLocationPath, mappingRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/mapping-rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignRoleToMappingRuleRequest generates requests for AssignRoleToMappingRule
func NewAssignRoleToMappingRuleRequest(server string, roleId string, mappingRuleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "mappingRuleId", runtime.ParamLocationPath, mappingRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/mapping-rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchUsersForRoleRequest calls the generic SearchUsersForRole builder with application/json body
func NewSearchUsersForRoleRequest(server string, roleId string, body SearchUsersForRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchUsersForRoleRequestWithBody(server, roleId, "application/json", bodyReader)
}

// NewSearchUsersForRoleRequestWithBody generates requests for SearchUsersForRole with any type of body
func NewSearchUsersForRoleRequestWithBody(server string, roleId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/users/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignRoleFromUserRequest generates requests for UnassignRoleFromUser
func NewUnassignRoleFromUserRequest(server string, roleId string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignRoleToUserRequest generates requests for AssignRoleToUser
func NewAssignRoleToUserRequest(server string, roleId string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAdminUserRequest calls the generic CreateAdminUser builder with application/json body
func NewCreateAdminUserRequest(server string, body CreateAdminUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAdminUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAdminUserRequestWithBody generates requests for CreateAdminUser with any type of body
func NewCreateAdminUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setup/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBroadcastSignalRequest calls the generic BroadcastSignal builder with application/json body
func NewBroadcastSignalRequest(server string, body BroadcastSignalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBroadcastSignalRequestWithBody(server, "application/json", bodyReader)
}

// NewBroadcastSignalRequestWithBody generates requests for BroadcastSignal with any type of body
func NewBroadcastSignalRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/signals/broadcast")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStatusRequest generates requests for GetStatus
func NewGetStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsageMetricsRequest generates requests for GetUsageMetrics
func NewGetUsageMetricsRequest(server string, params *GetUsageMetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/usage-metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endTime", runtime.ParamLocationQuery, params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TenantId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tenantId", runtime.ParamLocationQuery, *params.TenantId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithTenants != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withTenants", runtime.ParamLocationQuery, *params.WithTenants); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTenantRequest calls the generic CreateTenant builder with application/json body
func NewCreateTenantRequest(server string, body CreateTenantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTenantRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTenantRequestWithBody generates requests for CreateTenant with any type of body
func NewCreateTenantRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchTenantsRequest calls the generic SearchTenants builder with application/json body
func NewSearchTenantsRequest(server string, body SearchTenantsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchTenantsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchTenantsRequestWithBody generates requests for SearchTenants with any type of body
func NewSearchTenantsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTenantRequest generates requests for DeleteTenant
func NewDeleteTenantRequest(server string, tenantId TenantId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTenantRequest generates requests for GetTenant
func NewGetTenantRequest(server string, tenantId TenantId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTenantRequest calls the generic UpdateTenant builder with application/json body
func NewUpdateTenantRequest(server string, tenantId TenantId, body UpdateTenantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTenantRequestWithBody(server, tenantId, "application/json", bodyReader)
}

// NewUpdateTenantRequestWithBody generates requests for UpdateTenant with any type of body
func NewUpdateTenantRequestWithBody(server string, tenantId TenantId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchClientsForTenantRequest calls the generic SearchClientsForTenant builder with application/json body
func NewSearchClientsForTenantRequest(server string, tenantId TenantId, body SearchClientsForTenantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchClientsForTenantRequestWithBody(server, tenantId, "application/json", bodyReader)
}

// NewSearchClientsForTenantRequestWithBody generates requests for SearchClientsForTenant with any type of body
func NewSearchClientsForTenantRequestWithBody(server string, tenantId TenantId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/clients/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignClientFromTenantRequest generates requests for UnassignClientFromTenant
func NewUnassignClientFromTenantRequest(server string, tenantId TenantId, clientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/clients/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignClientToTenantRequest generates requests for AssignClientToTenant
func NewAssignClientToTenantRequest(server string, tenantId TenantId, clientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/clients/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchGroupIdsForTenantRequest calls the generic SearchGroupIdsForTenant builder with application/json body
func NewSearchGroupIdsForTenantRequest(server string, tenantId TenantId, body SearchGroupIdsForTenantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchGroupIdsForTenantRequestWithBody(server, tenantId, "application/json", bodyReader)
}

// NewSearchGroupIdsForTenantRequestWithBody generates requests for SearchGroupIdsForTenant with any type of body
func NewSearchGroupIdsForTenantRequestWithBody(server string, tenantId TenantId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/groups/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignGroupFromTenantRequest generates requests for UnassignGroupFromTenant
func NewUnassignGroupFromTenantRequest(server string, tenantId TenantId, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignGroupToTenantRequest generates requests for AssignGroupToTenant
func NewAssignGroupToTenantRequest(server string, tenantId TenantId, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchMappingRulesForTenantRequest calls the generic SearchMappingRulesForTenant builder with application/json body
func NewSearchMappingRulesForTenantRequest(server string, tenantId TenantId, body SearchMappingRulesForTenantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchMappingRulesForTenantRequestWithBody(server, tenantId, "application/json", bodyReader)
}

// NewSearchMappingRulesForTenantRequestWithBody generates requests for SearchMappingRulesForTenant with any type of body
func NewSearchMappingRulesForTenantRequestWithBody(server string, tenantId TenantId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/mapping-rules/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignMappingRuleFromTenantRequest generates requests for UnassignMappingRuleFromTenant
func NewUnassignMappingRuleFromTenantRequest(server string, tenantId TenantId, mappingRuleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "mappingRuleId", runtime.ParamLocationPath, mappingRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/mapping-rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignMappingRuleToTenantRequest generates requests for AssignMappingRuleToTenant
func NewAssignMappingRuleToTenantRequest(server string, tenantId TenantId, mappingRuleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "mappingRuleId", runtime.ParamLocationPath, mappingRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/mapping-rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchRolesForTenantRequest calls the generic SearchRolesForTenant builder with application/json body
func NewSearchRolesForTenantRequest(server string, tenantId TenantId, body SearchRolesForTenantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchRolesForTenantRequestWithBody(server, tenantId, "application/json", bodyReader)
}

// NewSearchRolesForTenantRequestWithBody generates requests for SearchRolesForTenant with any type of body
func NewSearchRolesForTenantRequestWithBody(server string, tenantId TenantId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/roles/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignRoleFromTenantRequest generates requests for UnassignRoleFromTenant
func NewUnassignRoleFromTenantRequest(server string, tenantId TenantId, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignRoleToTenantRequest generates requests for AssignRoleToTenant
func NewAssignRoleToTenantRequest(server string, tenantId TenantId, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchUsersForTenantRequest calls the generic SearchUsersForTenant builder with application/json body
func NewSearchUsersForTenantRequest(server string, tenantId TenantId, body SearchUsersForTenantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchUsersForTenantRequestWithBody(server, tenantId, "application/json", bodyReader)
}

// NewSearchUsersForTenantRequestWithBody generates requests for SearchUsersForTenant with any type of body
func NewSearchUsersForTenantRequestWithBody(server string, tenantId TenantId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/users/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignUserFromTenantRequest generates requests for UnassignUserFromTenant
func NewUnassignUserFromTenantRequest(server string, tenantId TenantId, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignUserToTenantRequest generates requests for AssignUserToTenant
func NewAssignUserToTenantRequest(server string, tenantId TenantId, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTopologyRequest generates requests for GetTopology
func NewGetTopologyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/topology")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchUserTasksRequest calls the generic SearchUserTasks builder with application/json body
func NewSearchUserTasksRequest(server string, body SearchUserTasksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchUserTasksRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchUserTasksRequestWithBody generates requests for SearchUserTasks with any type of body
func NewSearchUserTasksRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserTaskRequest generates requests for GetUserTask
func NewGetUserTaskRequest(server string, userTaskKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userTaskKey", runtime.ParamLocationPath, userTaskKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserTaskRequest calls the generic UpdateUserTask builder with application/json body
func NewUpdateUserTaskRequest(server string, userTaskKey string, body UpdateUserTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserTaskRequestWithBody(server, userTaskKey, "application/json", bodyReader)
}

// NewUpdateUserTaskRequestWithBody generates requests for UpdateUserTask with any type of body
func NewUpdateUserTaskRequestWithBody(server string, userTaskKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userTaskKey", runtime.ParamLocationPath, userTaskKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignUserTaskRequest generates requests for UnassignUserTask
func NewUnassignUserTaskRequest(server string, userTaskKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userTaskKey", runtime.ParamLocationPath, userTaskKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/%s/assignee", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignUserTaskRequest calls the generic AssignUserTask builder with application/json body
func NewAssignUserTaskRequest(server string, userTaskKey string, body AssignUserTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssignUserTaskRequestWithBody(server, userTaskKey, "application/json", bodyReader)
}

// NewAssignUserTaskRequestWithBody generates requests for AssignUserTask with any type of body
func NewAssignUserTaskRequestWithBody(server string, userTaskKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userTaskKey", runtime.ParamLocationPath, userTaskKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/%s/assignment", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCompleteUserTaskRequest calls the generic CompleteUserTask builder with application/json body
func NewCompleteUserTaskRequest(server string, userTaskKey string, body CompleteUserTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCompleteUserTaskRequestWithBody(server, userTaskKey, "application/json", bodyReader)
}

// NewCompleteUserTaskRequestWithBody generates requests for CompleteUserTask with any type of body
func NewCompleteUserTaskRequestWithBody(server string, userTaskKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userTaskKey", runtime.ParamLocationPath, userTaskKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/%s/completion", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserTaskFormRequest generates requests for GetUserTaskForm
func NewGetUserTaskFormRequest(server string, userTaskKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userTaskKey", runtime.ParamLocationPath, userTaskKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/%s/form", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchUserTaskVariablesRequest calls the generic SearchUserTaskVariables builder with application/json body
func NewSearchUserTaskVariablesRequest(server string, userTaskKey string, body SearchUserTaskVariablesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchUserTaskVariablesRequestWithBody(server, userTaskKey, "application/json", bodyReader)
}

// NewSearchUserTaskVariablesRequestWithBody generates requests for SearchUserTaskVariables with any type of body
func NewSearchUserTaskVariablesRequestWithBody(server string, userTaskKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userTaskKey", runtime.ParamLocationPath, userTaskKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/%s/variables/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchUsersRequest calls the generic SearchUsers builder with application/json body
func NewSearchUsersRequest(server string, body SearchUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchUsersRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchUsersRequestWithBody generates requests for SearchUsers with any type of body
func NewSearchUsersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, username Username, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, username, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, username Username, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchVariablesRequest calls the generic SearchVariables builder with application/json body
func NewSearchVariablesRequest(server string, body SearchVariablesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchVariablesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchVariablesRequestWithBody generates requests for SearchVariables with any type of body
func NewSearchVariablesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/variables/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVariableRequest generates requests for GetVariable
func NewGetVariableRequest(server string, variableKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "variableKey", runtime.ParamLocationPath, variableKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/variables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAuthenticationWithResponse request
	GetAuthenticationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthenticationResponse, error)

	// CreateAuthorizationWithBodyWithResponse request with any body
	CreateAuthorizationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAuthorizationResponse, error)

	CreateAuthorizationWithResponse(ctx context.Context, body CreateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAuthorizationResponse, error)

	// SearchAuthorizationsWithBodyWithResponse request with any body
	SearchAuthorizationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchAuthorizationsResponse, error)

	SearchAuthorizationsWithResponse(ctx context.Context, body SearchAuthorizationsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchAuthorizationsResponse, error)

	// DeleteAuthorizationWithResponse request
	DeleteAuthorizationWithResponse(ctx context.Context, authorizationKey string, reqEditors ...RequestEditorFn) (*DeleteAuthorizationResponse, error)

	// GetAuthorizationWithResponse request
	GetAuthorizationWithResponse(ctx context.Context, authorizationKey string, reqEditors ...RequestEditorFn) (*GetAuthorizationResponse, error)

	// UpdateAuthorizationWithBodyWithResponse request with any body
	UpdateAuthorizationWithBodyWithResponse(ctx context.Context, authorizationKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAuthorizationResponse, error)

	UpdateAuthorizationWithResponse(ctx context.Context, authorizationKey string, body UpdateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAuthorizationResponse, error)

	// SearchBatchOperationItemsWithBodyWithResponse request with any body
	SearchBatchOperationItemsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchBatchOperationItemsResponse, error)

	SearchBatchOperationItemsWithResponse(ctx context.Context, body SearchBatchOperationItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchBatchOperationItemsResponse, error)

	// SearchBatchOperationsWithBodyWithResponse request with any body
	SearchBatchOperationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchBatchOperationsResponse, error)

	SearchBatchOperationsWithResponse(ctx context.Context, body SearchBatchOperationsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchBatchOperationsResponse, error)

	// GetBatchOperationWithResponse request
	GetBatchOperationWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, reqEditors ...RequestEditorFn) (*GetBatchOperationResponse, error)

	// CancelBatchOperationWithBodyWithResponse request with any body
	CancelBatchOperationWithBodyWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelBatchOperationResponse, error)

	CancelBatchOperationWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, body CancelBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelBatchOperationResponse, error)

	// ResumeBatchOperationWithBodyWithResponse request with any body
	ResumeBatchOperationWithBodyWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResumeBatchOperationResponse, error)

	ResumeBatchOperationWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, body ResumeBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*ResumeBatchOperationResponse, error)

	// SuspendBatchOperationWithBodyWithResponse request with any body
	SuspendBatchOperationWithBodyWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SuspendBatchOperationResponse, error)

	SuspendBatchOperationWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, body SuspendBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*SuspendBatchOperationResponse, error)

	// PinClockWithBodyWithResponse request with any body
	PinClockWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PinClockResponse, error)

	PinClockWithResponse(ctx context.Context, body PinClockJSONRequestBody, reqEditors ...RequestEditorFn) (*PinClockResponse, error)

	// ResetClockWithResponse request
	ResetClockWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResetClockResponse, error)

	// SearchCorrelatedMessageSubscriptionsWithBodyWithResponse request with any body
	SearchCorrelatedMessageSubscriptionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchCorrelatedMessageSubscriptionsResponse, error)

	SearchCorrelatedMessageSubscriptionsWithResponse(ctx context.Context, body SearchCorrelatedMessageSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchCorrelatedMessageSubscriptionsResponse, error)

	// EvaluateDecisionWithBodyWithResponse request with any body
	EvaluateDecisionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EvaluateDecisionResponse, error)

	EvaluateDecisionWithResponse(ctx context.Context, body EvaluateDecisionJSONRequestBody, reqEditors ...RequestEditorFn) (*EvaluateDecisionResponse, error)

	// SearchDecisionDefinitionsWithBodyWithResponse request with any body
	SearchDecisionDefinitionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDecisionDefinitionsResponse, error)

	SearchDecisionDefinitionsWithResponse(ctx context.Context, body SearchDecisionDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDecisionDefinitionsResponse, error)

	// GetDecisionDefinitionWithResponse request
	GetDecisionDefinitionWithResponse(ctx context.Context, decisionDefinitionKey string, reqEditors ...RequestEditorFn) (*GetDecisionDefinitionResponse, error)

	// GetDecisionDefinitionXMLWithResponse request
	GetDecisionDefinitionXMLWithResponse(ctx context.Context, decisionDefinitionKey string, reqEditors ...RequestEditorFn) (*GetDecisionDefinitionXMLResponse, error)

	// SearchDecisionInstancesWithBodyWithResponse request with any body
	SearchDecisionInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDecisionInstancesResponse, error)

	SearchDecisionInstancesWithResponse(ctx context.Context, body SearchDecisionInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDecisionInstancesResponse, error)

	// GetDecisionInstanceWithResponse request
	GetDecisionInstanceWithResponse(ctx context.Context, decisionEvaluationInstanceKey string, reqEditors ...RequestEditorFn) (*GetDecisionInstanceResponse, error)

	// SearchDecisionRequirementsWithBodyWithResponse request with any body
	SearchDecisionRequirementsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDecisionRequirementsResponse, error)

	SearchDecisionRequirementsWithResponse(ctx context.Context, body SearchDecisionRequirementsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDecisionRequirementsResponse, error)

	// GetDecisionRequirementsWithResponse request
	GetDecisionRequirementsWithResponse(ctx context.Context, decisionRequirementsKey string, reqEditors ...RequestEditorFn) (*GetDecisionRequirementsResponse, error)

	// GetDecisionRequirementsXMLWithResponse request
	GetDecisionRequirementsXMLWithResponse(ctx context.Context, decisionRequirementsKey string, reqEditors ...RequestEditorFn) (*GetDecisionRequirementsXMLResponse, error)

	// CreateDeploymentWithBodyWithResponse request with any body
	CreateDeploymentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeploymentResponse, error)

	// CreateDocumentWithBodyWithResponse request with any body
	CreateDocumentWithBodyWithResponse(ctx context.Context, params *CreateDocumentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDocumentResponse, error)

	// CreateDocumentsWithBodyWithResponse request with any body
	CreateDocumentsWithBodyWithResponse(ctx context.Context, params *CreateDocumentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDocumentsResponse, error)

	// DeleteDocumentWithResponse request
	DeleteDocumentWithResponse(ctx context.Context, documentId DocumentId, params *DeleteDocumentParams, reqEditors ...RequestEditorFn) (*DeleteDocumentResponse, error)

	// GetDocumentWithResponse request
	GetDocumentWithResponse(ctx context.Context, documentId DocumentId, params *GetDocumentParams, reqEditors ...RequestEditorFn) (*GetDocumentResponse, error)

	// CreateDocumentLinkWithBodyWithResponse request with any body
	CreateDocumentLinkWithBodyWithResponse(ctx context.Context, documentId DocumentId, params *CreateDocumentLinkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDocumentLinkResponse, error)

	CreateDocumentLinkWithResponse(ctx context.Context, documentId DocumentId, params *CreateDocumentLinkParams, body CreateDocumentLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDocumentLinkResponse, error)

	// ActivateAdHocSubProcessActivitiesWithBodyWithResponse request with any body
	ActivateAdHocSubProcessActivitiesWithBodyWithResponse(ctx context.Context, adHocSubProcessInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateAdHocSubProcessActivitiesResponse, error)

	ActivateAdHocSubProcessActivitiesWithResponse(ctx context.Context, adHocSubProcessInstanceKey string, body ActivateAdHocSubProcessActivitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateAdHocSubProcessActivitiesResponse, error)

	// SearchElementInstancesWithBodyWithResponse request with any body
	SearchElementInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchElementInstancesResponse, error)

	SearchElementInstancesWithResponse(ctx context.Context, body SearchElementInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchElementInstancesResponse, error)

	// GetElementInstanceWithResponse request
	GetElementInstanceWithResponse(ctx context.Context, elementInstanceKey string, reqEditors ...RequestEditorFn) (*GetElementInstanceResponse, error)

	// CreateElementInstanceVariablesWithBodyWithResponse request with any body
	CreateElementInstanceVariablesWithBodyWithResponse(ctx context.Context, elementInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateElementInstanceVariablesResponse, error)

	CreateElementInstanceVariablesWithResponse(ctx context.Context, elementInstanceKey string, body CreateElementInstanceVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateElementInstanceVariablesResponse, error)

	// CreateGroupWithBodyWithResponse request with any body
	CreateGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	CreateGroupWithResponse(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	// SearchGroupsWithBodyWithResponse request with any body
	SearchGroupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchGroupsResponse, error)

	SearchGroupsWithResponse(ctx context.Context, body SearchGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchGroupsResponse, error)

	// DeleteGroupWithResponse request
	DeleteGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error)

	// GetGroupWithResponse request
	GetGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupResponse, error)

	// UpdateGroupWithBodyWithResponse request with any body
	UpdateGroupWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error)

	UpdateGroupWithResponse(ctx context.Context, groupId string, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error)

	// SearchClientsForGroupWithBodyWithResponse request with any body
	SearchClientsForGroupWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchClientsForGroupResponse, error)

	SearchClientsForGroupWithResponse(ctx context.Context, groupId string, body SearchClientsForGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchClientsForGroupResponse, error)

	// UnassignClientFromGroupWithResponse request
	UnassignClientFromGroupWithResponse(ctx context.Context, groupId string, clientId string, reqEditors ...RequestEditorFn) (*UnassignClientFromGroupResponse, error)

	// AssignClientToGroupWithResponse request
	AssignClientToGroupWithResponse(ctx context.Context, groupId string, clientId string, reqEditors ...RequestEditorFn) (*AssignClientToGroupResponse, error)

	// SearchMappingRulesForGroupWithBodyWithResponse request with any body
	SearchMappingRulesForGroupWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchMappingRulesForGroupResponse, error)

	SearchMappingRulesForGroupWithResponse(ctx context.Context, groupId string, body SearchMappingRulesForGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchMappingRulesForGroupResponse, error)

	// UnassignMappingRuleFromGroupWithResponse request
	UnassignMappingRuleFromGroupWithResponse(ctx context.Context, groupId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*UnassignMappingRuleFromGroupResponse, error)

	// AssignMappingRuleToGroupWithResponse request
	AssignMappingRuleToGroupWithResponse(ctx context.Context, groupId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*AssignMappingRuleToGroupResponse, error)

	// SearchRolesForGroupWithBodyWithResponse request with any body
	SearchRolesForGroupWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchRolesForGroupResponse, error)

	SearchRolesForGroupWithResponse(ctx context.Context, groupId string, body SearchRolesForGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchRolesForGroupResponse, error)

	// SearchUsersForGroupWithBodyWithResponse request with any body
	SearchUsersForGroupWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUsersForGroupResponse, error)

	SearchUsersForGroupWithResponse(ctx context.Context, groupId string, body SearchUsersForGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUsersForGroupResponse, error)

	// UnassignUserFromGroupWithResponse request
	UnassignUserFromGroupWithResponse(ctx context.Context, groupId string, username Username, reqEditors ...RequestEditorFn) (*UnassignUserFromGroupResponse, error)

	// AssignUserToGroupWithResponse request
	AssignUserToGroupWithResponse(ctx context.Context, groupId string, username Username, reqEditors ...RequestEditorFn) (*AssignUserToGroupResponse, error)

	// SearchIncidentsWithBodyWithResponse request with any body
	SearchIncidentsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchIncidentsResponse, error)

	SearchIncidentsWithResponse(ctx context.Context, body SearchIncidentsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchIncidentsResponse, error)

	// GetIncidentWithResponse request
	GetIncidentWithResponse(ctx context.Context, incidentKey string, reqEditors ...RequestEditorFn) (*GetIncidentResponse, error)

	// ResolveIncidentWithBodyWithResponse request with any body
	ResolveIncidentWithBodyWithResponse(ctx context.Context, incidentKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResolveIncidentResponse, error)

	ResolveIncidentWithResponse(ctx context.Context, incidentKey string, body ResolveIncidentJSONRequestBody, reqEditors ...RequestEditorFn) (*ResolveIncidentResponse, error)

	// ActivateJobsWithBodyWithResponse request with any body
	ActivateJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateJobsResponse, error)

	ActivateJobsWithResponse(ctx context.Context, body ActivateJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateJobsResponse, error)

	// SearchJobsWithBodyWithResponse request with any body
	SearchJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchJobsResponse, error)

	SearchJobsWithResponse(ctx context.Context, body SearchJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchJobsResponse, error)

	// UpdateJobWithBodyWithResponse request with any body
	UpdateJobWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error)

	UpdateJobWithResponse(ctx context.Context, jobKey string, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error)

	// CompleteJobWithBodyWithResponse request with any body
	CompleteJobWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompleteJobResponse, error)

	CompleteJobWithResponse(ctx context.Context, jobKey string, body CompleteJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CompleteJobResponse, error)

	// ThrowJobErrorWithBodyWithResponse request with any body
	ThrowJobErrorWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ThrowJobErrorResponse, error)

	ThrowJobErrorWithResponse(ctx context.Context, jobKey string, body ThrowJobErrorJSONRequestBody, reqEditors ...RequestEditorFn) (*ThrowJobErrorResponse, error)

	// FailJobWithBodyWithResponse request with any body
	FailJobWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FailJobResponse, error)

	FailJobWithResponse(ctx context.Context, jobKey string, body FailJobJSONRequestBody, reqEditors ...RequestEditorFn) (*FailJobResponse, error)

	// GetLicenseWithResponse request
	GetLicenseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLicenseResponse, error)

	// CreateMappingRuleWithBodyWithResponse request with any body
	CreateMappingRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMappingRuleResponse, error)

	CreateMappingRuleWithResponse(ctx context.Context, body CreateMappingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMappingRuleResponse, error)

	// SearchMappingRuleWithBodyWithResponse request with any body
	SearchMappingRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchMappingRuleResponse, error)

	SearchMappingRuleWithResponse(ctx context.Context, body SearchMappingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchMappingRuleResponse, error)

	// DeleteMappingRuleWithResponse request
	DeleteMappingRuleWithResponse(ctx context.Context, mappingRuleId string, reqEditors ...RequestEditorFn) (*DeleteMappingRuleResponse, error)

	// GetMappingRuleWithResponse request
	GetMappingRuleWithResponse(ctx context.Context, mappingRuleId string, reqEditors ...RequestEditorFn) (*GetMappingRuleResponse, error)

	// UpdateMappingRuleWithBodyWithResponse request with any body
	UpdateMappingRuleWithBodyWithResponse(ctx context.Context, mappingRuleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMappingRuleResponse, error)

	UpdateMappingRuleWithResponse(ctx context.Context, mappingRuleId string, body UpdateMappingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMappingRuleResponse, error)

	// SearchMessageSubscriptionsWithBodyWithResponse request with any body
	SearchMessageSubscriptionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchMessageSubscriptionsResponse, error)

	SearchMessageSubscriptionsWithResponse(ctx context.Context, body SearchMessageSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchMessageSubscriptionsResponse, error)

	// CorrelateMessageWithBodyWithResponse request with any body
	CorrelateMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CorrelateMessageResponse, error)

	CorrelateMessageWithResponse(ctx context.Context, body CorrelateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*CorrelateMessageResponse, error)

	// PublishMessageWithBodyWithResponse request with any body
	PublishMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PublishMessageResponse, error)

	PublishMessageWithResponse(ctx context.Context, body PublishMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*PublishMessageResponse, error)

	// SearchProcessDefinitionsWithBodyWithResponse request with any body
	SearchProcessDefinitionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchProcessDefinitionsResponse, error)

	SearchProcessDefinitionsWithResponse(ctx context.Context, body SearchProcessDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchProcessDefinitionsResponse, error)

	// GetProcessDefinitionWithResponse request
	GetProcessDefinitionWithResponse(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*GetProcessDefinitionResponse, error)

	// GetStartProcessFormWithResponse request
	GetStartProcessFormWithResponse(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*GetStartProcessFormResponse, error)

	// GetProcessDefinitionStatisticsWithBodyWithResponse request with any body
	GetProcessDefinitionStatisticsWithBodyWithResponse(ctx context.Context, processDefinitionKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetProcessDefinitionStatisticsResponse, error)

	GetProcessDefinitionStatisticsWithResponse(ctx context.Context, processDefinitionKey string, body GetProcessDefinitionStatisticsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetProcessDefinitionStatisticsResponse, error)

	// GetProcessDefinitionXMLWithResponse request
	GetProcessDefinitionXMLWithResponse(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*GetProcessDefinitionXMLResponse, error)

	// CreateProcessInstanceWithBodyWithResponse request with any body
	CreateProcessInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProcessInstanceResponse, error)

	CreateProcessInstanceWithResponse(ctx context.Context, body CreateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProcessInstanceResponse, error)

	// CancelProcessInstancesBatchOperationWithBodyWithResponse request with any body
	CancelProcessInstancesBatchOperationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelProcessInstancesBatchOperationResponse, error)

	CancelProcessInstancesBatchOperationWithResponse(ctx context.Context, body CancelProcessInstancesBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelProcessInstancesBatchOperationResponse, error)

	// ResolveIncidentsBatchOperationWithBodyWithResponse request with any body
	ResolveIncidentsBatchOperationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResolveIncidentsBatchOperationResponse, error)

	ResolveIncidentsBatchOperationWithResponse(ctx context.Context, body ResolveIncidentsBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*ResolveIncidentsBatchOperationResponse, error)

	// MigrateProcessInstancesBatchOperationWithBodyWithResponse request with any body
	MigrateProcessInstancesBatchOperationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrateProcessInstancesBatchOperationResponse, error)

	MigrateProcessInstancesBatchOperationWithResponse(ctx context.Context, body MigrateProcessInstancesBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrateProcessInstancesBatchOperationResponse, error)

	// ModifyProcessInstancesBatchOperationWithBodyWithResponse request with any body
	ModifyProcessInstancesBatchOperationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyProcessInstancesBatchOperationResponse, error)

	ModifyProcessInstancesBatchOperationWithResponse(ctx context.Context, body ModifyProcessInstancesBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyProcessInstancesBatchOperationResponse, error)

	// SearchProcessInstancesWithBodyWithResponse request with any body
	SearchProcessInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchProcessInstancesResponse, error)

	SearchProcessInstancesWithResponse(ctx context.Context, body SearchProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchProcessInstancesResponse, error)

	// GetProcessInstanceWithResponse request
	GetProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*GetProcessInstanceResponse, error)

	// GetProcessInstanceCallHierarchyWithResponse request
	GetProcessInstanceCallHierarchyWithResponse(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*GetProcessInstanceCallHierarchyResponse, error)

	// CancelProcessInstanceWithBodyWithResponse request with any body
	CancelProcessInstanceWithBodyWithResponse(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelProcessInstanceResponse, error)

	CancelProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, body CancelProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelProcessInstanceResponse, error)

	// SearchProcessInstanceIncidentsWithBodyWithResponse request with any body
	SearchProcessInstanceIncidentsWithBodyWithResponse(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchProcessInstanceIncidentsResponse, error)

	SearchProcessInstanceIncidentsWithResponse(ctx context.Context, processInstanceKey string, body SearchProcessInstanceIncidentsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchProcessInstanceIncidentsResponse, error)

	// MigrateProcessInstanceWithBodyWithResponse request with any body
	MigrateProcessInstanceWithBodyWithResponse(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrateProcessInstanceResponse, error)

	MigrateProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, body MigrateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrateProcessInstanceResponse, error)

	// ModifyProcessInstanceWithBodyWithResponse request with any body
	ModifyProcessInstanceWithBodyWithResponse(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyProcessInstanceResponse, error)

	ModifyProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, body ModifyProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyProcessInstanceResponse, error)

	// GetProcessInstanceSequenceFlowsWithResponse request
	GetProcessInstanceSequenceFlowsWithResponse(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*GetProcessInstanceSequenceFlowsResponse, error)

	// GetProcessInstanceStatisticsWithResponse request
	GetProcessInstanceStatisticsWithResponse(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*GetProcessInstanceStatisticsResponse, error)

	// GetResourceWithResponse request
	GetResourceWithResponse(ctx context.Context, resourceKey ResourceKey, reqEditors ...RequestEditorFn) (*GetResourceResponse, error)

	// GetResourceContentWithResponse request
	GetResourceContentWithResponse(ctx context.Context, resourceKey ResourceKey, reqEditors ...RequestEditorFn) (*GetResourceContentResponse, error)

	// DeleteResourceWithBodyWithResponse request with any body
	DeleteResourceWithBodyWithResponse(ctx context.Context, resourceKey ResourceKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteResourceResponse, error)

	DeleteResourceWithResponse(ctx context.Context, resourceKey ResourceKey, body DeleteResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteResourceResponse, error)

	// CreateRoleWithBodyWithResponse request with any body
	CreateRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error)

	CreateRoleWithResponse(ctx context.Context, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error)

	// SearchRolesWithBodyWithResponse request with any body
	SearchRolesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchRolesResponse, error)

	SearchRolesWithResponse(ctx context.Context, body SearchRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchRolesResponse, error)

	// DeleteRoleWithResponse request
	DeleteRoleWithResponse(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*DeleteRoleResponse, error)

	// GetRoleWithResponse request
	GetRoleWithResponse(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*GetRoleResponse, error)

	// UpdateRoleWithBodyWithResponse request with any body
	UpdateRoleWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error)

	UpdateRoleWithResponse(ctx context.Context, roleId string, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error)

	// SearchClientsForRoleWithBodyWithResponse request with any body
	SearchClientsForRoleWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchClientsForRoleResponse, error)

	SearchClientsForRoleWithResponse(ctx context.Context, roleId string, body SearchClientsForRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchClientsForRoleResponse, error)

	// UnassignRoleFromClientWithResponse request
	UnassignRoleFromClientWithResponse(ctx context.Context, roleId string, clientId string, reqEditors ...RequestEditorFn) (*UnassignRoleFromClientResponse, error)

	// AssignRoleToClientWithResponse request
	AssignRoleToClientWithResponse(ctx context.Context, roleId string, clientId string, reqEditors ...RequestEditorFn) (*AssignRoleToClientResponse, error)

	// SearchGroupsForRoleWithBodyWithResponse request with any body
	SearchGroupsForRoleWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchGroupsForRoleResponse, error)

	SearchGroupsForRoleWithResponse(ctx context.Context, roleId string, body SearchGroupsForRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchGroupsForRoleResponse, error)

	// UnassignRoleFromGroupWithResponse request
	UnassignRoleFromGroupWithResponse(ctx context.Context, roleId string, groupId string, reqEditors ...RequestEditorFn) (*UnassignRoleFromGroupResponse, error)

	// AssignRoleToGroupWithResponse request
	AssignRoleToGroupWithResponse(ctx context.Context, roleId string, groupId string, reqEditors ...RequestEditorFn) (*AssignRoleToGroupResponse, error)

	// SearchMappingRulesForRoleWithBodyWithResponse request with any body
	SearchMappingRulesForRoleWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchMappingRulesForRoleResponse, error)

	SearchMappingRulesForRoleWithResponse(ctx context.Context, roleId string, body SearchMappingRulesForRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchMappingRulesForRoleResponse, error)

	// UnassignRoleFromMappingRuleWithResponse request
	UnassignRoleFromMappingRuleWithResponse(ctx context.Context, roleId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*UnassignRoleFromMappingRuleResponse, error)

	// AssignRoleToMappingRuleWithResponse request
	AssignRoleToMappingRuleWithResponse(ctx context.Context, roleId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*AssignRoleToMappingRuleResponse, error)

	// SearchUsersForRoleWithBodyWithResponse request with any body
	SearchUsersForRoleWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUsersForRoleResponse, error)

	SearchUsersForRoleWithResponse(ctx context.Context, roleId string, body SearchUsersForRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUsersForRoleResponse, error)

	// UnassignRoleFromUserWithResponse request
	UnassignRoleFromUserWithResponse(ctx context.Context, roleId string, username Username, reqEditors ...RequestEditorFn) (*UnassignRoleFromUserResponse, error)

	// AssignRoleToUserWithResponse request
	AssignRoleToUserWithResponse(ctx context.Context, roleId string, username Username, reqEditors ...RequestEditorFn) (*AssignRoleToUserResponse, error)

	// CreateAdminUserWithBodyWithResponse request with any body
	CreateAdminUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAdminUserResponse, error)

	CreateAdminUserWithResponse(ctx context.Context, body CreateAdminUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAdminUserResponse, error)

	// BroadcastSignalWithBodyWithResponse request with any body
	BroadcastSignalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BroadcastSignalResponse, error)

	BroadcastSignalWithResponse(ctx context.Context, body BroadcastSignalJSONRequestBody, reqEditors ...RequestEditorFn) (*BroadcastSignalResponse, error)

	// GetStatusWithResponse request
	GetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatusResponse, error)

	// GetUsageMetricsWithResponse request
	GetUsageMetricsWithResponse(ctx context.Context, params *GetUsageMetricsParams, reqEditors ...RequestEditorFn) (*GetUsageMetricsResponse, error)

	// CreateTenantWithBodyWithResponse request with any body
	CreateTenantWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTenantResponse, error)

	CreateTenantWithResponse(ctx context.Context, body CreateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTenantResponse, error)

	// SearchTenantsWithBodyWithResponse request with any body
	SearchTenantsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchTenantsResponse, error)

	SearchTenantsWithResponse(ctx context.Context, body SearchTenantsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchTenantsResponse, error)

	// DeleteTenantWithResponse request
	DeleteTenantWithResponse(ctx context.Context, tenantId TenantId, reqEditors ...RequestEditorFn) (*DeleteTenantResponse, error)

	// GetTenantWithResponse request
	GetTenantWithResponse(ctx context.Context, tenantId TenantId, reqEditors ...RequestEditorFn) (*GetTenantResponse, error)

	// UpdateTenantWithBodyWithResponse request with any body
	UpdateTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTenantResponse, error)

	UpdateTenantWithResponse(ctx context.Context, tenantId TenantId, body UpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTenantResponse, error)

	// SearchClientsForTenantWithBodyWithResponse request with any body
	SearchClientsForTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchClientsForTenantResponse, error)

	SearchClientsForTenantWithResponse(ctx context.Context, tenantId TenantId, body SearchClientsForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchClientsForTenantResponse, error)

	// UnassignClientFromTenantWithResponse request
	UnassignClientFromTenantWithResponse(ctx context.Context, tenantId TenantId, clientId string, reqEditors ...RequestEditorFn) (*UnassignClientFromTenantResponse, error)

	// AssignClientToTenantWithResponse request
	AssignClientToTenantWithResponse(ctx context.Context, tenantId TenantId, clientId string, reqEditors ...RequestEditorFn) (*AssignClientToTenantResponse, error)

	// SearchGroupIdsForTenantWithBodyWithResponse request with any body
	SearchGroupIdsForTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchGroupIdsForTenantResponse, error)

	SearchGroupIdsForTenantWithResponse(ctx context.Context, tenantId TenantId, body SearchGroupIdsForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchGroupIdsForTenantResponse, error)

	// UnassignGroupFromTenantWithResponse request
	UnassignGroupFromTenantWithResponse(ctx context.Context, tenantId TenantId, groupId string, reqEditors ...RequestEditorFn) (*UnassignGroupFromTenantResponse, error)

	// AssignGroupToTenantWithResponse request
	AssignGroupToTenantWithResponse(ctx context.Context, tenantId TenantId, groupId string, reqEditors ...RequestEditorFn) (*AssignGroupToTenantResponse, error)

	// SearchMappingRulesForTenantWithBodyWithResponse request with any body
	SearchMappingRulesForTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchMappingRulesForTenantResponse, error)

	SearchMappingRulesForTenantWithResponse(ctx context.Context, tenantId TenantId, body SearchMappingRulesForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchMappingRulesForTenantResponse, error)

	// UnassignMappingRuleFromTenantWithResponse request
	UnassignMappingRuleFromTenantWithResponse(ctx context.Context, tenantId TenantId, mappingRuleId string, reqEditors ...RequestEditorFn) (*UnassignMappingRuleFromTenantResponse, error)

	// AssignMappingRuleToTenantWithResponse request
	AssignMappingRuleToTenantWithResponse(ctx context.Context, tenantId TenantId, mappingRuleId string, reqEditors ...RequestEditorFn) (*AssignMappingRuleToTenantResponse, error)

	// SearchRolesForTenantWithBodyWithResponse request with any body
	SearchRolesForTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchRolesForTenantResponse, error)

	SearchRolesForTenantWithResponse(ctx context.Context, tenantId TenantId, body SearchRolesForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchRolesForTenantResponse, error)

	// UnassignRoleFromTenantWithResponse request
	UnassignRoleFromTenantWithResponse(ctx context.Context, tenantId TenantId, roleId string, reqEditors ...RequestEditorFn) (*UnassignRoleFromTenantResponse, error)

	// AssignRoleToTenantWithResponse request
	AssignRoleToTenantWithResponse(ctx context.Context, tenantId TenantId, roleId string, reqEditors ...RequestEditorFn) (*AssignRoleToTenantResponse, error)

	// SearchUsersForTenantWithBodyWithResponse request with any body
	SearchUsersForTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUsersForTenantResponse, error)

	SearchUsersForTenantWithResponse(ctx context.Context, tenantId TenantId, body SearchUsersForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUsersForTenantResponse, error)

	// UnassignUserFromTenantWithResponse request
	UnassignUserFromTenantWithResponse(ctx context.Context, tenantId TenantId, username Username, reqEditors ...RequestEditorFn) (*UnassignUserFromTenantResponse, error)

	// AssignUserToTenantWithResponse request
	AssignUserToTenantWithResponse(ctx context.Context, tenantId TenantId, username Username, reqEditors ...RequestEditorFn) (*AssignUserToTenantResponse, error)

	// GetTopologyWithResponse request
	GetTopologyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTopologyResponse, error)

	// SearchUserTasksWithBodyWithResponse request with any body
	SearchUserTasksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUserTasksResponse, error)

	SearchUserTasksWithResponse(ctx context.Context, body SearchUserTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUserTasksResponse, error)

	// GetUserTaskWithResponse request
	GetUserTaskWithResponse(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*GetUserTaskResponse, error)

	// UpdateUserTaskWithBodyWithResponse request with any body
	UpdateUserTaskWithBodyWithResponse(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserTaskResponse, error)

	UpdateUserTaskWithResponse(ctx context.Context, userTaskKey string, body UpdateUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserTaskResponse, error)

	// UnassignUserTaskWithResponse request
	UnassignUserTaskWithResponse(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*UnassignUserTaskResponse, error)

	// AssignUserTaskWithBodyWithResponse request with any body
	AssignUserTaskWithBodyWithResponse(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignUserTaskResponse, error)

	AssignUserTaskWithResponse(ctx context.Context, userTaskKey string, body AssignUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignUserTaskResponse, error)

	// CompleteUserTaskWithBodyWithResponse request with any body
	CompleteUserTaskWithBodyWithResponse(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompleteUserTaskResponse, error)

	CompleteUserTaskWithResponse(ctx context.Context, userTaskKey string, body CompleteUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CompleteUserTaskResponse, error)

	// GetUserTaskFormWithResponse request
	GetUserTaskFormWithResponse(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*GetUserTaskFormResponse, error)

	// SearchUserTaskVariablesWithBodyWithResponse request with any body
	SearchUserTaskVariablesWithBodyWithResponse(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUserTaskVariablesResponse, error)

	SearchUserTaskVariablesWithResponse(ctx context.Context, userTaskKey string, body SearchUserTaskVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUserTaskVariablesResponse, error)

	// CreateUserWithBodyWithResponse request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// SearchUsersWithBodyWithResponse request with any body
	SearchUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUsersResponse, error)

	SearchUsersWithResponse(ctx context.Context, body SearchUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUsersResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUserWithResponse request
	GetUserWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// UpdateUserWithBodyWithResponse request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, username Username, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// SearchVariablesWithBodyWithResponse request with any body
	SearchVariablesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchVariablesResponse, error)

	SearchVariablesWithResponse(ctx context.Context, body SearchVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchVariablesResponse, error)

	// GetVariableWithResponse request
	GetVariableWithResponse(ctx context.Context, variableKey string, reqEditors ...RequestEditorFn) (*GetVariableResponse, error)
}

type GetAuthenticationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *CamundaUserResult
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAuthenticationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthenticationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAuthorizationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *AuthorizationCreateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CreateAuthorizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAuthorizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchAuthorizationsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *AuthorizationSearchResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchAuthorizationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchAuthorizationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAuthorizationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeleteAuthorizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAuthorizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthorizationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *AuthorizationResult
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAuthorizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthorizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAuthorizationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UpdateAuthorizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAuthorizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchBatchOperationItemsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *BatchOperationItemSearchQueryResult
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchBatchOperationItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchBatchOperationItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchBatchOperationsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *BatchOperationSearchQueryResult
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchBatchOperationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchBatchOperationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBatchOperationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *BatchOperationResponse
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetBatchOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBatchOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelBatchOperationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CancelBatchOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelBatchOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResumeBatchOperationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ResumeBatchOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResumeBatchOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SuspendBatchOperationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SuspendBatchOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SuspendBatchOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PinClockResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PinClockResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PinClockResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetClockResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ResetClockResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetClockResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchCorrelatedMessageSubscriptionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *CorrelatedMessageSubscriptionSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchCorrelatedMessageSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchCorrelatedMessageSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EvaluateDecisionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *EvaluateDecisionResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r EvaluateDecisionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EvaluateDecisionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchDecisionDefinitionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DecisionDefinitionSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchDecisionDefinitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchDecisionDefinitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionDefinitionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DecisionDefinitionResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDecisionDefinitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionDefinitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionDefinitionXMLResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	XML200                    *string
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDecisionDefinitionXMLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionDefinitionXMLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchDecisionInstancesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DecisionInstanceSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchDecisionInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchDecisionInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DecisionInstanceGetQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDecisionInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchDecisionRequirementsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DecisionRequirementsSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchDecisionRequirementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchDecisionRequirementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionRequirementsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DecisionRequirementsResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDecisionRequirementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionRequirementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionRequirementsXMLResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	XML200                    *string
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDecisionRequirementsXMLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionRequirementsXMLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDeploymentResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DeploymentResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CreateDeploymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDeploymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDocumentResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *DocumentReference
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON415 *UnsupportedMediaType
}

// Status returns HTTPResponse.Status
func (r CreateDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDocumentsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *DocumentCreationBatchResponse
	JSON207                   *DocumentCreationBatchResponse
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON415 *UnsupportedMediaType
}

// Status returns HTTPResponse.Status
func (r CreateDocumentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDocumentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDocumentResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDocumentResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDocumentLinkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *DocumentLink
	ApplicationproblemJSON400 *InvalidData
}

// Status returns HTTPResponse.Status
func (r CreateDocumentLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDocumentLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivateAdHocSubProcessActivitiesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ActivateAdHocSubProcessActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivateAdHocSubProcessActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchElementInstancesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ElementInstanceSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchElementInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchElementInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetElementInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ElementInstanceResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetElementInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetElementInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateElementInstanceVariablesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CreateElementInstanceVariablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateElementInstanceVariablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *GroupCreateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CreateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchGroupsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GroupSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r SearchGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeleteGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GroupResult
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GroupUpdateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UpdateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchClientsForGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GroupClientSearchResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchClientsForGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchClientsForGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignClientFromGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignClientFromGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignClientFromGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignClientToGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignClientToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignClientToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchMappingRulesForGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *MappingRuleSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchMappingRulesForGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchMappingRulesForGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignMappingRuleFromGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignMappingRuleFromGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignMappingRuleFromGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignMappingRuleToGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignMappingRuleToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignMappingRuleToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchRolesForGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RoleSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchRolesForGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchRolesForGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchUsersForGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GroupUserSearchResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchUsersForGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchUsersForGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignUserFromGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignUserFromGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignUserFromGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignUserToGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignUserToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignUserToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchIncidentsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *IncidentSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchIncidentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchIncidentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIncidentResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *IncidentResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetIncidentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIncidentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResolveIncidentResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ResolveIncidentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResolveIncidentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivateJobsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *JobActivationResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON500 *ProblemDetail
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ActivateJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivateJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchJobsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *JobSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateJobResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UpdateJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompleteJobResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CompleteJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompleteJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ThrowJobErrorResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ThrowJobErrorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ThrowJobErrorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FailJobResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r FailJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FailJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLicenseResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *LicenseResponse
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetLicenseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLicenseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMappingRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *MappingRuleCreateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *ProblemDetail
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateMappingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMappingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchMappingRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *MappingRuleSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchMappingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchMappingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMappingRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeleteMappingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMappingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMappingRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *MappingRuleResult
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetMappingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMappingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMappingRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *MappingRuleUpdateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *ProblemDetail
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UpdateMappingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMappingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchMessageSubscriptionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *MessageSubscriptionSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchMessageSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchMessageSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CorrelateMessageResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *MessageCorrelationResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CorrelateMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CorrelateMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PublishMessageResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *MessagePublicationResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PublishMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PublishMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchProcessDefinitionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessDefinitionSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchProcessDefinitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchProcessDefinitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessDefinitionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessDefinitionResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetProcessDefinitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessDefinitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStartProcessFormResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *FormResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetStartProcessFormResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStartProcessFormResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessDefinitionStatisticsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessDefinitionElementStatisticsQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetProcessDefinitionStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessDefinitionStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessDefinitionXMLResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	XML200                    *string
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetProcessDefinitionXMLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessDefinitionXMLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProcessInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *CreateProcessInstanceResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
	ApplicationproblemJSON504 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r CreateProcessInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProcessInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelProcessInstancesBatchOperationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *BatchOperationCreatedResult
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CancelProcessInstancesBatchOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelProcessInstancesBatchOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResolveIncidentsBatchOperationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *BatchOperationCreatedResult
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ResolveIncidentsBatchOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResolveIncidentsBatchOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrateProcessInstancesBatchOperationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *BatchOperationCreatedResult
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r MigrateProcessInstancesBatchOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrateProcessInstancesBatchOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyProcessInstancesBatchOperationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *BatchOperationCreatedResult
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ModifyProcessInstancesBatchOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyProcessInstancesBatchOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchProcessInstancesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessInstanceSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchProcessInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchProcessInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessInstanceResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetProcessInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessInstanceCallHierarchyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]ProcessInstanceCallHierarchyEntry
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetProcessInstanceCallHierarchyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessInstanceCallHierarchyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelProcessInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CancelProcessInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelProcessInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchProcessInstanceIncidentsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *IncidentSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchProcessInstanceIncidentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchProcessInstanceIncidentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrateProcessInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MigrateProcessInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrateProcessInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyProcessInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ModifyProcessInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyProcessInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessInstanceSequenceFlowsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessInstanceSequenceFlowsQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetProcessInstanceSequenceFlowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessInstanceSequenceFlowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessInstanceStatisticsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessInstanceElementStatisticsQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetProcessInstanceStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessInstanceStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResourceResult
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceContentResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *string
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetResourceContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResourceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeleteResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRoleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *RoleCreateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CreateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchRolesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RoleSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r SearchRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRoleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeleteRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RoleResult
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRoleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RoleUpdateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UpdateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchClientsForRoleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RoleClientSearchResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchClientsForRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchClientsForRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignRoleFromClientResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignRoleFromClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignRoleFromClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignRoleToClientResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignRoleToClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignRoleToClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchGroupsForRoleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RoleGroupSearchResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchGroupsForRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchGroupsForRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignRoleFromGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignRoleFromGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignRoleFromGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignRoleToGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignRoleToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignRoleToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchMappingRulesForRoleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *MappingRuleSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchMappingRulesForRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchMappingRulesForRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignRoleFromMappingRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignRoleFromMappingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignRoleFromMappingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignRoleToMappingRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignRoleToMappingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignRoleToMappingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchUsersForRoleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RoleUserSearchResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchUsersForRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchUsersForRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignRoleFromUserResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignRoleFromUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignRoleFromUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignRoleToUserResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignRoleToUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignRoleToUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAdminUserResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *UserCreateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CreateAdminUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAdminUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BroadcastSignalResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *SignalBroadcastResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r BroadcastSignalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BroadcastSignalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsageMetricsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UsageMetricsResponse
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUsageMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsageMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *TenantCreateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CreateTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchTenantsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *TenantSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchTenantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchTenantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeleteTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *TenantResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *TenantUpdateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UpdateTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchClientsForTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantClientSearchResult
}

// Status returns HTTPResponse.Status
func (r SearchClientsForTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchClientsForTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignClientFromTenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignClientFromTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignClientFromTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignClientToTenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignClientToTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignClientToTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchGroupIdsForTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantGroupSearchResult
}

// Status returns HTTPResponse.Status
func (r SearchGroupIdsForTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchGroupIdsForTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignGroupFromTenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignGroupFromTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignGroupFromTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignGroupToTenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignGroupToTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignGroupToTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchMappingRulesForTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MappingRuleSearchQueryResult
}

// Status returns HTTPResponse.Status
func (r SearchMappingRulesForTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchMappingRulesForTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignMappingRuleFromTenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignMappingRuleFromTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignMappingRuleFromTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignMappingRuleToTenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignMappingRuleToTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignMappingRuleToTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchRolesForTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RoleSearchQueryResult
}

// Status returns HTTPResponse.Status
func (r SearchRolesForTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchRolesForTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignRoleFromTenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignRoleFromTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignRoleFromTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignRoleToTenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignRoleToTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignRoleToTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchUsersForTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantUserSearchResult
}

// Status returns HTTPResponse.Status
func (r SearchUsersForTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchUsersForTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignUserFromTenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignUserFromTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignUserFromTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignUserToTenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignUserToTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignUserToTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTopologyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *TopologyResponse
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetTopologyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTopologyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchUserTasksResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UserTaskSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchUserTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchUserTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserTaskResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UserTaskResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserTaskResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UpdateUserTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignUserTaskResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignUserTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignUserTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignUserTaskResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignUserTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignUserTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompleteUserTaskResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CompleteUserTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompleteUserTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserTaskFormResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *FormResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserTaskFormResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserTaskFormResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchUserTaskVariablesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *VariableSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchUserTaskVariablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchUserTaskVariablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *UserCreateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchUsersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UserSearchResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UserResult
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UserUpdateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchVariablesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *VariableSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchVariablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchVariablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVariableResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *VariableResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAuthenticationWithResponse request returning *GetAuthenticationResponse
func (c *ClientWithResponses) GetAuthenticationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthenticationResponse, error) {
	rsp, err := c.GetAuthentication(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthenticationResponse(rsp)
}

// CreateAuthorizationWithBodyWithResponse request with arbitrary body returning *CreateAuthorizationResponse
func (c *ClientWithResponses) CreateAuthorizationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAuthorizationResponse, error) {
	rsp, err := c.CreateAuthorizationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuthorizationResponse(rsp)
}

func (c *ClientWithResponses) CreateAuthorizationWithResponse(ctx context.Context, body CreateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAuthorizationResponse, error) {
	rsp, err := c.CreateAuthorization(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuthorizationResponse(rsp)
}

// SearchAuthorizationsWithBodyWithResponse request with arbitrary body returning *SearchAuthorizationsResponse
func (c *ClientWithResponses) SearchAuthorizationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchAuthorizationsResponse, error) {
	rsp, err := c.SearchAuthorizationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchAuthorizationsResponse(rsp)
}

func (c *ClientWithResponses) SearchAuthorizationsWithResponse(ctx context.Context, body SearchAuthorizationsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchAuthorizationsResponse, error) {
	rsp, err := c.SearchAuthorizations(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchAuthorizationsResponse(rsp)
}

// DeleteAuthorizationWithResponse request returning *DeleteAuthorizationResponse
func (c *ClientWithResponses) DeleteAuthorizationWithResponse(ctx context.Context, authorizationKey string, reqEditors ...RequestEditorFn) (*DeleteAuthorizationResponse, error) {
	rsp, err := c.DeleteAuthorization(ctx, authorizationKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAuthorizationResponse(rsp)
}

// GetAuthorizationWithResponse request returning *GetAuthorizationResponse
func (c *ClientWithResponses) GetAuthorizationWithResponse(ctx context.Context, authorizationKey string, reqEditors ...RequestEditorFn) (*GetAuthorizationResponse, error) {
	rsp, err := c.GetAuthorization(ctx, authorizationKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthorizationResponse(rsp)
}

// UpdateAuthorizationWithBodyWithResponse request with arbitrary body returning *UpdateAuthorizationResponse
func (c *ClientWithResponses) UpdateAuthorizationWithBodyWithResponse(ctx context.Context, authorizationKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAuthorizationResponse, error) {
	rsp, err := c.UpdateAuthorizationWithBody(ctx, authorizationKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAuthorizationResponse(rsp)
}

func (c *ClientWithResponses) UpdateAuthorizationWithResponse(ctx context.Context, authorizationKey string, body UpdateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAuthorizationResponse, error) {
	rsp, err := c.UpdateAuthorization(ctx, authorizationKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAuthorizationResponse(rsp)
}

// SearchBatchOperationItemsWithBodyWithResponse request with arbitrary body returning *SearchBatchOperationItemsResponse
func (c *ClientWithResponses) SearchBatchOperationItemsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchBatchOperationItemsResponse, error) {
	rsp, err := c.SearchBatchOperationItemsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchBatchOperationItemsResponse(rsp)
}

func (c *ClientWithResponses) SearchBatchOperationItemsWithResponse(ctx context.Context, body SearchBatchOperationItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchBatchOperationItemsResponse, error) {
	rsp, err := c.SearchBatchOperationItems(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchBatchOperationItemsResponse(rsp)
}

// SearchBatchOperationsWithBodyWithResponse request with arbitrary body returning *SearchBatchOperationsResponse
func (c *ClientWithResponses) SearchBatchOperationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchBatchOperationsResponse, error) {
	rsp, err := c.SearchBatchOperationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchBatchOperationsResponse(rsp)
}

func (c *ClientWithResponses) SearchBatchOperationsWithResponse(ctx context.Context, body SearchBatchOperationsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchBatchOperationsResponse, error) {
	rsp, err := c.SearchBatchOperations(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchBatchOperationsResponse(rsp)
}

// GetBatchOperationWithResponse request returning *GetBatchOperationResponse
func (c *ClientWithResponses) GetBatchOperationWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, reqEditors ...RequestEditorFn) (*GetBatchOperationResponse, error) {
	rsp, err := c.GetBatchOperation(ctx, batchOperationKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBatchOperationResponse(rsp)
}

// CancelBatchOperationWithBodyWithResponse request with arbitrary body returning *CancelBatchOperationResponse
func (c *ClientWithResponses) CancelBatchOperationWithBodyWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelBatchOperationResponse, error) {
	rsp, err := c.CancelBatchOperationWithBody(ctx, batchOperationKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelBatchOperationResponse(rsp)
}

func (c *ClientWithResponses) CancelBatchOperationWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, body CancelBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelBatchOperationResponse, error) {
	rsp, err := c.CancelBatchOperation(ctx, batchOperationKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelBatchOperationResponse(rsp)
}

// ResumeBatchOperationWithBodyWithResponse request with arbitrary body returning *ResumeBatchOperationResponse
func (c *ClientWithResponses) ResumeBatchOperationWithBodyWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResumeBatchOperationResponse, error) {
	rsp, err := c.ResumeBatchOperationWithBody(ctx, batchOperationKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeBatchOperationResponse(rsp)
}

func (c *ClientWithResponses) ResumeBatchOperationWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, body ResumeBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*ResumeBatchOperationResponse, error) {
	rsp, err := c.ResumeBatchOperation(ctx, batchOperationKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeBatchOperationResponse(rsp)
}

// SuspendBatchOperationWithBodyWithResponse request with arbitrary body returning *SuspendBatchOperationResponse
func (c *ClientWithResponses) SuspendBatchOperationWithBodyWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SuspendBatchOperationResponse, error) {
	rsp, err := c.SuspendBatchOperationWithBody(ctx, batchOperationKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSuspendBatchOperationResponse(rsp)
}

func (c *ClientWithResponses) SuspendBatchOperationWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, body SuspendBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*SuspendBatchOperationResponse, error) {
	rsp, err := c.SuspendBatchOperation(ctx, batchOperationKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSuspendBatchOperationResponse(rsp)
}

// PinClockWithBodyWithResponse request with arbitrary body returning *PinClockResponse
func (c *ClientWithResponses) PinClockWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PinClockResponse, error) {
	rsp, err := c.PinClockWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePinClockResponse(rsp)
}

func (c *ClientWithResponses) PinClockWithResponse(ctx context.Context, body PinClockJSONRequestBody, reqEditors ...RequestEditorFn) (*PinClockResponse, error) {
	rsp, err := c.PinClock(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePinClockResponse(rsp)
}

// ResetClockWithResponse request returning *ResetClockResponse
func (c *ClientWithResponses) ResetClockWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResetClockResponse, error) {
	rsp, err := c.ResetClock(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetClockResponse(rsp)
}

// SearchCorrelatedMessageSubscriptionsWithBodyWithResponse request with arbitrary body returning *SearchCorrelatedMessageSubscriptionsResponse
func (c *ClientWithResponses) SearchCorrelatedMessageSubscriptionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchCorrelatedMessageSubscriptionsResponse, error) {
	rsp, err := c.SearchCorrelatedMessageSubscriptionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchCorrelatedMessageSubscriptionsResponse(rsp)
}

func (c *ClientWithResponses) SearchCorrelatedMessageSubscriptionsWithResponse(ctx context.Context, body SearchCorrelatedMessageSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchCorrelatedMessageSubscriptionsResponse, error) {
	rsp, err := c.SearchCorrelatedMessageSubscriptions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchCorrelatedMessageSubscriptionsResponse(rsp)
}

// EvaluateDecisionWithBodyWithResponse request with arbitrary body returning *EvaluateDecisionResponse
func (c *ClientWithResponses) EvaluateDecisionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EvaluateDecisionResponse, error) {
	rsp, err := c.EvaluateDecisionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEvaluateDecisionResponse(rsp)
}

func (c *ClientWithResponses) EvaluateDecisionWithResponse(ctx context.Context, body EvaluateDecisionJSONRequestBody, reqEditors ...RequestEditorFn) (*EvaluateDecisionResponse, error) {
	rsp, err := c.EvaluateDecision(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEvaluateDecisionResponse(rsp)
}

// SearchDecisionDefinitionsWithBodyWithResponse request with arbitrary body returning *SearchDecisionDefinitionsResponse
func (c *ClientWithResponses) SearchDecisionDefinitionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDecisionDefinitionsResponse, error) {
	rsp, err := c.SearchDecisionDefinitionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDecisionDefinitionsResponse(rsp)
}

func (c *ClientWithResponses) SearchDecisionDefinitionsWithResponse(ctx context.Context, body SearchDecisionDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDecisionDefinitionsResponse, error) {
	rsp, err := c.SearchDecisionDefinitions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDecisionDefinitionsResponse(rsp)
}

// GetDecisionDefinitionWithResponse request returning *GetDecisionDefinitionResponse
func (c *ClientWithResponses) GetDecisionDefinitionWithResponse(ctx context.Context, decisionDefinitionKey string, reqEditors ...RequestEditorFn) (*GetDecisionDefinitionResponse, error) {
	rsp, err := c.GetDecisionDefinition(ctx, decisionDefinitionKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionDefinitionResponse(rsp)
}

// GetDecisionDefinitionXMLWithResponse request returning *GetDecisionDefinitionXMLResponse
func (c *ClientWithResponses) GetDecisionDefinitionXMLWithResponse(ctx context.Context, decisionDefinitionKey string, reqEditors ...RequestEditorFn) (*GetDecisionDefinitionXMLResponse, error) {
	rsp, err := c.GetDecisionDefinitionXML(ctx, decisionDefinitionKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionDefinitionXMLResponse(rsp)
}

// SearchDecisionInstancesWithBodyWithResponse request with arbitrary body returning *SearchDecisionInstancesResponse
func (c *ClientWithResponses) SearchDecisionInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDecisionInstancesResponse, error) {
	rsp, err := c.SearchDecisionInstancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDecisionInstancesResponse(rsp)
}

func (c *ClientWithResponses) SearchDecisionInstancesWithResponse(ctx context.Context, body SearchDecisionInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDecisionInstancesResponse, error) {
	rsp, err := c.SearchDecisionInstances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDecisionInstancesResponse(rsp)
}

// GetDecisionInstanceWithResponse request returning *GetDecisionInstanceResponse
func (c *ClientWithResponses) GetDecisionInstanceWithResponse(ctx context.Context, decisionEvaluationInstanceKey string, reqEditors ...RequestEditorFn) (*GetDecisionInstanceResponse, error) {
	rsp, err := c.GetDecisionInstance(ctx, decisionEvaluationInstanceKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionInstanceResponse(rsp)
}

// SearchDecisionRequirementsWithBodyWithResponse request with arbitrary body returning *SearchDecisionRequirementsResponse
func (c *ClientWithResponses) SearchDecisionRequirementsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDecisionRequirementsResponse, error) {
	rsp, err := c.SearchDecisionRequirementsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDecisionRequirementsResponse(rsp)
}

func (c *ClientWithResponses) SearchDecisionRequirementsWithResponse(ctx context.Context, body SearchDecisionRequirementsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDecisionRequirementsResponse, error) {
	rsp, err := c.SearchDecisionRequirements(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDecisionRequirementsResponse(rsp)
}

// GetDecisionRequirementsWithResponse request returning *GetDecisionRequirementsResponse
func (c *ClientWithResponses) GetDecisionRequirementsWithResponse(ctx context.Context, decisionRequirementsKey string, reqEditors ...RequestEditorFn) (*GetDecisionRequirementsResponse, error) {
	rsp, err := c.GetDecisionRequirements(ctx, decisionRequirementsKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionRequirementsResponse(rsp)
}

// GetDecisionRequirementsXMLWithResponse request returning *GetDecisionRequirementsXMLResponse
func (c *ClientWithResponses) GetDecisionRequirementsXMLWithResponse(ctx context.Context, decisionRequirementsKey string, reqEditors ...RequestEditorFn) (*GetDecisionRequirementsXMLResponse, error) {
	rsp, err := c.GetDecisionRequirementsXML(ctx, decisionRequirementsKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionRequirementsXMLResponse(rsp)
}

// CreateDeploymentWithBodyWithResponse request with arbitrary body returning *CreateDeploymentResponse
func (c *ClientWithResponses) CreateDeploymentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeploymentResponse, error) {
	rsp, err := c.CreateDeploymentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeploymentResponse(rsp)
}

// CreateDocumentWithBodyWithResponse request with arbitrary body returning *CreateDocumentResponse
func (c *ClientWithResponses) CreateDocumentWithBodyWithResponse(ctx context.Context, params *CreateDocumentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDocumentResponse, error) {
	rsp, err := c.CreateDocumentWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDocumentResponse(rsp)
}

// CreateDocumentsWithBodyWithResponse request with arbitrary body returning *CreateDocumentsResponse
func (c *ClientWithResponses) CreateDocumentsWithBodyWithResponse(ctx context.Context, params *CreateDocumentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDocumentsResponse, error) {
	rsp, err := c.CreateDocumentsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDocumentsResponse(rsp)
}

// DeleteDocumentWithResponse request returning *DeleteDocumentResponse
func (c *ClientWithResponses) DeleteDocumentWithResponse(ctx context.Context, documentId DocumentId, params *DeleteDocumentParams, reqEditors ...RequestEditorFn) (*DeleteDocumentResponse, error) {
	rsp, err := c.DeleteDocument(ctx, documentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDocumentResponse(rsp)
}

// GetDocumentWithResponse request returning *GetDocumentResponse
func (c *ClientWithResponses) GetDocumentWithResponse(ctx context.Context, documentId DocumentId, params *GetDocumentParams, reqEditors ...RequestEditorFn) (*GetDocumentResponse, error) {
	rsp, err := c.GetDocument(ctx, documentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDocumentResponse(rsp)
}

// CreateDocumentLinkWithBodyWithResponse request with arbitrary body returning *CreateDocumentLinkResponse
func (c *ClientWithResponses) CreateDocumentLinkWithBodyWithResponse(ctx context.Context, documentId DocumentId, params *CreateDocumentLinkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDocumentLinkResponse, error) {
	rsp, err := c.CreateDocumentLinkWithBody(ctx, documentId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDocumentLinkResponse(rsp)
}

func (c *ClientWithResponses) CreateDocumentLinkWithResponse(ctx context.Context, documentId DocumentId, params *CreateDocumentLinkParams, body CreateDocumentLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDocumentLinkResponse, error) {
	rsp, err := c.CreateDocumentLink(ctx, documentId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDocumentLinkResponse(rsp)
}

// ActivateAdHocSubProcessActivitiesWithBodyWithResponse request with arbitrary body returning *ActivateAdHocSubProcessActivitiesResponse
func (c *ClientWithResponses) ActivateAdHocSubProcessActivitiesWithBodyWithResponse(ctx context.Context, adHocSubProcessInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateAdHocSubProcessActivitiesResponse, error) {
	rsp, err := c.ActivateAdHocSubProcessActivitiesWithBody(ctx, adHocSubProcessInstanceKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateAdHocSubProcessActivitiesResponse(rsp)
}

func (c *ClientWithResponses) ActivateAdHocSubProcessActivitiesWithResponse(ctx context.Context, adHocSubProcessInstanceKey string, body ActivateAdHocSubProcessActivitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateAdHocSubProcessActivitiesResponse, error) {
	rsp, err := c.ActivateAdHocSubProcessActivities(ctx, adHocSubProcessInstanceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateAdHocSubProcessActivitiesResponse(rsp)
}

// SearchElementInstancesWithBodyWithResponse request with arbitrary body returning *SearchElementInstancesResponse
func (c *ClientWithResponses) SearchElementInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchElementInstancesResponse, error) {
	rsp, err := c.SearchElementInstancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchElementInstancesResponse(rsp)
}

func (c *ClientWithResponses) SearchElementInstancesWithResponse(ctx context.Context, body SearchElementInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchElementInstancesResponse, error) {
	rsp, err := c.SearchElementInstances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchElementInstancesResponse(rsp)
}

// GetElementInstanceWithResponse request returning *GetElementInstanceResponse
func (c *ClientWithResponses) GetElementInstanceWithResponse(ctx context.Context, elementInstanceKey string, reqEditors ...RequestEditorFn) (*GetElementInstanceResponse, error) {
	rsp, err := c.GetElementInstance(ctx, elementInstanceKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetElementInstanceResponse(rsp)
}

// CreateElementInstanceVariablesWithBodyWithResponse request with arbitrary body returning *CreateElementInstanceVariablesResponse
func (c *ClientWithResponses) CreateElementInstanceVariablesWithBodyWithResponse(ctx context.Context, elementInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateElementInstanceVariablesResponse, error) {
	rsp, err := c.CreateElementInstanceVariablesWithBody(ctx, elementInstanceKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateElementInstanceVariablesResponse(rsp)
}

func (c *ClientWithResponses) CreateElementInstanceVariablesWithResponse(ctx context.Context, elementInstanceKey string, body CreateElementInstanceVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateElementInstanceVariablesResponse, error) {
	rsp, err := c.CreateElementInstanceVariables(ctx, elementInstanceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateElementInstanceVariablesResponse(rsp)
}

// CreateGroupWithBodyWithResponse request with arbitrary body returning *CreateGroupResponse
func (c *ClientWithResponses) CreateGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateGroupWithResponse(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

// SearchGroupsWithBodyWithResponse request with arbitrary body returning *SearchGroupsResponse
func (c *ClientWithResponses) SearchGroupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchGroupsResponse, error) {
	rsp, err := c.SearchGroupsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGroupsResponse(rsp)
}

func (c *ClientWithResponses) SearchGroupsWithResponse(ctx context.Context, body SearchGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchGroupsResponse, error) {
	rsp, err := c.SearchGroups(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGroupsResponse(rsp)
}

// DeleteGroupWithResponse request returning *DeleteGroupResponse
func (c *ClientWithResponses) DeleteGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error) {
	rsp, err := c.DeleteGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupResponse(rsp)
}

// GetGroupWithResponse request returning *GetGroupResponse
func (c *ClientWithResponses) GetGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupResponse, error) {
	rsp, err := c.GetGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupResponse(rsp)
}

// UpdateGroupWithBodyWithResponse request with arbitrary body returning *UpdateGroupResponse
func (c *ClientWithResponses) UpdateGroupWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error) {
	rsp, err := c.UpdateGroupWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateGroupWithResponse(ctx context.Context, groupId string, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error) {
	rsp, err := c.UpdateGroup(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupResponse(rsp)
}

// SearchClientsForGroupWithBodyWithResponse request with arbitrary body returning *SearchClientsForGroupResponse
func (c *ClientWithResponses) SearchClientsForGroupWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchClientsForGroupResponse, error) {
	rsp, err := c.SearchClientsForGroupWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchClientsForGroupResponse(rsp)
}

func (c *ClientWithResponses) SearchClientsForGroupWithResponse(ctx context.Context, groupId string, body SearchClientsForGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchClientsForGroupResponse, error) {
	rsp, err := c.SearchClientsForGroup(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchClientsForGroupResponse(rsp)
}

// UnassignClientFromGroupWithResponse request returning *UnassignClientFromGroupResponse
func (c *ClientWithResponses) UnassignClientFromGroupWithResponse(ctx context.Context, groupId string, clientId string, reqEditors ...RequestEditorFn) (*UnassignClientFromGroupResponse, error) {
	rsp, err := c.UnassignClientFromGroup(ctx, groupId, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignClientFromGroupResponse(rsp)
}

// AssignClientToGroupWithResponse request returning *AssignClientToGroupResponse
func (c *ClientWithResponses) AssignClientToGroupWithResponse(ctx context.Context, groupId string, clientId string, reqEditors ...RequestEditorFn) (*AssignClientToGroupResponse, error) {
	rsp, err := c.AssignClientToGroup(ctx, groupId, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignClientToGroupResponse(rsp)
}

// SearchMappingRulesForGroupWithBodyWithResponse request with arbitrary body returning *SearchMappingRulesForGroupResponse
func (c *ClientWithResponses) SearchMappingRulesForGroupWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchMappingRulesForGroupResponse, error) {
	rsp, err := c.SearchMappingRulesForGroupWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchMappingRulesForGroupResponse(rsp)
}

func (c *ClientWithResponses) SearchMappingRulesForGroupWithResponse(ctx context.Context, groupId string, body SearchMappingRulesForGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchMappingRulesForGroupResponse, error) {
	rsp, err := c.SearchMappingRulesForGroup(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchMappingRulesForGroupResponse(rsp)
}

// UnassignMappingRuleFromGroupWithResponse request returning *UnassignMappingRuleFromGroupResponse
func (c *ClientWithResponses) UnassignMappingRuleFromGroupWithResponse(ctx context.Context, groupId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*UnassignMappingRuleFromGroupResponse, error) {
	rsp, err := c.UnassignMappingRuleFromGroup(ctx, groupId, mappingRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignMappingRuleFromGroupResponse(rsp)
}

// AssignMappingRuleToGroupWithResponse request returning *AssignMappingRuleToGroupResponse
func (c *ClientWithResponses) AssignMappingRuleToGroupWithResponse(ctx context.Context, groupId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*AssignMappingRuleToGroupResponse, error) {
	rsp, err := c.AssignMappingRuleToGroup(ctx, groupId, mappingRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignMappingRuleToGroupResponse(rsp)
}

// SearchRolesForGroupWithBodyWithResponse request with arbitrary body returning *SearchRolesForGroupResponse
func (c *ClientWithResponses) SearchRolesForGroupWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchRolesForGroupResponse, error) {
	rsp, err := c.SearchRolesForGroupWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRolesForGroupResponse(rsp)
}

func (c *ClientWithResponses) SearchRolesForGroupWithResponse(ctx context.Context, groupId string, body SearchRolesForGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchRolesForGroupResponse, error) {
	rsp, err := c.SearchRolesForGroup(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRolesForGroupResponse(rsp)
}

// SearchUsersForGroupWithBodyWithResponse request with arbitrary body returning *SearchUsersForGroupResponse
func (c *ClientWithResponses) SearchUsersForGroupWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUsersForGroupResponse, error) {
	rsp, err := c.SearchUsersForGroupWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUsersForGroupResponse(rsp)
}

func (c *ClientWithResponses) SearchUsersForGroupWithResponse(ctx context.Context, groupId string, body SearchUsersForGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUsersForGroupResponse, error) {
	rsp, err := c.SearchUsersForGroup(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUsersForGroupResponse(rsp)
}

// UnassignUserFromGroupWithResponse request returning *UnassignUserFromGroupResponse
func (c *ClientWithResponses) UnassignUserFromGroupWithResponse(ctx context.Context, groupId string, username Username, reqEditors ...RequestEditorFn) (*UnassignUserFromGroupResponse, error) {
	rsp, err := c.UnassignUserFromGroup(ctx, groupId, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignUserFromGroupResponse(rsp)
}

// AssignUserToGroupWithResponse request returning *AssignUserToGroupResponse
func (c *ClientWithResponses) AssignUserToGroupWithResponse(ctx context.Context, groupId string, username Username, reqEditors ...RequestEditorFn) (*AssignUserToGroupResponse, error) {
	rsp, err := c.AssignUserToGroup(ctx, groupId, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignUserToGroupResponse(rsp)
}

// SearchIncidentsWithBodyWithResponse request with arbitrary body returning *SearchIncidentsResponse
func (c *ClientWithResponses) SearchIncidentsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchIncidentsResponse, error) {
	rsp, err := c.SearchIncidentsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchIncidentsResponse(rsp)
}

func (c *ClientWithResponses) SearchIncidentsWithResponse(ctx context.Context, body SearchIncidentsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchIncidentsResponse, error) {
	rsp, err := c.SearchIncidents(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchIncidentsResponse(rsp)
}

// GetIncidentWithResponse request returning *GetIncidentResponse
func (c *ClientWithResponses) GetIncidentWithResponse(ctx context.Context, incidentKey string, reqEditors ...RequestEditorFn) (*GetIncidentResponse, error) {
	rsp, err := c.GetIncident(ctx, incidentKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIncidentResponse(rsp)
}

// ResolveIncidentWithBodyWithResponse request with arbitrary body returning *ResolveIncidentResponse
func (c *ClientWithResponses) ResolveIncidentWithBodyWithResponse(ctx context.Context, incidentKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResolveIncidentResponse, error) {
	rsp, err := c.ResolveIncidentWithBody(ctx, incidentKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResolveIncidentResponse(rsp)
}

func (c *ClientWithResponses) ResolveIncidentWithResponse(ctx context.Context, incidentKey string, body ResolveIncidentJSONRequestBody, reqEditors ...RequestEditorFn) (*ResolveIncidentResponse, error) {
	rsp, err := c.ResolveIncident(ctx, incidentKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResolveIncidentResponse(rsp)
}

// ActivateJobsWithBodyWithResponse request with arbitrary body returning *ActivateJobsResponse
func (c *ClientWithResponses) ActivateJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateJobsResponse, error) {
	rsp, err := c.ActivateJobsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateJobsResponse(rsp)
}

func (c *ClientWithResponses) ActivateJobsWithResponse(ctx context.Context, body ActivateJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateJobsResponse, error) {
	rsp, err := c.ActivateJobs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateJobsResponse(rsp)
}

// SearchJobsWithBodyWithResponse request with arbitrary body returning *SearchJobsResponse
func (c *ClientWithResponses) SearchJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchJobsResponse, error) {
	rsp, err := c.SearchJobsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchJobsResponse(rsp)
}

func (c *ClientWithResponses) SearchJobsWithResponse(ctx context.Context, body SearchJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchJobsResponse, error) {
	rsp, err := c.SearchJobs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchJobsResponse(rsp)
}

// UpdateJobWithBodyWithResponse request with arbitrary body returning *UpdateJobResponse
func (c *ClientWithResponses) UpdateJobWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error) {
	rsp, err := c.UpdateJobWithBody(ctx, jobKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateJobResponse(rsp)
}

func (c *ClientWithResponses) UpdateJobWithResponse(ctx context.Context, jobKey string, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error) {
	rsp, err := c.UpdateJob(ctx, jobKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateJobResponse(rsp)
}

// CompleteJobWithBodyWithResponse request with arbitrary body returning *CompleteJobResponse
func (c *ClientWithResponses) CompleteJobWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompleteJobResponse, error) {
	rsp, err := c.CompleteJobWithBody(ctx, jobKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompleteJobResponse(rsp)
}

func (c *ClientWithResponses) CompleteJobWithResponse(ctx context.Context, jobKey string, body CompleteJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CompleteJobResponse, error) {
	rsp, err := c.CompleteJob(ctx, jobKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompleteJobResponse(rsp)
}

// ThrowJobErrorWithBodyWithResponse request with arbitrary body returning *ThrowJobErrorResponse
func (c *ClientWithResponses) ThrowJobErrorWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ThrowJobErrorResponse, error) {
	rsp, err := c.ThrowJobErrorWithBody(ctx, jobKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseThrowJobErrorResponse(rsp)
}

func (c *ClientWithResponses) ThrowJobErrorWithResponse(ctx context.Context, jobKey string, body ThrowJobErrorJSONRequestBody, reqEditors ...RequestEditorFn) (*ThrowJobErrorResponse, error) {
	rsp, err := c.ThrowJobError(ctx, jobKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseThrowJobErrorResponse(rsp)
}

// FailJobWithBodyWithResponse request with arbitrary body returning *FailJobResponse
func (c *ClientWithResponses) FailJobWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FailJobResponse, error) {
	rsp, err := c.FailJobWithBody(ctx, jobKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFailJobResponse(rsp)
}

func (c *ClientWithResponses) FailJobWithResponse(ctx context.Context, jobKey string, body FailJobJSONRequestBody, reqEditors ...RequestEditorFn) (*FailJobResponse, error) {
	rsp, err := c.FailJob(ctx, jobKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFailJobResponse(rsp)
}

// GetLicenseWithResponse request returning *GetLicenseResponse
func (c *ClientWithResponses) GetLicenseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLicenseResponse, error) {
	rsp, err := c.GetLicense(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLicenseResponse(rsp)
}

// CreateMappingRuleWithBodyWithResponse request with arbitrary body returning *CreateMappingRuleResponse
func (c *ClientWithResponses) CreateMappingRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMappingRuleResponse, error) {
	rsp, err := c.CreateMappingRuleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMappingRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateMappingRuleWithResponse(ctx context.Context, body CreateMappingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMappingRuleResponse, error) {
	rsp, err := c.CreateMappingRule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMappingRuleResponse(rsp)
}

// SearchMappingRuleWithBodyWithResponse request with arbitrary body returning *SearchMappingRuleResponse
func (c *ClientWithResponses) SearchMappingRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchMappingRuleResponse, error) {
	rsp, err := c.SearchMappingRuleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchMappingRuleResponse(rsp)
}

func (c *ClientWithResponses) SearchMappingRuleWithResponse(ctx context.Context, body SearchMappingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchMappingRuleResponse, error) {
	rsp, err := c.SearchMappingRule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchMappingRuleResponse(rsp)
}

// DeleteMappingRuleWithResponse request returning *DeleteMappingRuleResponse
func (c *ClientWithResponses) DeleteMappingRuleWithResponse(ctx context.Context, mappingRuleId string, reqEditors ...RequestEditorFn) (*DeleteMappingRuleResponse, error) {
	rsp, err := c.DeleteMappingRule(ctx, mappingRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMappingRuleResponse(rsp)
}

// GetMappingRuleWithResponse request returning *GetMappingRuleResponse
func (c *ClientWithResponses) GetMappingRuleWithResponse(ctx context.Context, mappingRuleId string, reqEditors ...RequestEditorFn) (*GetMappingRuleResponse, error) {
	rsp, err := c.GetMappingRule(ctx, mappingRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMappingRuleResponse(rsp)
}

// UpdateMappingRuleWithBodyWithResponse request with arbitrary body returning *UpdateMappingRuleResponse
func (c *ClientWithResponses) UpdateMappingRuleWithBodyWithResponse(ctx context.Context, mappingRuleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMappingRuleResponse, error) {
	rsp, err := c.UpdateMappingRuleWithBody(ctx, mappingRuleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMappingRuleResponse(rsp)
}

func (c *ClientWithResponses) UpdateMappingRuleWithResponse(ctx context.Context, mappingRuleId string, body UpdateMappingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMappingRuleResponse, error) {
	rsp, err := c.UpdateMappingRule(ctx, mappingRuleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMappingRuleResponse(rsp)
}

// SearchMessageSubscriptionsWithBodyWithResponse request with arbitrary body returning *SearchMessageSubscriptionsResponse
func (c *ClientWithResponses) SearchMessageSubscriptionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchMessageSubscriptionsResponse, error) {
	rsp, err := c.SearchMessageSubscriptionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchMessageSubscriptionsResponse(rsp)
}

func (c *ClientWithResponses) SearchMessageSubscriptionsWithResponse(ctx context.Context, body SearchMessageSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchMessageSubscriptionsResponse, error) {
	rsp, err := c.SearchMessageSubscriptions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchMessageSubscriptionsResponse(rsp)
}

// CorrelateMessageWithBodyWithResponse request with arbitrary body returning *CorrelateMessageResponse
func (c *ClientWithResponses) CorrelateMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CorrelateMessageResponse, error) {
	rsp, err := c.CorrelateMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCorrelateMessageResponse(rsp)
}

func (c *ClientWithResponses) CorrelateMessageWithResponse(ctx context.Context, body CorrelateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*CorrelateMessageResponse, error) {
	rsp, err := c.CorrelateMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCorrelateMessageResponse(rsp)
}

// PublishMessageWithBodyWithResponse request with arbitrary body returning *PublishMessageResponse
func (c *ClientWithResponses) PublishMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PublishMessageResponse, error) {
	rsp, err := c.PublishMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublishMessageResponse(rsp)
}

func (c *ClientWithResponses) PublishMessageWithResponse(ctx context.Context, body PublishMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*PublishMessageResponse, error) {
	rsp, err := c.PublishMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublishMessageResponse(rsp)
}

// SearchProcessDefinitionsWithBodyWithResponse request with arbitrary body returning *SearchProcessDefinitionsResponse
func (c *ClientWithResponses) SearchProcessDefinitionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchProcessDefinitionsResponse, error) {
	rsp, err := c.SearchProcessDefinitionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchProcessDefinitionsResponse(rsp)
}

func (c *ClientWithResponses) SearchProcessDefinitionsWithResponse(ctx context.Context, body SearchProcessDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchProcessDefinitionsResponse, error) {
	rsp, err := c.SearchProcessDefinitions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchProcessDefinitionsResponse(rsp)
}

// GetProcessDefinitionWithResponse request returning *GetProcessDefinitionResponse
func (c *ClientWithResponses) GetProcessDefinitionWithResponse(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*GetProcessDefinitionResponse, error) {
	rsp, err := c.GetProcessDefinition(ctx, processDefinitionKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessDefinitionResponse(rsp)
}

// GetStartProcessFormWithResponse request returning *GetStartProcessFormResponse
func (c *ClientWithResponses) GetStartProcessFormWithResponse(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*GetStartProcessFormResponse, error) {
	rsp, err := c.GetStartProcessForm(ctx, processDefinitionKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStartProcessFormResponse(rsp)
}

// GetProcessDefinitionStatisticsWithBodyWithResponse request with arbitrary body returning *GetProcessDefinitionStatisticsResponse
func (c *ClientWithResponses) GetProcessDefinitionStatisticsWithBodyWithResponse(ctx context.Context, processDefinitionKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetProcessDefinitionStatisticsResponse, error) {
	rsp, err := c.GetProcessDefinitionStatisticsWithBody(ctx, processDefinitionKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessDefinitionStatisticsResponse(rsp)
}

func (c *ClientWithResponses) GetProcessDefinitionStatisticsWithResponse(ctx context.Context, processDefinitionKey string, body GetProcessDefinitionStatisticsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetProcessDefinitionStatisticsResponse, error) {
	rsp, err := c.GetProcessDefinitionStatistics(ctx, processDefinitionKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessDefinitionStatisticsResponse(rsp)
}

// GetProcessDefinitionXMLWithResponse request returning *GetProcessDefinitionXMLResponse
func (c *ClientWithResponses) GetProcessDefinitionXMLWithResponse(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*GetProcessDefinitionXMLResponse, error) {
	rsp, err := c.GetProcessDefinitionXML(ctx, processDefinitionKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessDefinitionXMLResponse(rsp)
}

// CreateProcessInstanceWithBodyWithResponse request with arbitrary body returning *CreateProcessInstanceResponse
func (c *ClientWithResponses) CreateProcessInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProcessInstanceResponse, error) {
	rsp, err := c.CreateProcessInstanceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProcessInstanceResponse(rsp)
}

func (c *ClientWithResponses) CreateProcessInstanceWithResponse(ctx context.Context, body CreateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProcessInstanceResponse, error) {
	rsp, err := c.CreateProcessInstance(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProcessInstanceResponse(rsp)
}

// CancelProcessInstancesBatchOperationWithBodyWithResponse request with arbitrary body returning *CancelProcessInstancesBatchOperationResponse
func (c *ClientWithResponses) CancelProcessInstancesBatchOperationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelProcessInstancesBatchOperationResponse, error) {
	rsp, err := c.CancelProcessInstancesBatchOperationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelProcessInstancesBatchOperationResponse(rsp)
}

func (c *ClientWithResponses) CancelProcessInstancesBatchOperationWithResponse(ctx context.Context, body CancelProcessInstancesBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelProcessInstancesBatchOperationResponse, error) {
	rsp, err := c.CancelProcessInstancesBatchOperation(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelProcessInstancesBatchOperationResponse(rsp)
}

// ResolveIncidentsBatchOperationWithBodyWithResponse request with arbitrary body returning *ResolveIncidentsBatchOperationResponse
func (c *ClientWithResponses) ResolveIncidentsBatchOperationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResolveIncidentsBatchOperationResponse, error) {
	rsp, err := c.ResolveIncidentsBatchOperationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResolveIncidentsBatchOperationResponse(rsp)
}

func (c *ClientWithResponses) ResolveIncidentsBatchOperationWithResponse(ctx context.Context, body ResolveIncidentsBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*ResolveIncidentsBatchOperationResponse, error) {
	rsp, err := c.ResolveIncidentsBatchOperation(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResolveIncidentsBatchOperationResponse(rsp)
}

// MigrateProcessInstancesBatchOperationWithBodyWithResponse request with arbitrary body returning *MigrateProcessInstancesBatchOperationResponse
func (c *ClientWithResponses) MigrateProcessInstancesBatchOperationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrateProcessInstancesBatchOperationResponse, error) {
	rsp, err := c.MigrateProcessInstancesBatchOperationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrateProcessInstancesBatchOperationResponse(rsp)
}

func (c *ClientWithResponses) MigrateProcessInstancesBatchOperationWithResponse(ctx context.Context, body MigrateProcessInstancesBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrateProcessInstancesBatchOperationResponse, error) {
	rsp, err := c.MigrateProcessInstancesBatchOperation(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrateProcessInstancesBatchOperationResponse(rsp)
}

// ModifyProcessInstancesBatchOperationWithBodyWithResponse request with arbitrary body returning *ModifyProcessInstancesBatchOperationResponse
func (c *ClientWithResponses) ModifyProcessInstancesBatchOperationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyProcessInstancesBatchOperationResponse, error) {
	rsp, err := c.ModifyProcessInstancesBatchOperationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyProcessInstancesBatchOperationResponse(rsp)
}

func (c *ClientWithResponses) ModifyProcessInstancesBatchOperationWithResponse(ctx context.Context, body ModifyProcessInstancesBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyProcessInstancesBatchOperationResponse, error) {
	rsp, err := c.ModifyProcessInstancesBatchOperation(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyProcessInstancesBatchOperationResponse(rsp)
}

// SearchProcessInstancesWithBodyWithResponse request with arbitrary body returning *SearchProcessInstancesResponse
func (c *ClientWithResponses) SearchProcessInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchProcessInstancesResponse, error) {
	rsp, err := c.SearchProcessInstancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchProcessInstancesResponse(rsp)
}

func (c *ClientWithResponses) SearchProcessInstancesWithResponse(ctx context.Context, body SearchProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchProcessInstancesResponse, error) {
	rsp, err := c.SearchProcessInstances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchProcessInstancesResponse(rsp)
}

// GetProcessInstanceWithResponse request returning *GetProcessInstanceResponse
func (c *ClientWithResponses) GetProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*GetProcessInstanceResponse, error) {
	rsp, err := c.GetProcessInstance(ctx, processInstanceKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessInstanceResponse(rsp)
}

// GetProcessInstanceCallHierarchyWithResponse request returning *GetProcessInstanceCallHierarchyResponse
func (c *ClientWithResponses) GetProcessInstanceCallHierarchyWithResponse(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*GetProcessInstanceCallHierarchyResponse, error) {
	rsp, err := c.GetProcessInstanceCallHierarchy(ctx, processInstanceKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessInstanceCallHierarchyResponse(rsp)
}

// CancelProcessInstanceWithBodyWithResponse request with arbitrary body returning *CancelProcessInstanceResponse
func (c *ClientWithResponses) CancelProcessInstanceWithBodyWithResponse(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelProcessInstanceResponse, error) {
	rsp, err := c.CancelProcessInstanceWithBody(ctx, processInstanceKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelProcessInstanceResponse(rsp)
}

func (c *ClientWithResponses) CancelProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, body CancelProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelProcessInstanceResponse, error) {
	rsp, err := c.CancelProcessInstance(ctx, processInstanceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelProcessInstanceResponse(rsp)
}

// SearchProcessInstanceIncidentsWithBodyWithResponse request with arbitrary body returning *SearchProcessInstanceIncidentsResponse
func (c *ClientWithResponses) SearchProcessInstanceIncidentsWithBodyWithResponse(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchProcessInstanceIncidentsResponse, error) {
	rsp, err := c.SearchProcessInstanceIncidentsWithBody(ctx, processInstanceKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchProcessInstanceIncidentsResponse(rsp)
}

func (c *ClientWithResponses) SearchProcessInstanceIncidentsWithResponse(ctx context.Context, processInstanceKey string, body SearchProcessInstanceIncidentsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchProcessInstanceIncidentsResponse, error) {
	rsp, err := c.SearchProcessInstanceIncidents(ctx, processInstanceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchProcessInstanceIncidentsResponse(rsp)
}

// MigrateProcessInstanceWithBodyWithResponse request with arbitrary body returning *MigrateProcessInstanceResponse
func (c *ClientWithResponses) MigrateProcessInstanceWithBodyWithResponse(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrateProcessInstanceResponse, error) {
	rsp, err := c.MigrateProcessInstanceWithBody(ctx, processInstanceKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrateProcessInstanceResponse(rsp)
}

func (c *ClientWithResponses) MigrateProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, body MigrateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrateProcessInstanceResponse, error) {
	rsp, err := c.MigrateProcessInstance(ctx, processInstanceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrateProcessInstanceResponse(rsp)
}

// ModifyProcessInstanceWithBodyWithResponse request with arbitrary body returning *ModifyProcessInstanceResponse
func (c *ClientWithResponses) ModifyProcessInstanceWithBodyWithResponse(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyProcessInstanceResponse, error) {
	rsp, err := c.ModifyProcessInstanceWithBody(ctx, processInstanceKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyProcessInstanceResponse(rsp)
}

func (c *ClientWithResponses) ModifyProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, body ModifyProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyProcessInstanceResponse, error) {
	rsp, err := c.ModifyProcessInstance(ctx, processInstanceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyProcessInstanceResponse(rsp)
}

// GetProcessInstanceSequenceFlowsWithResponse request returning *GetProcessInstanceSequenceFlowsResponse
func (c *ClientWithResponses) GetProcessInstanceSequenceFlowsWithResponse(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*GetProcessInstanceSequenceFlowsResponse, error) {
	rsp, err := c.GetProcessInstanceSequenceFlows(ctx, processInstanceKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessInstanceSequenceFlowsResponse(rsp)
}

// GetProcessInstanceStatisticsWithResponse request returning *GetProcessInstanceStatisticsResponse
func (c *ClientWithResponses) GetProcessInstanceStatisticsWithResponse(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*GetProcessInstanceStatisticsResponse, error) {
	rsp, err := c.GetProcessInstanceStatistics(ctx, processInstanceKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessInstanceStatisticsResponse(rsp)
}

// GetResourceWithResponse request returning *GetResourceResponse
func (c *ClientWithResponses) GetResourceWithResponse(ctx context.Context, resourceKey ResourceKey, reqEditors ...RequestEditorFn) (*GetResourceResponse, error) {
	rsp, err := c.GetResource(ctx, resourceKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceResponse(rsp)
}

// GetResourceContentWithResponse request returning *GetResourceContentResponse
func (c *ClientWithResponses) GetResourceContentWithResponse(ctx context.Context, resourceKey ResourceKey, reqEditors ...RequestEditorFn) (*GetResourceContentResponse, error) {
	rsp, err := c.GetResourceContent(ctx, resourceKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceContentResponse(rsp)
}

// DeleteResourceWithBodyWithResponse request with arbitrary body returning *DeleteResourceResponse
func (c *ClientWithResponses) DeleteResourceWithBodyWithResponse(ctx context.Context, resourceKey ResourceKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteResourceResponse, error) {
	rsp, err := c.DeleteResourceWithBody(ctx, resourceKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResourceResponse(rsp)
}

func (c *ClientWithResponses) DeleteResourceWithResponse(ctx context.Context, resourceKey ResourceKey, body DeleteResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteResourceResponse, error) {
	rsp, err := c.DeleteResource(ctx, resourceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResourceResponse(rsp)
}

// CreateRoleWithBodyWithResponse request with arbitrary body returning *CreateRoleResponse
func (c *ClientWithResponses) CreateRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error) {
	rsp, err := c.CreateRoleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleResponse(rsp)
}

func (c *ClientWithResponses) CreateRoleWithResponse(ctx context.Context, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error) {
	rsp, err := c.CreateRole(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleResponse(rsp)
}

// SearchRolesWithBodyWithResponse request with arbitrary body returning *SearchRolesResponse
func (c *ClientWithResponses) SearchRolesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchRolesResponse, error) {
	rsp, err := c.SearchRolesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRolesResponse(rsp)
}

func (c *ClientWithResponses) SearchRolesWithResponse(ctx context.Context, body SearchRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchRolesResponse, error) {
	rsp, err := c.SearchRoles(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRolesResponse(rsp)
}

// DeleteRoleWithResponse request returning *DeleteRoleResponse
func (c *ClientWithResponses) DeleteRoleWithResponse(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*DeleteRoleResponse, error) {
	rsp, err := c.DeleteRole(ctx, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRoleResponse(rsp)
}

// GetRoleWithResponse request returning *GetRoleResponse
func (c *ClientWithResponses) GetRoleWithResponse(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*GetRoleResponse, error) {
	rsp, err := c.GetRole(ctx, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleResponse(rsp)
}

// UpdateRoleWithBodyWithResponse request with arbitrary body returning *UpdateRoleResponse
func (c *ClientWithResponses) UpdateRoleWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error) {
	rsp, err := c.UpdateRoleWithBody(ctx, roleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleResponse(rsp)
}

func (c *ClientWithResponses) UpdateRoleWithResponse(ctx context.Context, roleId string, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error) {
	rsp, err := c.UpdateRole(ctx, roleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleResponse(rsp)
}

// SearchClientsForRoleWithBodyWithResponse request with arbitrary body returning *SearchClientsForRoleResponse
func (c *ClientWithResponses) SearchClientsForRoleWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchClientsForRoleResponse, error) {
	rsp, err := c.SearchClientsForRoleWithBody(ctx, roleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchClientsForRoleResponse(rsp)
}

func (c *ClientWithResponses) SearchClientsForRoleWithResponse(ctx context.Context, roleId string, body SearchClientsForRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchClientsForRoleResponse, error) {
	rsp, err := c.SearchClientsForRole(ctx, roleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchClientsForRoleResponse(rsp)
}

// UnassignRoleFromClientWithResponse request returning *UnassignRoleFromClientResponse
func (c *ClientWithResponses) UnassignRoleFromClientWithResponse(ctx context.Context, roleId string, clientId string, reqEditors ...RequestEditorFn) (*UnassignRoleFromClientResponse, error) {
	rsp, err := c.UnassignRoleFromClient(ctx, roleId, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignRoleFromClientResponse(rsp)
}

// AssignRoleToClientWithResponse request returning *AssignRoleToClientResponse
func (c *ClientWithResponses) AssignRoleToClientWithResponse(ctx context.Context, roleId string, clientId string, reqEditors ...RequestEditorFn) (*AssignRoleToClientResponse, error) {
	rsp, err := c.AssignRoleToClient(ctx, roleId, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignRoleToClientResponse(rsp)
}

// SearchGroupsForRoleWithBodyWithResponse request with arbitrary body returning *SearchGroupsForRoleResponse
func (c *ClientWithResponses) SearchGroupsForRoleWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchGroupsForRoleResponse, error) {
	rsp, err := c.SearchGroupsForRoleWithBody(ctx, roleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGroupsForRoleResponse(rsp)
}

func (c *ClientWithResponses) SearchGroupsForRoleWithResponse(ctx context.Context, roleId string, body SearchGroupsForRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchGroupsForRoleResponse, error) {
	rsp, err := c.SearchGroupsForRole(ctx, roleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGroupsForRoleResponse(rsp)
}

// UnassignRoleFromGroupWithResponse request returning *UnassignRoleFromGroupResponse
func (c *ClientWithResponses) UnassignRoleFromGroupWithResponse(ctx context.Context, roleId string, groupId string, reqEditors ...RequestEditorFn) (*UnassignRoleFromGroupResponse, error) {
	rsp, err := c.UnassignRoleFromGroup(ctx, roleId, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignRoleFromGroupResponse(rsp)
}

// AssignRoleToGroupWithResponse request returning *AssignRoleToGroupResponse
func (c *ClientWithResponses) AssignRoleToGroupWithResponse(ctx context.Context, roleId string, groupId string, reqEditors ...RequestEditorFn) (*AssignRoleToGroupResponse, error) {
	rsp, err := c.AssignRoleToGroup(ctx, roleId, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignRoleToGroupResponse(rsp)
}

// SearchMappingRulesForRoleWithBodyWithResponse request with arbitrary body returning *SearchMappingRulesForRoleResponse
func (c *ClientWithResponses) SearchMappingRulesForRoleWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchMappingRulesForRoleResponse, error) {
	rsp, err := c.SearchMappingRulesForRoleWithBody(ctx, roleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchMappingRulesForRoleResponse(rsp)
}

func (c *ClientWithResponses) SearchMappingRulesForRoleWithResponse(ctx context.Context, roleId string, body SearchMappingRulesForRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchMappingRulesForRoleResponse, error) {
	rsp, err := c.SearchMappingRulesForRole(ctx, roleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchMappingRulesForRoleResponse(rsp)
}

// UnassignRoleFromMappingRuleWithResponse request returning *UnassignRoleFromMappingRuleResponse
func (c *ClientWithResponses) UnassignRoleFromMappingRuleWithResponse(ctx context.Context, roleId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*UnassignRoleFromMappingRuleResponse, error) {
	rsp, err := c.UnassignRoleFromMappingRule(ctx, roleId, mappingRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignRoleFromMappingRuleResponse(rsp)
}

// AssignRoleToMappingRuleWithResponse request returning *AssignRoleToMappingRuleResponse
func (c *ClientWithResponses) AssignRoleToMappingRuleWithResponse(ctx context.Context, roleId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*AssignRoleToMappingRuleResponse, error) {
	rsp, err := c.AssignRoleToMappingRule(ctx, roleId, mappingRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignRoleToMappingRuleResponse(rsp)
}

// SearchUsersForRoleWithBodyWithResponse request with arbitrary body returning *SearchUsersForRoleResponse
func (c *ClientWithResponses) SearchUsersForRoleWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUsersForRoleResponse, error) {
	rsp, err := c.SearchUsersForRoleWithBody(ctx, roleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUsersForRoleResponse(rsp)
}

func (c *ClientWithResponses) SearchUsersForRoleWithResponse(ctx context.Context, roleId string, body SearchUsersForRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUsersForRoleResponse, error) {
	rsp, err := c.SearchUsersForRole(ctx, roleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUsersForRoleResponse(rsp)
}

// UnassignRoleFromUserWithResponse request returning *UnassignRoleFromUserResponse
func (c *ClientWithResponses) UnassignRoleFromUserWithResponse(ctx context.Context, roleId string, username Username, reqEditors ...RequestEditorFn) (*UnassignRoleFromUserResponse, error) {
	rsp, err := c.UnassignRoleFromUser(ctx, roleId, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignRoleFromUserResponse(rsp)
}

// AssignRoleToUserWithResponse request returning *AssignRoleToUserResponse
func (c *ClientWithResponses) AssignRoleToUserWithResponse(ctx context.Context, roleId string, username Username, reqEditors ...RequestEditorFn) (*AssignRoleToUserResponse, error) {
	rsp, err := c.AssignRoleToUser(ctx, roleId, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignRoleToUserResponse(rsp)
}

// CreateAdminUserWithBodyWithResponse request with arbitrary body returning *CreateAdminUserResponse
func (c *ClientWithResponses) CreateAdminUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAdminUserResponse, error) {
	rsp, err := c.CreateAdminUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAdminUserResponse(rsp)
}

func (c *ClientWithResponses) CreateAdminUserWithResponse(ctx context.Context, body CreateAdminUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAdminUserResponse, error) {
	rsp, err := c.CreateAdminUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAdminUserResponse(rsp)
}

// BroadcastSignalWithBodyWithResponse request with arbitrary body returning *BroadcastSignalResponse
func (c *ClientWithResponses) BroadcastSignalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BroadcastSignalResponse, error) {
	rsp, err := c.BroadcastSignalWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBroadcastSignalResponse(rsp)
}

func (c *ClientWithResponses) BroadcastSignalWithResponse(ctx context.Context, body BroadcastSignalJSONRequestBody, reqEditors ...RequestEditorFn) (*BroadcastSignalResponse, error) {
	rsp, err := c.BroadcastSignal(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBroadcastSignalResponse(rsp)
}

// GetStatusWithResponse request returning *GetStatusResponse
func (c *ClientWithResponses) GetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatusResponse, error) {
	rsp, err := c.GetStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatusResponse(rsp)
}

// GetUsageMetricsWithResponse request returning *GetUsageMetricsResponse
func (c *ClientWithResponses) GetUsageMetricsWithResponse(ctx context.Context, params *GetUsageMetricsParams, reqEditors ...RequestEditorFn) (*GetUsageMetricsResponse, error) {
	rsp, err := c.GetUsageMetrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsageMetricsResponse(rsp)
}

// CreateTenantWithBodyWithResponse request with arbitrary body returning *CreateTenantResponse
func (c *ClientWithResponses) CreateTenantWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTenantResponse, error) {
	rsp, err := c.CreateTenantWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTenantResponse(rsp)
}

func (c *ClientWithResponses) CreateTenantWithResponse(ctx context.Context, body CreateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTenantResponse, error) {
	rsp, err := c.CreateTenant(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTenantResponse(rsp)
}

// SearchTenantsWithBodyWithResponse request with arbitrary body returning *SearchTenantsResponse
func (c *ClientWithResponses) SearchTenantsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchTenantsResponse, error) {
	rsp, err := c.SearchTenantsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchTenantsResponse(rsp)
}

func (c *ClientWithResponses) SearchTenantsWithResponse(ctx context.Context, body SearchTenantsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchTenantsResponse, error) {
	rsp, err := c.SearchTenants(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchTenantsResponse(rsp)
}

// DeleteTenantWithResponse request returning *DeleteTenantResponse
func (c *ClientWithResponses) DeleteTenantWithResponse(ctx context.Context, tenantId TenantId, reqEditors ...RequestEditorFn) (*DeleteTenantResponse, error) {
	rsp, err := c.DeleteTenant(ctx, tenantId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTenantResponse(rsp)
}

// GetTenantWithResponse request returning *GetTenantResponse
func (c *ClientWithResponses) GetTenantWithResponse(ctx context.Context, tenantId TenantId, reqEditors ...RequestEditorFn) (*GetTenantResponse, error) {
	rsp, err := c.GetTenant(ctx, tenantId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTenantResponse(rsp)
}

// UpdateTenantWithBodyWithResponse request with arbitrary body returning *UpdateTenantResponse
func (c *ClientWithResponses) UpdateTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTenantResponse, error) {
	rsp, err := c.UpdateTenantWithBody(ctx, tenantId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTenantResponse(rsp)
}

func (c *ClientWithResponses) UpdateTenantWithResponse(ctx context.Context, tenantId TenantId, body UpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTenantResponse, error) {
	rsp, err := c.UpdateTenant(ctx, tenantId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTenantResponse(rsp)
}

// SearchClientsForTenantWithBodyWithResponse request with arbitrary body returning *SearchClientsForTenantResponse
func (c *ClientWithResponses) SearchClientsForTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchClientsForTenantResponse, error) {
	rsp, err := c.SearchClientsForTenantWithBody(ctx, tenantId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchClientsForTenantResponse(rsp)
}

func (c *ClientWithResponses) SearchClientsForTenantWithResponse(ctx context.Context, tenantId TenantId, body SearchClientsForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchClientsForTenantResponse, error) {
	rsp, err := c.SearchClientsForTenant(ctx, tenantId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchClientsForTenantResponse(rsp)
}

// UnassignClientFromTenantWithResponse request returning *UnassignClientFromTenantResponse
func (c *ClientWithResponses) UnassignClientFromTenantWithResponse(ctx context.Context, tenantId TenantId, clientId string, reqEditors ...RequestEditorFn) (*UnassignClientFromTenantResponse, error) {
	rsp, err := c.UnassignClientFromTenant(ctx, tenantId, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignClientFromTenantResponse(rsp)
}

// AssignClientToTenantWithResponse request returning *AssignClientToTenantResponse
func (c *ClientWithResponses) AssignClientToTenantWithResponse(ctx context.Context, tenantId TenantId, clientId string, reqEditors ...RequestEditorFn) (*AssignClientToTenantResponse, error) {
	rsp, err := c.AssignClientToTenant(ctx, tenantId, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignClientToTenantResponse(rsp)
}

// SearchGroupIdsForTenantWithBodyWithResponse request with arbitrary body returning *SearchGroupIdsForTenantResponse
func (c *ClientWithResponses) SearchGroupIdsForTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchGroupIdsForTenantResponse, error) {
	rsp, err := c.SearchGroupIdsForTenantWithBody(ctx, tenantId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGroupIdsForTenantResponse(rsp)
}

func (c *ClientWithResponses) SearchGroupIdsForTenantWithResponse(ctx context.Context, tenantId TenantId, body SearchGroupIdsForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchGroupIdsForTenantResponse, error) {
	rsp, err := c.SearchGroupIdsForTenant(ctx, tenantId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGroupIdsForTenantResponse(rsp)
}

// UnassignGroupFromTenantWithResponse request returning *UnassignGroupFromTenantResponse
func (c *ClientWithResponses) UnassignGroupFromTenantWithResponse(ctx context.Context, tenantId TenantId, groupId string, reqEditors ...RequestEditorFn) (*UnassignGroupFromTenantResponse, error) {
	rsp, err := c.UnassignGroupFromTenant(ctx, tenantId, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignGroupFromTenantResponse(rsp)
}

// AssignGroupToTenantWithResponse request returning *AssignGroupToTenantResponse
func (c *ClientWithResponses) AssignGroupToTenantWithResponse(ctx context.Context, tenantId TenantId, groupId string, reqEditors ...RequestEditorFn) (*AssignGroupToTenantResponse, error) {
	rsp, err := c.AssignGroupToTenant(ctx, tenantId, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignGroupToTenantResponse(rsp)
}

// SearchMappingRulesForTenantWithBodyWithResponse request with arbitrary body returning *SearchMappingRulesForTenantResponse
func (c *ClientWithResponses) SearchMappingRulesForTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchMappingRulesForTenantResponse, error) {
	rsp, err := c.SearchMappingRulesForTenantWithBody(ctx, tenantId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchMappingRulesForTenantResponse(rsp)
}

func (c *ClientWithResponses) SearchMappingRulesForTenantWithResponse(ctx context.Context, tenantId TenantId, body SearchMappingRulesForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchMappingRulesForTenantResponse, error) {
	rsp, err := c.SearchMappingRulesForTenant(ctx, tenantId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchMappingRulesForTenantResponse(rsp)
}

// UnassignMappingRuleFromTenantWithResponse request returning *UnassignMappingRuleFromTenantResponse
func (c *ClientWithResponses) UnassignMappingRuleFromTenantWithResponse(ctx context.Context, tenantId TenantId, mappingRuleId string, reqEditors ...RequestEditorFn) (*UnassignMappingRuleFromTenantResponse, error) {
	rsp, err := c.UnassignMappingRuleFromTenant(ctx, tenantId, mappingRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignMappingRuleFromTenantResponse(rsp)
}

// AssignMappingRuleToTenantWithResponse request returning *AssignMappingRuleToTenantResponse
func (c *ClientWithResponses) AssignMappingRuleToTenantWithResponse(ctx context.Context, tenantId TenantId, mappingRuleId string, reqEditors ...RequestEditorFn) (*AssignMappingRuleToTenantResponse, error) {
	rsp, err := c.AssignMappingRuleToTenant(ctx, tenantId, mappingRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignMappingRuleToTenantResponse(rsp)
}

// SearchRolesForTenantWithBodyWithResponse request with arbitrary body returning *SearchRolesForTenantResponse
func (c *ClientWithResponses) SearchRolesForTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchRolesForTenantResponse, error) {
	rsp, err := c.SearchRolesForTenantWithBody(ctx, tenantId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRolesForTenantResponse(rsp)
}

func (c *ClientWithResponses) SearchRolesForTenantWithResponse(ctx context.Context, tenantId TenantId, body SearchRolesForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchRolesForTenantResponse, error) {
	rsp, err := c.SearchRolesForTenant(ctx, tenantId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRolesForTenantResponse(rsp)
}

// UnassignRoleFromTenantWithResponse request returning *UnassignRoleFromTenantResponse
func (c *ClientWithResponses) UnassignRoleFromTenantWithResponse(ctx context.Context, tenantId TenantId, roleId string, reqEditors ...RequestEditorFn) (*UnassignRoleFromTenantResponse, error) {
	rsp, err := c.UnassignRoleFromTenant(ctx, tenantId, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignRoleFromTenantResponse(rsp)
}

// AssignRoleToTenantWithResponse request returning *AssignRoleToTenantResponse
func (c *ClientWithResponses) AssignRoleToTenantWithResponse(ctx context.Context, tenantId TenantId, roleId string, reqEditors ...RequestEditorFn) (*AssignRoleToTenantResponse, error) {
	rsp, err := c.AssignRoleToTenant(ctx, tenantId, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignRoleToTenantResponse(rsp)
}

// SearchUsersForTenantWithBodyWithResponse request with arbitrary body returning *SearchUsersForTenantResponse
func (c *ClientWithResponses) SearchUsersForTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUsersForTenantResponse, error) {
	rsp, err := c.SearchUsersForTenantWithBody(ctx, tenantId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUsersForTenantResponse(rsp)
}

func (c *ClientWithResponses) SearchUsersForTenantWithResponse(ctx context.Context, tenantId TenantId, body SearchUsersForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUsersForTenantResponse, error) {
	rsp, err := c.SearchUsersForTenant(ctx, tenantId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUsersForTenantResponse(rsp)
}

// UnassignUserFromTenantWithResponse request returning *UnassignUserFromTenantResponse
func (c *ClientWithResponses) UnassignUserFromTenantWithResponse(ctx context.Context, tenantId TenantId, username Username, reqEditors ...RequestEditorFn) (*UnassignUserFromTenantResponse, error) {
	rsp, err := c.UnassignUserFromTenant(ctx, tenantId, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignUserFromTenantResponse(rsp)
}

// AssignUserToTenantWithResponse request returning *AssignUserToTenantResponse
func (c *ClientWithResponses) AssignUserToTenantWithResponse(ctx context.Context, tenantId TenantId, username Username, reqEditors ...RequestEditorFn) (*AssignUserToTenantResponse, error) {
	rsp, err := c.AssignUserToTenant(ctx, tenantId, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignUserToTenantResponse(rsp)
}

// GetTopologyWithResponse request returning *GetTopologyResponse
func (c *ClientWithResponses) GetTopologyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTopologyResponse, error) {
	rsp, err := c.GetTopology(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTopologyResponse(rsp)
}

// SearchUserTasksWithBodyWithResponse request with arbitrary body returning *SearchUserTasksResponse
func (c *ClientWithResponses) SearchUserTasksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUserTasksResponse, error) {
	rsp, err := c.SearchUserTasksWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUserTasksResponse(rsp)
}

func (c *ClientWithResponses) SearchUserTasksWithResponse(ctx context.Context, body SearchUserTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUserTasksResponse, error) {
	rsp, err := c.SearchUserTasks(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUserTasksResponse(rsp)
}

// GetUserTaskWithResponse request returning *GetUserTaskResponse
func (c *ClientWithResponses) GetUserTaskWithResponse(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*GetUserTaskResponse, error) {
	rsp, err := c.GetUserTask(ctx, userTaskKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserTaskResponse(rsp)
}

// UpdateUserTaskWithBodyWithResponse request with arbitrary body returning *UpdateUserTaskResponse
func (c *ClientWithResponses) UpdateUserTaskWithBodyWithResponse(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserTaskResponse, error) {
	rsp, err := c.UpdateUserTaskWithBody(ctx, userTaskKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserTaskResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserTaskWithResponse(ctx context.Context, userTaskKey string, body UpdateUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserTaskResponse, error) {
	rsp, err := c.UpdateUserTask(ctx, userTaskKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserTaskResponse(rsp)
}

// UnassignUserTaskWithResponse request returning *UnassignUserTaskResponse
func (c *ClientWithResponses) UnassignUserTaskWithResponse(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*UnassignUserTaskResponse, error) {
	rsp, err := c.UnassignUserTask(ctx, userTaskKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignUserTaskResponse(rsp)
}

// AssignUserTaskWithBodyWithResponse request with arbitrary body returning *AssignUserTaskResponse
func (c *ClientWithResponses) AssignUserTaskWithBodyWithResponse(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignUserTaskResponse, error) {
	rsp, err := c.AssignUserTaskWithBody(ctx, userTaskKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignUserTaskResponse(rsp)
}

func (c *ClientWithResponses) AssignUserTaskWithResponse(ctx context.Context, userTaskKey string, body AssignUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignUserTaskResponse, error) {
	rsp, err := c.AssignUserTask(ctx, userTaskKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignUserTaskResponse(rsp)
}

// CompleteUserTaskWithBodyWithResponse request with arbitrary body returning *CompleteUserTaskResponse
func (c *ClientWithResponses) CompleteUserTaskWithBodyWithResponse(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompleteUserTaskResponse, error) {
	rsp, err := c.CompleteUserTaskWithBody(ctx, userTaskKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompleteUserTaskResponse(rsp)
}

func (c *ClientWithResponses) CompleteUserTaskWithResponse(ctx context.Context, userTaskKey string, body CompleteUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CompleteUserTaskResponse, error) {
	rsp, err := c.CompleteUserTask(ctx, userTaskKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompleteUserTaskResponse(rsp)
}

// GetUserTaskFormWithResponse request returning *GetUserTaskFormResponse
func (c *ClientWithResponses) GetUserTaskFormWithResponse(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*GetUserTaskFormResponse, error) {
	rsp, err := c.GetUserTaskForm(ctx, userTaskKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserTaskFormResponse(rsp)
}

// SearchUserTaskVariablesWithBodyWithResponse request with arbitrary body returning *SearchUserTaskVariablesResponse
func (c *ClientWithResponses) SearchUserTaskVariablesWithBodyWithResponse(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUserTaskVariablesResponse, error) {
	rsp, err := c.SearchUserTaskVariablesWithBody(ctx, userTaskKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUserTaskVariablesResponse(rsp)
}

func (c *ClientWithResponses) SearchUserTaskVariablesWithResponse(ctx context.Context, userTaskKey string, body SearchUserTaskVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUserTaskVariablesResponse, error) {
	rsp, err := c.SearchUserTaskVariables(ctx, userTaskKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUserTaskVariablesResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// SearchUsersWithBodyWithResponse request with arbitrary body returning *SearchUsersResponse
func (c *ClientWithResponses) SearchUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUsersResponse, error) {
	rsp, err := c.SearchUsersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUsersResponse(rsp)
}

func (c *ClientWithResponses) SearchUsersWithResponse(ctx context.Context, body SearchUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUsersResponse, error) {
	rsp, err := c.SearchUsers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUsersResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, username, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, username Username, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, username, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// SearchVariablesWithBodyWithResponse request with arbitrary body returning *SearchVariablesResponse
func (c *ClientWithResponses) SearchVariablesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchVariablesResponse, error) {
	rsp, err := c.SearchVariablesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchVariablesResponse(rsp)
}

func (c *ClientWithResponses) SearchVariablesWithResponse(ctx context.Context, body SearchVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchVariablesResponse, error) {
	rsp, err := c.SearchVariables(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchVariablesResponse(rsp)
}

// GetVariableWithResponse request returning *GetVariableResponse
func (c *ClientWithResponses) GetVariableWithResponse(ctx context.Context, variableKey string, reqEditors ...RequestEditorFn) (*GetVariableResponse, error) {
	rsp, err := c.GetVariable(ctx, variableKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVariableResponse(rsp)
}

// ParseGetAuthenticationResponse parses an HTTP response from a GetAuthenticationWithResponse call
func ParseGetAuthenticationResponse(rsp *http.Response) (*GetAuthenticationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthenticationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CamundaUserResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateAuthorizationResponse parses an HTTP response from a CreateAuthorizationWithResponse call
func ParseCreateAuthorizationResponse(rsp *http.Response) (*CreateAuthorizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAuthorizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AuthorizationCreateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchAuthorizationsResponse parses an HTTP response from a SearchAuthorizationsWithResponse call
func ParseSearchAuthorizationsResponse(rsp *http.Response) (*SearchAuthorizationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchAuthorizationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthorizationSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAuthorizationResponse parses an HTTP response from a DeleteAuthorizationWithResponse call
func ParseDeleteAuthorizationResponse(rsp *http.Response) (*DeleteAuthorizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAuthorizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetAuthorizationResponse parses an HTTP response from a GetAuthorizationWithResponse call
func ParseGetAuthorizationResponse(rsp *http.Response) (*GetAuthorizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthorizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthorizationResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAuthorizationResponse parses an HTTP response from a UpdateAuthorizationWithResponse call
func ParseUpdateAuthorizationResponse(rsp *http.Response) (*UpdateAuthorizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAuthorizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchBatchOperationItemsResponse parses an HTTP response from a SearchBatchOperationItemsWithResponse call
func ParseSearchBatchOperationItemsResponse(rsp *http.Response) (*SearchBatchOperationItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchBatchOperationItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchOperationItemSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearchBatchOperationsResponse parses an HTTP response from a SearchBatchOperationsWithResponse call
func ParseSearchBatchOperationsResponse(rsp *http.Response) (*SearchBatchOperationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchBatchOperationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchOperationSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetBatchOperationResponse parses an HTTP response from a GetBatchOperationWithResponse call
func ParseGetBatchOperationResponse(rsp *http.Response) (*GetBatchOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBatchOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchOperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCancelBatchOperationResponse parses an HTTP response from a CancelBatchOperationWithResponse call
func ParseCancelBatchOperationResponse(rsp *http.Response) (*CancelBatchOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelBatchOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseResumeBatchOperationResponse parses an HTTP response from a ResumeBatchOperationWithResponse call
func ParseResumeBatchOperationResponse(rsp *http.Response) (*ResumeBatchOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResumeBatchOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSuspendBatchOperationResponse parses an HTTP response from a SuspendBatchOperationWithResponse call
func ParseSuspendBatchOperationResponse(rsp *http.Response) (*SuspendBatchOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SuspendBatchOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParsePinClockResponse parses an HTTP response from a PinClockWithResponse call
func ParsePinClockResponse(rsp *http.Response) (*PinClockResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PinClockResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseResetClockResponse parses an HTTP response from a ResetClockWithResponse call
func ParseResetClockResponse(rsp *http.Response) (*ResetClockResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetClockResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchCorrelatedMessageSubscriptionsResponse parses an HTTP response from a SearchCorrelatedMessageSubscriptionsWithResponse call
func ParseSearchCorrelatedMessageSubscriptionsResponse(rsp *http.Response) (*SearchCorrelatedMessageSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchCorrelatedMessageSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CorrelatedMessageSubscriptionSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseEvaluateDecisionResponse parses an HTTP response from a EvaluateDecisionWithResponse call
func ParseEvaluateDecisionResponse(rsp *http.Response) (*EvaluateDecisionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EvaluateDecisionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvaluateDecisionResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchDecisionDefinitionsResponse parses an HTTP response from a SearchDecisionDefinitionsWithResponse call
func ParseSearchDecisionDefinitionsResponse(rsp *http.Response) (*SearchDecisionDefinitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchDecisionDefinitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DecisionDefinitionSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDecisionDefinitionResponse parses an HTTP response from a GetDecisionDefinitionWithResponse call
func ParseGetDecisionDefinitionResponse(rsp *http.Response) (*GetDecisionDefinitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionDefinitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DecisionDefinitionResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDecisionDefinitionXMLResponse parses an HTTP response from a GetDecisionDefinitionXMLWithResponse call
func ParseGetDecisionDefinitionXMLResponse(rsp *http.Response) (*GetDecisionDefinitionXMLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionDefinitionXMLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest string
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseSearchDecisionInstancesResponse parses an HTTP response from a SearchDecisionInstancesWithResponse call
func ParseSearchDecisionInstancesResponse(rsp *http.Response) (*SearchDecisionInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchDecisionInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DecisionInstanceSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDecisionInstanceResponse parses an HTTP response from a GetDecisionInstanceWithResponse call
func ParseGetDecisionInstanceResponse(rsp *http.Response) (*GetDecisionInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DecisionInstanceGetQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearchDecisionRequirementsResponse parses an HTTP response from a SearchDecisionRequirementsWithResponse call
func ParseSearchDecisionRequirementsResponse(rsp *http.Response) (*SearchDecisionRequirementsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchDecisionRequirementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DecisionRequirementsSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDecisionRequirementsResponse parses an HTTP response from a GetDecisionRequirementsWithResponse call
func ParseGetDecisionRequirementsResponse(rsp *http.Response) (*GetDecisionRequirementsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionRequirementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DecisionRequirementsResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDecisionRequirementsXMLResponse parses an HTTP response from a GetDecisionRequirementsXMLWithResponse call
func ParseGetDecisionRequirementsXMLResponse(rsp *http.Response) (*GetDecisionRequirementsXMLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionRequirementsXMLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest string
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseCreateDeploymentResponse parses an HTTP response from a CreateDeploymentWithResponse call
func ParseCreateDeploymentResponse(rsp *http.Response) (*CreateDeploymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDeploymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeploymentResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseCreateDocumentResponse parses an HTTP response from a CreateDocumentWithResponse call
func ParseCreateDocumentResponse(rsp *http.Response) (*CreateDocumentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DocumentReference
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON415 = &dest

	}

	return response, nil
}

// ParseCreateDocumentsResponse parses an HTTP response from a CreateDocumentsWithResponse call
func ParseCreateDocumentsResponse(rsp *http.Response) (*CreateDocumentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDocumentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DocumentCreationBatchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest DocumentCreationBatchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON415 = &dest

	}

	return response, nil
}

// ParseDeleteDocumentResponse parses an HTTP response from a DeleteDocumentWithResponse call
func ParseDeleteDocumentResponse(rsp *http.Response) (*DeleteDocumentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDocumentResponse parses an HTTP response from a GetDocumentWithResponse call
func ParseGetDocumentResponse(rsp *http.Response) (*GetDocumentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateDocumentLinkResponse parses an HTTP response from a CreateDocumentLinkWithResponse call
func ParseCreateDocumentLinkResponse(rsp *http.Response) (*CreateDocumentLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDocumentLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DocumentLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	}

	return response, nil
}

// ParseActivateAdHocSubProcessActivitiesResponse parses an HTTP response from a ActivateAdHocSubProcessActivitiesWithResponse call
func ParseActivateAdHocSubProcessActivitiesResponse(rsp *http.Response) (*ActivateAdHocSubProcessActivitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivateAdHocSubProcessActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchElementInstancesResponse parses an HTTP response from a SearchElementInstancesWithResponse call
func ParseSearchElementInstancesResponse(rsp *http.Response) (*SearchElementInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchElementInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ElementInstanceSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetElementInstanceResponse parses an HTTP response from a GetElementInstanceWithResponse call
func ParseGetElementInstanceResponse(rsp *http.Response) (*GetElementInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetElementInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ElementInstanceResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateElementInstanceVariablesResponse parses an HTTP response from a CreateElementInstanceVariablesWithResponse call
func ParseCreateElementInstanceVariablesResponse(rsp *http.Response) (*CreateElementInstanceVariablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateElementInstanceVariablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseCreateGroupResponse parses an HTTP response from a CreateGroupWithResponse call
func ParseCreateGroupResponse(rsp *http.Response) (*CreateGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GroupCreateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchGroupsResponse parses an HTTP response from a SearchGroupsWithResponse call
func ParseSearchGroupsResponse(rsp *http.Response) (*SearchGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteGroupResponse parses an HTTP response from a DeleteGroupWithResponse call
func ParseDeleteGroupResponse(rsp *http.Response) (*DeleteGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetGroupResponse parses an HTTP response from a GetGroupWithResponse call
func ParseGetGroupResponse(rsp *http.Response) (*GetGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateGroupResponse parses an HTTP response from a UpdateGroupWithResponse call
func ParseUpdateGroupResponse(rsp *http.Response) (*UpdateGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupUpdateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchClientsForGroupResponse parses an HTTP response from a SearchClientsForGroupWithResponse call
func ParseSearchClientsForGroupResponse(rsp *http.Response) (*SearchClientsForGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchClientsForGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupClientSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnassignClientFromGroupResponse parses an HTTP response from a UnassignClientFromGroupWithResponse call
func ParseUnassignClientFromGroupResponse(rsp *http.Response) (*UnassignClientFromGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignClientFromGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignClientToGroupResponse parses an HTTP response from a AssignClientToGroupWithResponse call
func ParseAssignClientToGroupResponse(rsp *http.Response) (*AssignClientToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignClientToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchMappingRulesForGroupResponse parses an HTTP response from a SearchMappingRulesForGroupWithResponse call
func ParseSearchMappingRulesForGroupResponse(rsp *http.Response) (*SearchMappingRulesForGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchMappingRulesForGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MappingRuleSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnassignMappingRuleFromGroupResponse parses an HTTP response from a UnassignMappingRuleFromGroupWithResponse call
func ParseUnassignMappingRuleFromGroupResponse(rsp *http.Response) (*UnassignMappingRuleFromGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignMappingRuleFromGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignMappingRuleToGroupResponse parses an HTTP response from a AssignMappingRuleToGroupWithResponse call
func ParseAssignMappingRuleToGroupResponse(rsp *http.Response) (*AssignMappingRuleToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignMappingRuleToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchRolesForGroupResponse parses an HTTP response from a SearchRolesForGroupWithResponse call
func ParseSearchRolesForGroupResponse(rsp *http.Response) (*SearchRolesForGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchRolesForGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearchUsersForGroupResponse parses an HTTP response from a SearchUsersForGroupWithResponse call
func ParseSearchUsersForGroupResponse(rsp *http.Response) (*SearchUsersForGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchUsersForGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupUserSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnassignUserFromGroupResponse parses an HTTP response from a UnassignUserFromGroupWithResponse call
func ParseUnassignUserFromGroupResponse(rsp *http.Response) (*UnassignUserFromGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignUserFromGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignUserToGroupResponse parses an HTTP response from a AssignUserToGroupWithResponse call
func ParseAssignUserToGroupResponse(rsp *http.Response) (*AssignUserToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignUserToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchIncidentsResponse parses an HTTP response from a SearchIncidentsWithResponse call
func ParseSearchIncidentsResponse(rsp *http.Response) (*SearchIncidentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchIncidentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IncidentSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetIncidentResponse parses an HTTP response from a GetIncidentWithResponse call
func ParseGetIncidentResponse(rsp *http.Response) (*GetIncidentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIncidentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IncidentResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseResolveIncidentResponse parses an HTTP response from a ResolveIncidentWithResponse call
func ParseResolveIncidentResponse(rsp *http.Response) (*ResolveIncidentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResolveIncidentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseActivateJobsResponse parses an HTTP response from a ActivateJobsWithResponse call
func ParseActivateJobsResponse(rsp *http.Response) (*ActivateJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivateJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobActivationResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchJobsResponse parses an HTTP response from a SearchJobsWithResponse call
func ParseSearchJobsResponse(rsp *http.Response) (*SearchJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateJobResponse parses an HTTP response from a UpdateJobWithResponse call
func ParseUpdateJobResponse(rsp *http.Response) (*UpdateJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseCompleteJobResponse parses an HTTP response from a CompleteJobWithResponse call
func ParseCompleteJobResponse(rsp *http.Response) (*CompleteJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompleteJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseThrowJobErrorResponse parses an HTTP response from a ThrowJobErrorWithResponse call
func ParseThrowJobErrorResponse(rsp *http.Response) (*ThrowJobErrorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ThrowJobErrorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseFailJobResponse parses an HTTP response from a FailJobWithResponse call
func ParseFailJobResponse(rsp *http.Response) (*FailJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FailJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetLicenseResponse parses an HTTP response from a GetLicenseWithResponse call
func ParseGetLicenseResponse(rsp *http.Response) (*GetLicenseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLicenseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LicenseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateMappingRuleResponse parses an HTTP response from a CreateMappingRuleWithResponse call
func ParseCreateMappingRuleResponse(rsp *http.Response) (*CreateMappingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMappingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MappingRuleCreateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearchMappingRuleResponse parses an HTTP response from a SearchMappingRuleWithResponse call
func ParseSearchMappingRuleResponse(rsp *http.Response) (*SearchMappingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchMappingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MappingRuleSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteMappingRuleResponse parses an HTTP response from a DeleteMappingRuleWithResponse call
func ParseDeleteMappingRuleResponse(rsp *http.Response) (*DeleteMappingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMappingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetMappingRuleResponse parses an HTTP response from a GetMappingRuleWithResponse call
func ParseGetMappingRuleResponse(rsp *http.Response) (*GetMappingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMappingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MappingRuleResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateMappingRuleResponse parses an HTTP response from a UpdateMappingRuleWithResponse call
func ParseUpdateMappingRuleResponse(rsp *http.Response) (*UpdateMappingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMappingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MappingRuleUpdateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchMessageSubscriptionsResponse parses an HTTP response from a SearchMessageSubscriptionsWithResponse call
func ParseSearchMessageSubscriptionsResponse(rsp *http.Response) (*SearchMessageSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchMessageSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessageSubscriptionSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCorrelateMessageResponse parses an HTTP response from a CorrelateMessageWithResponse call
func ParseCorrelateMessageResponse(rsp *http.Response) (*CorrelateMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CorrelateMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessageCorrelationResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParsePublishMessageResponse parses an HTTP response from a PublishMessageWithResponse call
func ParsePublishMessageResponse(rsp *http.Response) (*PublishMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PublishMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessagePublicationResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchProcessDefinitionsResponse parses an HTTP response from a SearchProcessDefinitionsWithResponse call
func ParseSearchProcessDefinitionsResponse(rsp *http.Response) (*SearchProcessDefinitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchProcessDefinitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessDefinitionSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetProcessDefinitionResponse parses an HTTP response from a GetProcessDefinitionWithResponse call
func ParseGetProcessDefinitionResponse(rsp *http.Response) (*GetProcessDefinitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessDefinitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessDefinitionResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetStartProcessFormResponse parses an HTTP response from a GetStartProcessFormWithResponse call
func ParseGetStartProcessFormResponse(rsp *http.Response) (*GetStartProcessFormResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStartProcessFormResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FormResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetProcessDefinitionStatisticsResponse parses an HTTP response from a GetProcessDefinitionStatisticsWithResponse call
func ParseGetProcessDefinitionStatisticsResponse(rsp *http.Response) (*GetProcessDefinitionStatisticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessDefinitionStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessDefinitionElementStatisticsQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetProcessDefinitionXMLResponse parses an HTTP response from a GetProcessDefinitionXMLWithResponse call
func ParseGetProcessDefinitionXMLResponse(rsp *http.Response) (*GetProcessDefinitionXMLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessDefinitionXMLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest string
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseCreateProcessInstanceResponse parses an HTTP response from a CreateProcessInstanceWithResponse call
func ParseCreateProcessInstanceResponse(rsp *http.Response) (*CreateProcessInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProcessInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateProcessInstanceResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON504 = &dest

	}

	return response, nil
}

// ParseCancelProcessInstancesBatchOperationResponse parses an HTTP response from a CancelProcessInstancesBatchOperationWithResponse call
func ParseCancelProcessInstancesBatchOperationResponse(rsp *http.Response) (*CancelProcessInstancesBatchOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelProcessInstancesBatchOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchOperationCreatedResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseResolveIncidentsBatchOperationResponse parses an HTTP response from a ResolveIncidentsBatchOperationWithResponse call
func ParseResolveIncidentsBatchOperationResponse(rsp *http.Response) (*ResolveIncidentsBatchOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResolveIncidentsBatchOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchOperationCreatedResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseMigrateProcessInstancesBatchOperationResponse parses an HTTP response from a MigrateProcessInstancesBatchOperationWithResponse call
func ParseMigrateProcessInstancesBatchOperationResponse(rsp *http.Response) (*MigrateProcessInstancesBatchOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrateProcessInstancesBatchOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchOperationCreatedResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseModifyProcessInstancesBatchOperationResponse parses an HTTP response from a ModifyProcessInstancesBatchOperationWithResponse call
func ParseModifyProcessInstancesBatchOperationResponse(rsp *http.Response) (*ModifyProcessInstancesBatchOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyProcessInstancesBatchOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchOperationCreatedResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearchProcessInstancesResponse parses an HTTP response from a SearchProcessInstancesWithResponse call
func ParseSearchProcessInstancesResponse(rsp *http.Response) (*SearchProcessInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchProcessInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessInstanceSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetProcessInstanceResponse parses an HTTP response from a GetProcessInstanceWithResponse call
func ParseGetProcessInstanceResponse(rsp *http.Response) (*GetProcessInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessInstanceResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetProcessInstanceCallHierarchyResponse parses an HTTP response from a GetProcessInstanceCallHierarchyWithResponse call
func ParseGetProcessInstanceCallHierarchyResponse(rsp *http.Response) (*GetProcessInstanceCallHierarchyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessInstanceCallHierarchyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ProcessInstanceCallHierarchyEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCancelProcessInstanceResponse parses an HTTP response from a CancelProcessInstanceWithResponse call
func ParseCancelProcessInstanceResponse(rsp *http.Response) (*CancelProcessInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelProcessInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchProcessInstanceIncidentsResponse parses an HTTP response from a SearchProcessInstanceIncidentsWithResponse call
func ParseSearchProcessInstanceIncidentsResponse(rsp *http.Response) (*SearchProcessInstanceIncidentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchProcessInstanceIncidentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IncidentSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseMigrateProcessInstanceResponse parses an HTTP response from a MigrateProcessInstanceWithResponse call
func ParseMigrateProcessInstanceResponse(rsp *http.Response) (*MigrateProcessInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrateProcessInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseModifyProcessInstanceResponse parses an HTTP response from a ModifyProcessInstanceWithResponse call
func ParseModifyProcessInstanceResponse(rsp *http.Response) (*ModifyProcessInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyProcessInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetProcessInstanceSequenceFlowsResponse parses an HTTP response from a GetProcessInstanceSequenceFlowsWithResponse call
func ParseGetProcessInstanceSequenceFlowsResponse(rsp *http.Response) (*GetProcessInstanceSequenceFlowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessInstanceSequenceFlowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessInstanceSequenceFlowsQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetProcessInstanceStatisticsResponse parses an HTTP response from a GetProcessInstanceStatisticsWithResponse call
func ParseGetProcessInstanceStatisticsResponse(rsp *http.Response) (*GetProcessInstanceStatisticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessInstanceStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessInstanceElementStatisticsQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceResponse parses an HTTP response from a GetResourceWithResponse call
func ParseGetResourceResponse(rsp *http.Response) (*GetResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourceResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceContentResponse parses an HTTP response from a GetResourceContentWithResponse call
func ParseGetResourceContentResponse(rsp *http.Response) (*GetResourceContentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteResourceResponse parses an HTTP response from a DeleteResourceWithResponse call
func ParseDeleteResourceResponse(rsp *http.Response) (*DeleteResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseCreateRoleResponse parses an HTTP response from a CreateRoleWithResponse call
func ParseCreateRoleResponse(rsp *http.Response) (*CreateRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RoleCreateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchRolesResponse parses an HTTP response from a SearchRolesWithResponse call
func ParseSearchRolesResponse(rsp *http.Response) (*SearchRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRoleResponse parses an HTTP response from a DeleteRoleWithResponse call
func ParseDeleteRoleResponse(rsp *http.Response) (*DeleteRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetRoleResponse parses an HTTP response from a GetRoleWithResponse call
func ParseGetRoleResponse(rsp *http.Response) (*GetRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRoleResponse parses an HTTP response from a UpdateRoleWithResponse call
func ParseUpdateRoleResponse(rsp *http.Response) (*UpdateRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleUpdateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchClientsForRoleResponse parses an HTTP response from a SearchClientsForRoleWithResponse call
func ParseSearchClientsForRoleResponse(rsp *http.Response) (*SearchClientsForRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchClientsForRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleClientSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnassignRoleFromClientResponse parses an HTTP response from a UnassignRoleFromClientWithResponse call
func ParseUnassignRoleFromClientResponse(rsp *http.Response) (*UnassignRoleFromClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignRoleFromClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignRoleToClientResponse parses an HTTP response from a AssignRoleToClientWithResponse call
func ParseAssignRoleToClientResponse(rsp *http.Response) (*AssignRoleToClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignRoleToClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchGroupsForRoleResponse parses an HTTP response from a SearchGroupsForRoleWithResponse call
func ParseSearchGroupsForRoleResponse(rsp *http.Response) (*SearchGroupsForRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchGroupsForRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleGroupSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnassignRoleFromGroupResponse parses an HTTP response from a UnassignRoleFromGroupWithResponse call
func ParseUnassignRoleFromGroupResponse(rsp *http.Response) (*UnassignRoleFromGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignRoleFromGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignRoleToGroupResponse parses an HTTP response from a AssignRoleToGroupWithResponse call
func ParseAssignRoleToGroupResponse(rsp *http.Response) (*AssignRoleToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignRoleToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchMappingRulesForRoleResponse parses an HTTP response from a SearchMappingRulesForRoleWithResponse call
func ParseSearchMappingRulesForRoleResponse(rsp *http.Response) (*SearchMappingRulesForRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchMappingRulesForRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MappingRuleSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnassignRoleFromMappingRuleResponse parses an HTTP response from a UnassignRoleFromMappingRuleWithResponse call
func ParseUnassignRoleFromMappingRuleResponse(rsp *http.Response) (*UnassignRoleFromMappingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignRoleFromMappingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignRoleToMappingRuleResponse parses an HTTP response from a AssignRoleToMappingRuleWithResponse call
func ParseAssignRoleToMappingRuleResponse(rsp *http.Response) (*AssignRoleToMappingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignRoleToMappingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchUsersForRoleResponse parses an HTTP response from a SearchUsersForRoleWithResponse call
func ParseSearchUsersForRoleResponse(rsp *http.Response) (*SearchUsersForRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchUsersForRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleUserSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnassignRoleFromUserResponse parses an HTTP response from a UnassignRoleFromUserWithResponse call
func ParseUnassignRoleFromUserResponse(rsp *http.Response) (*UnassignRoleFromUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignRoleFromUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignRoleToUserResponse parses an HTTP response from a AssignRoleToUserWithResponse call
func ParseAssignRoleToUserResponse(rsp *http.Response) (*AssignRoleToUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignRoleToUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseCreateAdminUserResponse parses an HTTP response from a CreateAdminUserWithResponse call
func ParseCreateAdminUserResponse(rsp *http.Response) (*CreateAdminUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAdminUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest UserCreateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseBroadcastSignalResponse parses an HTTP response from a BroadcastSignalWithResponse call
func ParseBroadcastSignalResponse(rsp *http.Response) (*BroadcastSignalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BroadcastSignalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SignalBroadcastResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetStatusResponse parses an HTTP response from a GetStatusWithResponse call
func ParseGetStatusResponse(rsp *http.Response) (*GetStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUsageMetricsResponse parses an HTTP response from a GetUsageMetricsWithResponse call
func ParseGetUsageMetricsResponse(rsp *http.Response) (*GetUsageMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsageMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsageMetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateTenantResponse parses an HTTP response from a CreateTenantWithResponse call
func ParseCreateTenantResponse(rsp *http.Response) (*CreateTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TenantCreateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchTenantsResponse parses an HTTP response from a SearchTenantsWithResponse call
func ParseSearchTenantsResponse(rsp *http.Response) (*SearchTenantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchTenantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTenantResponse parses an HTTP response from a DeleteTenantWithResponse call
func ParseDeleteTenantResponse(rsp *http.Response) (*DeleteTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetTenantResponse parses an HTTP response from a GetTenantWithResponse call
func ParseGetTenantResponse(rsp *http.Response) (*GetTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateTenantResponse parses an HTTP response from a UpdateTenantWithResponse call
func ParseUpdateTenantResponse(rsp *http.Response) (*UpdateTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantUpdateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchClientsForTenantResponse parses an HTTP response from a SearchClientsForTenantWithResponse call
func ParseSearchClientsForTenantResponse(rsp *http.Response) (*SearchClientsForTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchClientsForTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantClientSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnassignClientFromTenantResponse parses an HTTP response from a UnassignClientFromTenantWithResponse call
func ParseUnassignClientFromTenantResponse(rsp *http.Response) (*UnassignClientFromTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignClientFromTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignClientToTenantResponse parses an HTTP response from a AssignClientToTenantWithResponse call
func ParseAssignClientToTenantResponse(rsp *http.Response) (*AssignClientToTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignClientToTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchGroupIdsForTenantResponse parses an HTTP response from a SearchGroupIdsForTenantWithResponse call
func ParseSearchGroupIdsForTenantResponse(rsp *http.Response) (*SearchGroupIdsForTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchGroupIdsForTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantGroupSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnassignGroupFromTenantResponse parses an HTTP response from a UnassignGroupFromTenantWithResponse call
func ParseUnassignGroupFromTenantResponse(rsp *http.Response) (*UnassignGroupFromTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignGroupFromTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignGroupToTenantResponse parses an HTTP response from a AssignGroupToTenantWithResponse call
func ParseAssignGroupToTenantResponse(rsp *http.Response) (*AssignGroupToTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignGroupToTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchMappingRulesForTenantResponse parses an HTTP response from a SearchMappingRulesForTenantWithResponse call
func ParseSearchMappingRulesForTenantResponse(rsp *http.Response) (*SearchMappingRulesForTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchMappingRulesForTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MappingRuleSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnassignMappingRuleFromTenantResponse parses an HTTP response from a UnassignMappingRuleFromTenantWithResponse call
func ParseUnassignMappingRuleFromTenantResponse(rsp *http.Response) (*UnassignMappingRuleFromTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignMappingRuleFromTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignMappingRuleToTenantResponse parses an HTTP response from a AssignMappingRuleToTenantWithResponse call
func ParseAssignMappingRuleToTenantResponse(rsp *http.Response) (*AssignMappingRuleToTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignMappingRuleToTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchRolesForTenantResponse parses an HTTP response from a SearchRolesForTenantWithResponse call
func ParseSearchRolesForTenantResponse(rsp *http.Response) (*SearchRolesForTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchRolesForTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnassignRoleFromTenantResponse parses an HTTP response from a UnassignRoleFromTenantWithResponse call
func ParseUnassignRoleFromTenantResponse(rsp *http.Response) (*UnassignRoleFromTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignRoleFromTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignRoleToTenantResponse parses an HTTP response from a AssignRoleToTenantWithResponse call
func ParseAssignRoleToTenantResponse(rsp *http.Response) (*AssignRoleToTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignRoleToTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchUsersForTenantResponse parses an HTTP response from a SearchUsersForTenantWithResponse call
func ParseSearchUsersForTenantResponse(rsp *http.Response) (*SearchUsersForTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchUsersForTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantUserSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnassignUserFromTenantResponse parses an HTTP response from a UnassignUserFromTenantWithResponse call
func ParseUnassignUserFromTenantResponse(rsp *http.Response) (*UnassignUserFromTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignUserFromTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignUserToTenantResponse parses an HTTP response from a AssignUserToTenantWithResponse call
func ParseAssignUserToTenantResponse(rsp *http.Response) (*AssignUserToTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignUserToTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetTopologyResponse parses an HTTP response from a GetTopologyWithResponse call
func ParseGetTopologyResponse(rsp *http.Response) (*GetTopologyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTopologyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TopologyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearchUserTasksResponse parses an HTTP response from a SearchUserTasksWithResponse call
func ParseSearchUserTasksResponse(rsp *http.Response) (*SearchUserTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchUserTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserTaskSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetUserTaskResponse parses an HTTP response from a GetUserTaskWithResponse call
func ParseGetUserTaskResponse(rsp *http.Response) (*GetUserTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserTaskResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserTaskResponse parses an HTTP response from a UpdateUserTaskWithResponse call
func ParseUpdateUserTaskResponse(rsp *http.Response) (*UpdateUserTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseUnassignUserTaskResponse parses an HTTP response from a UnassignUserTaskWithResponse call
func ParseUnassignUserTaskResponse(rsp *http.Response) (*UnassignUserTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignUserTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignUserTaskResponse parses an HTTP response from a AssignUserTaskWithResponse call
func ParseAssignUserTaskResponse(rsp *http.Response) (*AssignUserTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignUserTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseCompleteUserTaskResponse parses an HTTP response from a CompleteUserTaskWithResponse call
func ParseCompleteUserTaskResponse(rsp *http.Response) (*CompleteUserTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompleteUserTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetUserTaskFormResponse parses an HTTP response from a GetUserTaskFormWithResponse call
func ParseGetUserTaskFormResponse(rsp *http.Response) (*GetUserTaskFormResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserTaskFormResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FormResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearchUserTaskVariablesResponse parses an HTTP response from a SearchUserTaskVariablesWithResponse call
func ParseSearchUserTaskVariablesResponse(rsp *http.Response) (*SearchUserTaskVariablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchUserTaskVariablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VariableSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest UserCreateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchUsersResponse parses an HTTP response from a SearchUsersWithResponse call
func ParseSearchUsersResponse(rsp *http.Response) (*SearchUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserUpdateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchVariablesResponse parses an HTTP response from a SearchVariablesWithResponse call
func ParseSearchVariablesResponse(rsp *http.Response) (*SearchVariablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchVariablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VariableSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetVariableResponse parses an HTTP response from a GetVariableWithResponse call
func ParseGetVariableResponse(rsp *http.Response) (*GetVariableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VariableResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}
